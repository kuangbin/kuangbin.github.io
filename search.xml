<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算几何模板中的代码]]></title>
    <url>%2F2019%2F04%2F28%2F20190428%2F</url>
    <content type="text"><![CDATA[应群里大佬的要求，把模板里面计算几何部分的代码给贴出来。 具体参考最新的模板。 7 计算几何 7.1 二维几何 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997// `计算几何模板`const double eps = 1e-8;const double inf = 1e20;const double pi = acos(-1.0);const int maxp = 1010;//`Compares a double to zero`int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;//square of a doubleinline double sqr(double x)&#123;return x*x;&#125;/* * Point * Point() - Empty constructor * Point(double _x,double _y) - constructor * input() - double input * output() - %.2f output * operator == - compares x and y * operator &lt; - compares first by x, then by y * operator - - return new Point after subtracting curresponging x and y * operator ^ - cross product of 2d points * operator * - dot product * len() - gives length from origin * len2() - gives square of length from origin * distance(Point p) - gives distance from p * operator + Point b - returns new Point after adding curresponging x and y * operator * double k - returns new Point after multiplieing x and y by k * operator / double k - returns new Point after divideing x and y by k * rad(Point a,Point b)- returns the angle of Point a and Point b from this Point * trunc(double r) - return Point that if truncated the distance from center to r * rotleft() - returns 90 degree ccw rotated point * rotright() - returns 90 degree cw rotated point * rotate(Point p,double angle) - returns Point after rotateing the Point centering at p by angle radian ccw */struct Point&#123; double x,y; Point()&#123;&#125; Point(double _x,double _y)&#123; x = _x; y = _y; &#125; void input()&#123; scanf("%lf%lf",&amp;x,&amp;y); &#125; void output()&#123; printf("%.2f %.2f\n",x,y); &#125; bool operator == (Point b)const&#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0; &#125; bool operator &lt; (Point b)const&#123; return sgn(x-b.x)== 0?sgn(y-b.y)&lt;0:x&lt;b.x; &#125; Point operator -(const Point &amp;b)const&#123; return Point(x-b.x,y-b.y); &#125; //叉积 double operator ^(const Point &amp;b)const&#123; return x*b.y - y*b.x; &#125; //点积 double operator *(const Point &amp;b)const&#123; return x*b.x + y*b.y; &#125; //返回长度 double len()&#123; return hypot(x,y);//库函数 &#125; //返回长度的平方 double len2()&#123; return x*x + y*y; &#125; //返回两点的距离 double distance(Point p)&#123; return hypot(x-p.x,y-p.y); &#125; Point operator +(const Point &amp;b)const&#123; return Point(x+b.x,y+b.y); &#125; Point operator *(const double &amp;k)const&#123; return Point(x*k,y*k); &#125; Point operator /(const double &amp;k)const&#123; return Point(x/k,y/k); &#125; //`计算pa 和 pb 的夹角` //`就是求这个点看a,b 所成的夹角` //`测试 LightOJ1203` double rad(Point a,Point b)&#123; Point p = *this; return fabs(atan2( fabs((a-p)^(b-p)),(a-p)*(b-p) )); &#125; //`化为长度为r的向量` Point trunc(double r)&#123; double l = len(); if(!sgn(l))return *this; r /= l; return Point(x*r,y*r); &#125; //`逆时针旋转90度` Point rotleft()&#123; return Point(-y,x); &#125; //`顺时针旋转90度` Point rotright()&#123; return Point(y,-x); &#125; //`绕着p点逆时针旋转angle` Point rotate(Point p,double angle)&#123; Point v = (*this) - p; double c = cos(angle), s = sin(angle); return Point(p.x + v.x*c - v.y*s,p.y + v.x*s + v.y*c); &#125;&#125;;/* * Stores two points * Line() - Empty constructor * Line(Point _s,Point _e) - Line through _s and _e * operator == - checks if two points are same * Line(Point p,double angle) - one end p , another end at angle degree * Line(double a,double b,double c) - Line of equation ax + by + c = 0 * input() - inputs s and e * adjust() - orders in such a way that s &lt; e * length() - distance of se * angle() - return 0 &lt;= angle &lt; pi * relation(Point p) - 3 if point is on line * 1 if point on the left of line * 2 if point on the right of line * pointonseg(double p) - return true if point on segment * parallel(Line v) - return true if they are parallel * segcrossseg(Line v) - returns 0 if does not intersect * returns 1 if non-standard intersection * returns 2 if intersects * linecrossseg(Line v) - line and seg * linecrossline(Line v) - 0 if parallel * 1 if coincides * 2 if intersects * crosspoint(Line v) - returns intersection point * dispointtoline(Point p) - distance from point p to the line * dispointtoseg(Point p) - distance from p to the segment * dissegtoseg(Line v) - distance of two segment * lineprog(Point p) - returns projected point p on se line * symmetrypoint(Point p) - returns reflection point of p over se * */struct Line&#123; Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s = _s; e = _e; &#125; bool operator ==(Line v)&#123; return (s == v.s)&amp;&amp;(e == v.e); &#125; //`根据一个点和倾斜角angle确定直线,0&lt;=angle&lt;pi` Line(Point p,double angle)&#123; s = p; if(sgn(angle-pi/2) == 0)&#123; e = (s + Point(0,1)); &#125; else&#123; e = (s + Point(1,tan(angle))); &#125; &#125; //ax+by+c=0 Line(double a,double b,double c)&#123; if(sgn(a) == 0)&#123; s = Point(0,-c/b); e = Point(1,-c/b); &#125; else if(sgn(b) == 0)&#123; s = Point(-c/a,0); e = Point(-c/a,1); &#125; else&#123; s = Point(0,-c/b); e = Point(1,(-c-a)/b); &#125; &#125; void input()&#123; s.input(); e.input(); &#125; void adjust()&#123; if(e &lt; s)swap(s,e); &#125; //求线段长度 double length()&#123; return s.distance(e); &#125; //`返回直线倾斜角 0&lt;=angle&lt;pi` double angle()&#123; double k = atan2(e.y-s.y,e.x-s.x); if(sgn(k) &lt; 0)k += pi; if(sgn(k-pi) == 0)k -= pi; return k; &#125; //`点和直线关系` //`1 在左侧` //`2 在右侧` //`3 在直线上` int relation(Point p)&#123; int c = sgn((p-s)^(e-s)); if(c &lt; 0)return 1; else if(c &gt; 0)return 2; else return 3; &#125; // 点在线段上的判断 bool pointonseg(Point p)&#123; return sgn((p-s)^(e-s)) == 0 &amp;&amp; sgn((p-s)*(p-e)) &lt;= 0; &#125; //`两向量平行(对应直线平行或重合)` bool parallel(Line v)&#123; return sgn((e-s)^(v.e-v.s)) == 0; &#125; //`两线段相交判断` //`2 规范相交` //`1 非规范相交` //`0 不相交` int segcrossseg(Line v)&#123; int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); int d3 = sgn((v.e-v.s)^(s-v.s)); int d4 = sgn((v.e-v.s)^(e-v.s)); if( (d1^d2)==-2 &amp;&amp; (d3^d4)==-2 )return 2; return (d1==0 &amp;&amp; sgn((v.s-s)*(v.s-e))&lt;=0) || (d2==0 &amp;&amp; sgn((v.e-s)*(v.e-e))&lt;=0) || (d3==0 &amp;&amp; sgn((s-v.s)*(s-v.e))&lt;=0) || (d4==0 &amp;&amp; sgn((e-v.s)*(e-v.e))&lt;=0); &#125; //`直线和线段相交判断` //`-*this line -v seg` //`2 规范相交` //`1 非规范相交` //`0 不相交` int linecrossseg(Line v)&#123; int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); if((d1^d2)==-2) return 2; return (d1==0||d2==0); &#125; //`两直线关系` //`0 平行` //`1 重合` //`2 相交` int linecrossline(Line v)&#123; if((*this).parallel(v)) return v.relation(s)==3; return 2; &#125; //`求两直线的交点` //`要保证两直线不平行或重合` Point crosspoint(Line v)&#123; double a1 = (v.e-v.s)^(s-v.s); double a2 = (v.e-v.s)^(e-v.s); return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1)); &#125; //点到直线的距离 double dispointtoline(Point p)&#123; return fabs((p-s)^(e-s))/length(); &#125; //点到线段的距离 double dispointtoseg(Point p)&#123; if(sgn((p-s)*(e-s))&lt;0 || sgn((p-e)*(s-e))&lt;0) return min(p.distance(s),p.distance(e)); return dispointtoline(p); &#125; //`返回线段到线段的距离` //`前提是两线段不相交，相交距离就是0了` double dissegtoseg(Line v)&#123; return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e))); &#125; //`返回点p在直线上的投影` Point lineprog(Point p)&#123; return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) ); &#125; //`返回点p关于直线的对称点` Point symmetrypoint(Point p)&#123; Point q = lineprog(p); return Point(2*q.x-p.x,2*q.y-p.y); &#125;&#125;;//圆struct circle&#123; Point p;//圆心 double r;//半径 circle()&#123;&#125; circle(Point _p,double _r)&#123; p = _p; r = _r; &#125; circle(double x,double y,double _r)&#123; p = Point(x,y); r = _r; &#125; //`三角形的外接圆` //`需要Point的+ / rotate() 以及Line的crosspoint()` //`利用两条边的中垂线得到圆心` //`测试：UVA12304` circle(Point a,Point b,Point c)&#123; Line u = Line((a+b)/2,((a+b)/2)+((b-a).rotleft())); Line v = Line((b+c)/2,((b+c)/2)+((c-b).rotleft())); p = u.crosspoint(v); r = p.distance(a); &#125; //`三角形的内切圆` //`参数bool t没有作用，只是为了和上面外接圆函数区别` //`测试：UVA12304` circle(Point a,Point b,Point c,bool t)&#123; Line u,v; double m = atan2(b.y-a.y,b.x-a.x), n = atan2(c.y-a.y,c.x-a.x); u.s = a; u.e = u.s + Point(cos((n+m)/2),sin((n+m)/2)); v.s = b; m = atan2(a.y-b.y,a.x-b.x) , n = atan2(c.y-b.y,c.x-b.x); v.e = v.s + Point(cos((n+m)/2),sin((n+m)/2)); p = u.crosspoint(v); r = Line(a,b).dispointtoseg(p); &#125; //输入 void input()&#123; p.input(); scanf("%lf",&amp;r); &#125; //输出 void output()&#123; printf("%.2lf %.2lf %.2lf\n",p.x,p.y,r); &#125; bool operator == (circle v)&#123; return (p==v.p) &amp;&amp; sgn(r-v.r)==0; &#125; bool operator &lt; (circle v)const&#123; return ((p&lt;v.p)||((p==v.p)&amp;&amp;sgn(r-v.r)&lt;0)); &#125; //面积 double area()&#123; return pi*r*r; &#125; //周长 double circumference()&#123; return 2*pi*r; &#125; //`点和圆的关系` //`0 圆外` //`1 圆上` //`2 圆内` int relation(Point b)&#123; double dst = b.distance(p); if(sgn(dst-r) &lt; 0)return 2; else if(sgn(dst-r)==0)return 1; return 0; &#125; //`线段和圆的关系` //`比较的是圆心到线段的距离和半径的关系` int relationseg(Line v)&#123; double dst = v.dispointtoseg(p); if(sgn(dst-r) &lt; 0)return 2; else if(sgn(dst-r) == 0)return 1; return 0; &#125; //`直线和圆的关系` //`比较的是圆心到直线的距离和半径的关系` int relationline(Line v)&#123; double dst = v.dispointtoline(p); if(sgn(dst-r) &lt; 0)return 2; else if(sgn(dst-r) == 0)return 1; return 0; &#125; //`两圆的关系` //`5 相离` //`4 外切` //`3 相交` //`2 内切` //`1 内含` //`需要Point的distance` //`测试：UVA12304` int relationcircle(circle v)&#123; double d = p.distance(v.p); if(sgn(d-r-v.r) &gt; 0)return 5; if(sgn(d-r-v.r) == 0)return 4; double l = fabs(r-v.r); if(sgn(d-r-v.r)&lt;0 &amp;&amp; sgn(d-l)&gt;0)return 3; if(sgn(d-l)==0)return 2; if(sgn(d-l)&lt;0)return 1; &#125; //`求两个圆的交点，返回0表示没有交点，返回1是一个交点，2是两个交点` //`需要relationcircle` //`测试：UVA12304` int pointcrosscircle(circle v,Point &amp;p1,Point &amp;p2)&#123; int rel = relationcircle(v); if(rel == 1 || rel == 5)return 0; double d = p.distance(v.p); double l = (d*d+r*r-v.r*v.r)/(2*d); double h = sqrt(r*r-l*l); Point tmp = p + (v.p-p).trunc(l); p1 = tmp + ((v.p-p).rotleft().trunc(h)); p2 = tmp + ((v.p-p).rotright().trunc(h)); if(rel == 2 || rel == 4) return 1; return 2; &#125; //`求直线和圆的交点，返回交点个数` int pointcrossline(Line v,Point &amp;p1,Point &amp;p2)&#123; if(!(*this).relationline(v))return 0; Point a = v.lineprog(p); double d = v.dispointtoline(p); d = sqrt(r*r-d*d); if(sgn(d) == 0)&#123; p1 = a; p2 = a; return 1; &#125; p1 = a + (v.e-v.s).trunc(d); p2 = a - (v.e-v.s).trunc(d); return 2; &#125; //`得到过a,b两点，半径为r1的两个圆` int gercircle(Point a,Point b,double r1,circle &amp;c1,circle &amp;c2)&#123; circle x(a,r1),y(b,r1); int t = x.pointcrosscircle(y,c1.p,c2.p); if(!t)return 0; c1.r = c2.r = r; return t; &#125; //`得到与直线u相切，过点q,半径为r1的圆` //`测试：UVA12304` int getcircle(Line u,Point q,double r1,circle &amp;c1,circle &amp;c2)&#123; double dis = u.dispointtoline(q); if(sgn(dis-r1*2)&gt;0)return 0; if(sgn(dis) == 0)&#123; c1.p = q + ((u.e-u.s).rotleft().trunc(r1)); c2.p = q + ((u.e-u.s).rotright().trunc(r1)); c1.r = c2.r = r1; return 2; &#125; Line u1 = Line((u.s + (u.e-u.s).rotleft().trunc(r1)),(u.e + (u.e-u.s).rotleft().trunc(r1))); Line u2 = Line((u.s + (u.e-u.s).rotright().trunc(r1)),(u.e + (u.e-u.s).rotright().trunc(r1))); circle cc = circle(q,r1); Point p1,p2; if(!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2); c1 = circle(p1,r1); if(p1 == p2)&#123; c2 = c1; return 1; &#125; c2 = circle(p2,r1); return 2; &#125; //`同时与直线u,v相切，半径为r1的圆` //`测试：UVA12304` int getcircle(Line u,Line v,double r1,circle &amp;c1,circle &amp;c2,circle &amp;c3,circle &amp;c4)&#123; if(u.parallel(v))return 0;//两直线平行 Line u1 = Line(u.s + (u.e-u.s).rotleft().trunc(r1),u.e + (u.e-u.s).rotleft().trunc(r1)); Line u2 = Line(u.s + (u.e-u.s).rotright().trunc(r1),u.e + (u.e-u.s).rotright().trunc(r1)); Line v1 = Line(v.s + (v.e-v.s).rotleft().trunc(r1),v.e + (v.e-v.s).rotleft().trunc(r1)); Line v2 = Line(v.s + (v.e-v.s).rotright().trunc(r1),v.e + (v.e-v.s).rotright().trunc(r1)); c1.r = c2.r = c3.r = c4.r = r1; c1.p = u1.crosspoint(v1); c2.p = u1.crosspoint(v2); c3.p = u2.crosspoint(v1); c4.p = u2.crosspoint(v2); return 4; &#125; //`同时与不相交圆cx,cy相切，半径为r1的圆` //`测试：UVA12304` int getcircle(circle cx,circle cy,double r1,circle &amp;c1,circle &amp;c2)&#123; circle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r); int t = x.pointcrosscircle(y,c1.p,c2.p); if(!t)return 0; c1.r = c2.r = r1; return t; &#125; //`过一点作圆的切线(先判断点和圆的关系)` //`测试：UVA12304` int tangentline(Point q,Line &amp;u,Line &amp;v)&#123; int x = relation(q); if(x == 2)return 0; if(x == 1)&#123; u = Line(q,q + (q-p).rotleft()); v = u; return 1; &#125; double d = p.distance(q); double l = r*r/d; double h = sqrt(r*r-l*l); u = Line(q,p + ((q-p).trunc(l) + (q-p).rotleft().trunc(h))); v = Line(q,p + ((q-p).trunc(l) + (q-p).rotright().trunc(h))); return 2; &#125; //`求两圆相交的面积` double areacircle(circle v)&#123; int rel = relationcircle(v); if(rel &gt;= 4)return 0.0; if(rel &lt;= 2)return min(area(),v.area()); double d = p.distance(v.p); double hf = (r+v.r+d)/2.0; double ss = 2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d)); double a1 = acos((r*r+d*d-v.r*v.r)/(2.0*r*d)); a1 = a1*r*r; double a2 = acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d)); a2 = a2*v.r*v.r; return a1+a2-ss; &#125; //`求圆和三角形pab的相交面积` //`测试：POJ3675 HDU3982 HDU2892` double areatriangle(Point a,Point b)&#123; if(sgn((p-a)^(p-b)) == 0)return 0.0; Point q[5]; int len = 0; q[len++] = a; Line l(a,b); Point p1,p2; if(pointcrossline(l,q[1],q[2])==2)&#123; if(sgn((a-q[1])*(b-q[1]))&lt;0)q[len++] = q[1]; if(sgn((a-q[2])*(b-q[2]))&lt;0)q[len++] = q[2]; &#125; q[len++] = b; if(len == 4 &amp;&amp; sgn((q[0]-q[1])*(q[2]-q[1]))&gt;0)swap(q[1],q[2]); double res = 0; for(int i = 0;i &lt; len-1;i++)&#123; if(relation(q[i])==0||relation(q[i+1])==0)&#123; double arg = p.rad(q[i],q[i+1]); res += r*r*arg/2.0; &#125; else&#123; res += fabs((q[i]-p)^(q[i+1]-p))/2.0; &#125; &#125; return res; &#125;&#125;;/* * n,p Line l for each side * input(int _n) - inputs _n size polygon * add(Point q) - adds a point at end of the list * getline() - populates line array * cmp - comparision in convex_hull order * norm() - sorting in convex_hull order * getconvex(polygon &amp;convex) - returns convex hull in convex * Graham(polygon &amp;convex) - returns convex hull in convex * isconvex() - checks if convex * relationpoint(Point q) - returns 3 if q is a vertex * 2 if on a side * 1 if inside * 0 if outside * convexcut(Line u,polygon &amp;po) - left side of u in po * gercircumference() - returns side length * getarea() - returns area * getdir() - returns 0 for cw, 1 for ccw * getbarycentre() - returns barycenter * */struct polygon&#123; int n; Point p[maxp]; Line l[maxp]; void input(int _n)&#123; n = _n; for(int i = 0;i &lt; n;i++) p[i].input(); &#125; void add(Point q)&#123; p[n++] = q; &#125; void getline()&#123; for(int i = 0;i &lt; n;i++)&#123; l[i] = Line(p[i],p[(i+1)%n]); &#125; &#125; struct cmp&#123; Point p; cmp(const Point &amp;p0)&#123;p = p0;&#125; bool operator()(const Point &amp;aa,const Point &amp;bb)&#123; Point a = aa, b = bb; int d = sgn((a-p)^(b-p)); if(d == 0)&#123; return sgn(a.distance(p)-b.distance(p)) &lt; 0; &#125; return d &gt; 0; &#125; &#125;; //`进行极角排序` //`首先需要找到最左下角的点` //`需要重载号好Point的 &lt; 操作符(min函数要用) ` void norm()&#123; Point mi = p[0]; for(int i = 1;i &lt; n;i++)mi = min(mi,p[i]); sort(p,p+n,cmp(mi)); &#125; //`得到凸包` //`得到的凸包里面的点编号是0$\sim$n-1的` //`两种凸包的方法` //`注意如果有影响，要特判下所有点共点，或者共线的特殊情况` //`测试 LightOJ1203 LightOJ1239` void getconvex(polygon &amp;convex)&#123; sort(p,p+n); convex.n = n; for(int i = 0;i &lt; min(n,2);i++)&#123; convex.p[i] = p[i]; &#125; if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 if(n &lt;= 2)return; int &amp;top = convex.n; top = 1; for(int i = 2;i &lt; n;i++)&#123; while(top &amp;&amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) &lt;= 0) top--; convex.p[++top] = p[i]; &#125; int temp = top; convex.p[++top] = p[n-2]; for(int i = n-3;i &gt;= 0;i--)&#123; while(top != temp &amp;&amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) &lt;= 0) top--; convex.p[++top] = p[i]; &#125; if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 convex.norm();//`原来得到的是顺时针的点，排序后逆时针` &#125; //`得到凸包的另外一种方法` //`测试 LightOJ1203 LightOJ1239` void Graham(polygon &amp;convex)&#123; norm(); int &amp;top = convex.n; top = 0; if(n == 1)&#123; top = 1; convex.p[0] = p[0]; return; &#125; if(n == 2)&#123; top = 2; convex.p[0] = p[0]; convex.p[1] = p[1]; if(convex.p[0] == convex.p[1])top--; return; &#125; convex.p[0] = p[0]; convex.p[1] = p[1]; top = 2; for(int i = 2;i &lt; n;i++)&#123; while( top &gt; 1 &amp;&amp; sgn((convex.p[top-1]-convex.p[top-2])^(p[i]-convex.p[top-2])) &lt;= 0 ) top--; convex.p[top++] = p[i]; &#125; if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 &#125; //`判断是不是凸的` bool isconvex()&#123; bool s[2]; memset(s,false,sizeof(s)); for(int i = 0;i &lt; n;i++)&#123; int j = (i+1)%n; int k = (j+1)%n; s[sgn((p[j]-p[i])^(p[k]-p[i]))+1] = true; if(s[0] &amp;&amp; s[2])return false; &#125; return true; &#125; //`判断点和任意多边形的关系` //` 3 点上` //` 2 边上` //` 1 内部` //` 0 外部` int relationpoint(Point q)&#123; for(int i = 0;i &lt; n;i++)&#123; if(p[i] == q)return 3; &#125; getline(); for(int i = 0;i &lt; n;i++)&#123; if(l[i].pointonseg(q))return 2; &#125; int cnt = 0; for(int i = 0;i &lt; n;i++)&#123; int j = (i+1)%n; int k = sgn((q-p[j])^(p[i]-p[j])); int u = sgn(p[i].y-q.y); int v = sgn(p[j].y-q.y); if(k &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0)cnt++; if(k &lt; 0 &amp;&amp; v &lt; 0 &amp;&amp; u &gt;= 0)cnt--; &#125; return cnt != 0; &#125; //`直线u切割凸多边形左侧` //`注意直线方向` //`测试：HDU3982` void convexcut(Line u,polygon &amp;po)&#123; int &amp;top = po.n;//注意引用 top = 0; for(int i = 0;i &lt; n;i++)&#123; int d1 = sgn((u.e-u.s)^(p[i]-u.s)); int d2 = sgn((u.e-u.s)^(p[(i+1)%n]-u.s)); if(d1 &gt;= 0)po.p[top++] = p[i]; if(d1*d2 &lt; 0)po.p[top++] = u.crosspoint(Line(p[i],p[(i+1)%n])); &#125; &#125; //`得到周长` //`测试 LightOJ1239` double getcircumference()&#123; double sum = 0; for(int i = 0;i &lt; n;i++)&#123; sum += p[i].distance(p[(i+1)%n]); &#125; return sum; &#125; //`得到面积` double getarea()&#123; double sum = 0; for(int i = 0;i &lt; n;i++)&#123; sum += (p[i]^p[(i+1)%n]); &#125; return fabs(sum)/2; &#125; //`得到方向` //` 1 表示逆时针，0表示顺时针` bool getdir()&#123; double sum = 0; for(int i = 0;i &lt; n;i++) sum += (p[i]^p[(i+1)%n]); if(sgn(sum) &gt; 0)return 1; return 0; &#125; //`得到重心` Point getbarycentre()&#123; Point ret(0,0); double area = 0; for(int i = 1;i &lt; n-1;i++)&#123; double tmp = (p[i]-p[0])^(p[i+1]-p[0]); if(sgn(tmp) == 0)continue; area += tmp; ret.x += (p[0].x+p[i].x+p[i+1].x)/3*tmp; ret.y += (p[0].y+p[i].y+p[i+1].y)/3*tmp; &#125; if(sgn(area)) ret = ret/area; return ret; &#125; //`多边形和圆交的面积` //`测试：POJ3675 HDU3982 HDU2892` double areacircle(circle c)&#123; double ans = 0; for(int i = 0;i &lt; n;i++)&#123; int j = (i+1)%n; if(sgn( (p[j]-c.p)^(p[i]-c.p) ) &gt;= 0) ans += c.areatriangle(p[i],p[j]); else ans -= c.areatriangle(p[i],p[j]); &#125; return fabs(ans); &#125; //`多边形和圆关系` //` 2 圆完全在多边形内` //` 1 圆在多边形里面，碰到了多边形边界` //` 0 其它` int relationcircle(circle c)&#123; getline(); int x = 2; if(relationpoint(c.p) != 1)return 0;//圆心不在内部 for(int i = 0;i &lt; n;i++)&#123; if(c.relationseg(l[i])==2)return 0; if(c.relationseg(l[i])==1)x = 1; &#125; return x; &#125;&#125;;//`AB X AC`double cross(Point A,Point B,Point C)&#123; return (B-A)^(C-A);&#125;//`AB*AC`double dot(Point A,Point B,Point C)&#123; return (B-A)*(C-A);&#125;//`最小矩形面积覆盖`//` A 必须是凸包(而且是逆时针顺序)`//` 测试 UVA 10173`double minRectangleCover(polygon A)&#123; //`要特判A.n &lt; 3的情况` if(A.n &lt; 3)return 0.0; A.p[A.n] = A.p[0]; double ans = -1; int r = 1, p = 1, q; for(int i = 0;i &lt; A.n;i++)&#123; //`卡出离边A.p[i] - A.p[i+1]最远的点` while( sgn( cross(A.p[i],A.p[i+1],A.p[r+1]) - cross(A.p[i],A.p[i+1],A.p[r]) ) &gt;= 0 ) r = (r+1)%A.n; //`卡出A.p[i] - A.p[i+1]方向上正向n最远的点` while(sgn( dot(A.p[i],A.p[i+1],A.p[p+1]) - dot(A.p[i],A.p[i+1],A.p[p]) ) &gt;= 0 ) p = (p+1)%A.n; if(i == 0)q = p; //`卡出A.p[i] - A.p[i+1]方向上负向最远的点` while(sgn(dot(A.p[i],A.p[i+1],A.p[q+1]) - dot(A.p[i],A.p[i+1],A.p[q])) &lt;= 0) q = (q+1)%A.n; double d = (A.p[i] - A.p[i+1]).len2(); double tmp = cross(A.p[i],A.p[i+1],A.p[r]) * (dot(A.p[i],A.p[i+1],A.p[p]) - dot(A.p[i],A.p[i+1],A.p[q]))/d; if(ans &lt; 0 || ans &gt; tmp)ans = tmp; &#125; return ans;&#125;//`直线切凸多边形`//`多边形是逆时针的，在q1q2的左侧`//`测试:HDU3982`vector&lt;Point&gt; convexCut(const vector&lt;Point&gt; &amp;ps,Point q1,Point q2)&#123; vector&lt;Point&gt;qs; int n = ps.size(); for(int i = 0;i &lt; n;i++)&#123; Point p1 = ps[i], p2 = ps[(i+1)%n]; int d1 = sgn((q2-q1)^(p1-q1)), d2 = sgn((q2-q1)^(p2-q1)); if(d1 &gt;= 0) qs.push_back(p1); if(d1 * d2 &lt; 0) qs.push_back(Line(p1,p2).crosspoint(Line(q1,q2))); &#125; return qs;&#125;//`半平面交`//`测试 POJ3335 POJ1474 POJ1279`//***************************struct halfplane:public Line&#123; double angle; halfplane()&#123;&#125; //`表示向量s-&gt;e逆时针(左侧)的半平面` halfplane(Point _s,Point _e)&#123; s = _s; e = _e; &#125; halfplane(Line v)&#123; s = v.s; e = v.e; &#125; void calcangle()&#123; angle = atan2(e.y-s.y,e.x-s.x); &#125; bool operator &lt;(const halfplane &amp;b)const&#123; return angle &lt; b.angle; &#125;&#125;;struct halfplanes&#123; int n; halfplane hp[maxp]; Point p[maxp]; int que[maxp]; int st,ed; void push(halfplane tmp)&#123; hp[n++] = tmp; &#125; //去重 void unique()&#123; int m = 1; for(int i = 1;i &lt; n;i++)&#123; if(sgn(hp[i].angle-hp[i-1].angle) != 0) hp[m++] = hp[i]; else if(sgn( (hp[m-1].e-hp[m-1].s)^(hp[i].s-hp[m-1].s) ) &gt; 0) hp[m-1] = hp[i]; &#125; n = m; &#125; bool halfplaneinsert()&#123; for(int i = 0;i &lt; n;i++)hp[i].calcangle(); sort(hp,hp+n); unique(); que[st=0] = 0; que[ed=1] = 1; p[1] = hp[0].crosspoint(hp[1]); for(int i = 2;i &lt; n;i++)&#123; while(st&lt;ed &amp;&amp; sgn((hp[i].e-hp[i].s)^(p[ed]-hp[i].s))&lt;0)ed--; while(st&lt;ed &amp;&amp; sgn((hp[i].e-hp[i].s)^(p[st+1]-hp[i].s))&lt;0)st++; que[++ed] = i; if(hp[i].parallel(hp[que[ed-1]]))return false; p[ed]=hp[i].crosspoint(hp[que[ed-1]]); &#125; while(st&lt;ed &amp;&amp; sgn((hp[que[st]].e-hp[que[st]].s)^(p[ed]-hp[que[st]].s))&lt;0)ed--; while(st&lt;ed &amp;&amp; sgn((hp[que[ed]].e-hp[que[ed]].s)^(p[st+1]-hp[que[ed]].s))&lt;0)st++; if(st+1&gt;=ed)return false; return true; &#125; //`得到最后半平面交得到的凸多边形` //`需要先调用halfplaneinsert() 且返回true` void getconvex(polygon &amp;con)&#123; p[st] = hp[que[st]].crosspoint(hp[que[ed]]); con.n = ed-st+1; for(int j = st,i = 0;j &lt;= ed;i++,j++) con.p[i] = p[j]; &#125;&#125;;//***************************const int maxn = 1010;struct circles&#123; circle c[maxn]; double ans[maxn];//`ans[i]表示被覆盖了i次的面积` double pre[maxn]; int n; circles()&#123;&#125; void add(circle cc)&#123; c[n++] = cc; &#125; //`x包含在y中` bool inner(circle x,circle y)&#123; if(x.relationcircle(y) != 1)return 0; return sgn(x.r-y.r)&lt;=0?1:0; &#125; //圆的面积并去掉内含的圆 void init_or()&#123; bool mark[maxn] = &#123;0&#125;; int i,j,k=0; for(i = 0;i &lt; n;i++)&#123; for(j = 0;j &lt; n;j++) if(i != j &amp;&amp; !mark[j])&#123; if( (c[i]==c[j])||inner(c[i],c[j]) )break; &#125; if(j &lt; n)mark[i] = 1; &#125; for(i = 0;i &lt; n;i++) if(!mark[i]) c[k++] = c[i]; n = k; &#125; //`圆的面积交去掉内含的圆` void init_add()&#123; int i,j,k; bool mark[maxn] = &#123;0&#125;; for(i = 0;i &lt; n;i++)&#123; for(j = 0;j &lt; n;j++) if(i != j &amp;&amp; !mark[j])&#123; if( (c[i]==c[j])||inner(c[j],c[i]) )break; &#125; if(j &lt; n)mark[i] = 1; &#125; for(i = 0;i &lt; n;i++) if(!mark[i]) c[k++] = c[i]; n = k; &#125; //`半径为r的圆，弧度为th对应的弓形的面积` double areaarc(double th,double r)&#123; return 0.5*r*r*(th-sin(th)); &#125; //`测试SPOJVCIRCLES SPOJCIRUT` //`SPOJVCIRCLES求n个圆并的面积，需要加上init\_or()去掉重复圆（否则WA）` //`SPOJCIRUT 是求被覆盖k次的面积，不能加init\_or()` //`对于求覆盖多少次面积的问题，不能解决相同圆，而且不能init\_or()` //`求多圆面积并，需要init\_or,其中一个目的就是去掉相同圆` void getarea()&#123; memset(ans,0,sizeof(ans)); vector&lt;pair&lt;double,int&gt; &gt;v; for(int i = 0;i &lt; n;i++)&#123; v.clear(); v.push_back(make_pair(-pi,1)); v.push_back(make_pair(pi,-1)); for(int j = 0;j &lt; n;j++) if(i != j)&#123; Point q = (c[j].p - c[i].p); double ab = q.len(),ac = c[i].r, bc = c[j].r; if(sgn(ab+ac-bc)&lt;=0)&#123; v.push_back(make_pair(-pi,1)); v.push_back(make_pair(pi,-1)); continue; &#125; if(sgn(ab+bc-ac)&lt;=0)continue; if(sgn(ab-ac-bc)&gt;0)continue; double th = atan2(q.y,q.x), fai = acos((ac*ac+ab*ab-bc*bc)/(2.0*ac*ab)); double a0 = th-fai; if(sgn(a0+pi)&lt;0)a0+=2*pi; double a1 = th+fai; if(sgn(a1-pi)&gt;0)a1-=2*pi; if(sgn(a0-a1)&gt;0)&#123; v.push_back(make_pair(a0,1)); v.push_back(make_pair(pi,-1)); v.push_back(make_pair(-pi,1)); v.push_back(make_pair(a1,-1)); &#125; else&#123; v.push_back(make_pair(a0,1)); v.push_back(make_pair(a1,-1)); &#125; &#125; sort(v.begin(),v.end()); int cur = 0; for(int j = 0;j &lt; v.size();j++)&#123; if(cur &amp;&amp; sgn(v[j].first-pre[cur]))&#123; ans[cur] += areaarc(v[j].first-pre[cur],c[i].r); ans[cur] += 0.5*(Point(c[i].p.x+c[i].r*cos(pre[cur]),c[i].p.y+c[i].r*sin(pre[cur]))^Point(c[i].p.x+c[i].r*cos(v[j].first),c[i].p.y+c[i].r*sin(v[j].first))); &#125; cur += v[j].second; pre[cur] = v[j].first; &#125; &#125; for(int i = 1;i &lt; n;i++) ans[i] -= ans[i+1]; &#125;&#125;; 7.2 三维几何 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188const double eps = 1e-8;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct Point3&#123; double x,y,z; Point3(double _x = 0,double _y = 0,double _z = 0)&#123; x = _x; y = _y; z = _z; &#125; void input()&#123; scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;z); &#125; void output()&#123; scanf("%.2lf %.2lf %.2lf\n",x,y,z); &#125; bool operator ==(const Point3 &amp;b)const&#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0 &amp;&amp; sgn(z-b.z) == 0; &#125; bool operator &lt;(const Point3 &amp;b)const&#123; return sgn(x-b.x)==0?(sgn(y-b.y)==0?sgn(z-b.z)&lt;0:y&lt;b.y):x&lt;b.x; &#125; double len()&#123; return sqrt(x*x+y*y+z*z); &#125; double len2()&#123; return x*x+y*y+z*z; &#125; double distance(const Point3 &amp;b)const&#123; return sqrt((x-b.x)*(x-b.x)+(y-b.y)*(y-b.y)+(z-b.z)*(z-b.z)); &#125; Point3 operator -(const Point3 &amp;b)const&#123; return Point3(x-b.x,y-b.y,z-b.z); &#125; Point3 operator +(const Point3 &amp;b)const&#123; return Point3(x+b.x,y+b.y,z+b.z); &#125; Point3 operator *(const double &amp;k)const&#123; return Point3(x*k,y*k,z*k); &#125; Point3 operator /(const double &amp;k)const&#123; return Point3(x/k,y/k,z/k); &#125; //点乘 double operator *(const Point3 &amp;b)const&#123; return x*b.x+y*b.y+z*b.z; &#125; //叉乘 Point3 operator ^(const Point3 &amp;b)const&#123; return Point3(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x); &#125; double rad(Point3 a,Point3 b)&#123; Point3 p = (*this); return acos( ( (a-p)*(b-p) )/ (a.distance(p)*b.distance(p)) ); &#125; //变换长度 Point3 trunc(double r)&#123; double l = len(); if(!sgn(l))return *this; r /= l; return Point3(x*r,y*r,z*r); &#125;&#125;;struct Line3&#123; Point3 s,e; Line3()&#123;&#125; Line3(Point3 _s,Point3 _e) &#123; s = _s; e = _e; &#125; bool operator ==(const Line3 v) &#123; return (s==v.s)&amp;&amp;(e==v.e); &#125; void input() &#123; s.input(); e.input(); &#125; double length() &#123; return s.distance(e); &#125; //点到直线距离 double dispointtoline(Point3 p) &#123; return ((e-s)^(p-s)).len()/s.distance(e); &#125; //点到线段距离 double dispointtoseg(Point3 p) &#123; if(sgn((p-s)*(e-s)) &lt; 0 || sgn((p-e)*(s-e)) &lt; 0) return min(p.distance(s),e.distance(p)); return dispointtoline(p); &#125; //`返回点p在直线上的投影` Point3 lineprog(Point3 p) &#123; return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) ); &#125; //`p绕此向量逆时针arg角度` Point3 rotate(Point3 p,double ang) &#123; if(sgn(((s-p)^(e-p)).len()) == 0)return p; Point3 f1 = (e-s)^(p-s); Point3 f2 = (e-s)^(f1); double len = ((s-p)^(e-p)).len()/s.distance(e); f1 = f1.trunc(len); f2 = f2.trunc(len); Point3 h = p+f2; Point3 pp = h+f1; return h + ((p-h)*cos(ang)) + ((pp-h)*sin(ang)); &#125; //`点在直线上` bool pointonseg(Point3 p) &#123; return sgn( ((s-p)^(e-p)).len() ) == 0 &amp;&amp; sgn((s-p)*(e-p)) == 0; &#125;&#125;;struct Plane&#123; Point3 a,b,c,o;//`平面上的三个点，以及法向量` Plane()&#123;&#125; Plane(Point3 _a,Point3 _b,Point3 _c) &#123; a = _a; b = _b; c = _c; o = pvec(); &#125; Point3 pvec() &#123; return (b-a)^(c-a); &#125; //`ax+by+cz+d = 0` Plane(double _a,double _b,double _c,double _d) &#123; o = Point3(_a,_b,_c); if(sgn(_a) != 0) a = Point3((-_d-_c-_b)/_a,1,1); else if(sgn(_b) != 0) a = Point3(1,(-_d-_c-_a)/_b,1); else if(sgn(_c) != 0) a = Point3(1,1,(-_d-_a-_b)/_c); &#125; //`点在平面上的判断` bool pointonplane(Point3 p) &#123; return sgn((p-a)*o) == 0; &#125; //`两平面夹角` double angleplane(Plane f) &#123; return acos(o*f.o)/(o.len()*f.o.len()); &#125; //`平面和直线的交点，返回值是交点个数` int crossline(Line3 u,Point3 &amp;p) &#123; double x = o*(u.e-a); double y = o*(u.s-a); double d = x-y; if(sgn(d) == 0)return 0; p = ((u.s*x)-(u.e*y))/d; return 1; &#125; //`点到平面最近点(也就是投影)` Point3 pointtoplane(Point3 p) &#123; Line3 u = Line3(p,p+o); crossline(u,p); return p; &#125; //`平面和平面的交线` int crossplane(Plane f,Line3 &amp;u) &#123; Point3 oo = o^f.o; Point3 v = o^oo; double d = fabs(f.o*v); if(sgn(d) == 0)return 0; Point3 q = a + (v*(f.o*(f.a-a))/d); u = Line3(q,q+oo); return 1; &#125;&#125;; 7.3 平面最近点对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int MAXN = 100010;const double eps = 1e-8;const double INF = 1e20;struct Point&#123; double x,y; void input()&#123; scanf("%lf%lf",&amp;x,&amp;y); &#125;&#125;;double dist(Point a,Point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));&#125;Point p[MAXN];Point tmpt[MAXN];bool cmpx(Point a,Point b)&#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;bool cmpy(Point a,Point b)&#123; return a.y &lt; b.y || (a.y == b.y &amp;&amp; a.x &lt; b.x);&#125;double Closest_Pair(int left,int right)&#123; double d = INF; if(left == right)return d; if(left+1 == right)return dist(p[left],p[right]); int mid = (left+right)/2; double d1 = Closest_Pair(left,mid); double d2 = Closest_Pair(mid+1,right); d = min(d1,d2); int cnt = 0; for(int i = left;i &lt;= right;i++)&#123; if(fabs(p[mid].x - p[i].x) &lt;= d) tmpt[cnt++] = p[i]; &#125; sort(tmpt,tmpt+cnt,cmpy); for(int i = 0;i &lt; cnt;i++)&#123; for(int j = i+1;j &lt; cnt &amp;&amp; tmpt[j].y - tmpt[i].y &lt; d;j++) d = min(d,dist(tmpt[i],tmpt[j])); &#125; return d;&#125;int main()&#123; int n; while(scanf("%d",&amp;n) == 1 &amp;&amp; n)&#123; for(int i = 0;i &lt; n;i++)p[i].input(); sort(p,p+n,cmpx); printf("%.2lf\n",Closest_Pair(0,n-1)); &#125; return 0;&#125; 7.4 三维凸包 7.4.1 HDU4273 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246const double eps = 1e-8;const int MAXN = 550;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct Point3&#123; double x,y,z; Point3(double _x = 0, double _y = 0, double _z = 0)&#123; x = _x; y = _y; z = _z; &#125; void input()&#123; scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;z); &#125; bool operator ==(const Point3 &amp;b)const&#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0 &amp;&amp; sgn(z-b.z) == 0; &#125; double len()&#123; return sqrt(x*x+y*y+z*z); &#125; double len2()&#123; return x*x+y*y+z*z; &#125; double distance(const Point3 &amp;b)const&#123; return sqrt((x-b.x)*(x-b.x)+(y-b.y)*(y-b.y)+(z-b.z)*(z-b.z)); &#125; Point3 operator -(const Point3 &amp;b)const&#123; return Point3(x-b.x,y-b.y,z-b.z); &#125; Point3 operator +(const Point3 &amp;b)const&#123; return Point3(x+b.x,y+b.y,z+b.z); &#125; Point3 operator *(const double &amp;k)const&#123; return Point3(x*k,y*k,z*k); &#125; Point3 operator /(const double &amp;k)const&#123; return Point3(x/k,y/k,z/k); &#125; //点乘 double operator *(const Point3 &amp;b)const&#123; return x*b.x + y*b.y + z*b.z; &#125; //叉乘 Point3 operator ^(const Point3 &amp;b)const&#123; return Point3(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x); &#125;&#125;;struct CH3D&#123; struct face&#123; //表示凸包一个面上的三个点的编号 int a,b,c; //表示该面是否属于最终的凸包上的面 bool ok; &#125;; //初始顶点数 int n; Point3 P[MAXN]; //凸包表面的三角形数 int num; //凸包表面的三角形 face F[8*MAXN]; int g[MAXN][MAXN]; //叉乘 Point3 cross(const Point3 &amp;a,const Point3 &amp;b,const Point3 &amp;c)&#123; return (b-a)^(c-a); &#125; //`三角形面积*2` double area(Point3 a,Point3 b,Point3 c)&#123; return ((b-a)^(c-a)).len(); &#125; //`四面体有向面积*6` double volume(Point3 a,Point3 b,Point3 c,Point3 d)&#123; return ((b-a)^(c-a))*(d-a); &#125; //`正：点在面同向` double dblcmp(Point3 &amp;p,face &amp;f)&#123; Point3 p1 = P[f.b] - P[f.a]; Point3 p2 = P[f.c] - P[f.a]; Point3 p3 = p - P[f.a]; return (p1^p2)*p3; &#125; void deal(int p,int a,int b)&#123; int f = g[a][b]; face add; if(F[f].ok)&#123; if(dblcmp(P[p],F[f]) &gt; eps) dfs(p,f); else &#123; add.a = b; add.b = a; add.c = p; add.ok = true; g[p][b] = g[a][p] = g[b][a] = num; F[num++] = add; &#125; &#125; &#125; //递归搜索所有应该从凸包内删除的面 void dfs(int p,int now)&#123; F[now].ok = false; deal(p,F[now].b,F[now].a); deal(p,F[now].c,F[now].b); deal(p,F[now].a,F[now].c); &#125; bool same(int s,int t)&#123; Point3 &amp;a = P[F[s].a]; Point3 &amp;b = P[F[s].b]; Point3 &amp;c = P[F[s].c]; return fabs(volume(a,b,c,P[F[t].a])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].b])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].c])) &lt; eps; &#125; //构建三维凸包 void create()&#123; num = 0; face add; //*********************************** //此段是为了保证前四个点不共面 bool flag = true; for(int i = 1;i &lt; n;i++)&#123; if(!(P[0] == P[i]))&#123; swap(P[1],P[i]); flag = false; break; &#125; &#125; if(flag)return; flag = true; for(int i = 2;i &lt; n;i++)&#123; if( ((P[1]-P[0])^(P[i]-P[0])).len() &gt; eps )&#123; swap(P[2],P[i]); flag = false; break; &#125; &#125; if(flag)return; flag = true; for(int i = 3;i &lt; n;i++)&#123; if(fabs( ((P[1]-P[0])^(P[2]-P[0]))*(P[i]-P[0]) ) &gt; eps)&#123; swap(P[3],P[i]); flag = false; break; &#125; &#125; if(flag)return; //********************************** for(int i = 0;i &lt; 4;i++)&#123; add.a = (i+1)%4; add.b = (i+2)%4; add.c = (i+3)%4; add.ok = true; if(dblcmp(P[i],add) &gt; 0)swap(add.b,add.c); g[add.a][add.b] = g[add.b][add.c] = g[add.c][add.a] = num; F[num++] = add; &#125; for(int i = 4;i &lt; n;i++) for(int j = 0;j &lt; num;j++) if(F[j].ok &amp;&amp; dblcmp(P[i],F[j]) &gt; eps)&#123; dfs(i,j); break; &#125; int tmp = num; num = 0; for(int i = 0;i &lt; tmp;i++) if(F[i].ok) F[num++] = F[i]; &#125; //表面积 //`测试：HDU3528` double area()&#123; double res = 0; if(n == 3)&#123; Point3 p = cross(P[0],P[1],P[2]); return p.len()/2; &#125; for(int i = 0;i &lt; num;i++) res += area(P[F[i].a],P[F[i].b],P[F[i].c]); return res/2.0; &#125; double volume()&#123; double res = 0; Point3 tmp = Point3(0,0,0); for(int i = 0;i &lt; num;i++) res += volume(tmp,P[F[i].a],P[F[i].b],P[F[i].c]); return fabs(res/6); &#125; //表面三角形个数 int triangle()&#123; return num; &#125; //表面多边形个数 //`测试：HDU3662` int polygon()&#123; int res = 0; for(int i = 0;i &lt; num;i++)&#123; bool flag = true; for(int j = 0;j &lt; i;j++) if(same(i,j))&#123; flag = 0; break; &#125; res += flag; &#125; return res; &#125; //重心 //`测试：HDU4273` Point3 barycenter()&#123; Point3 ans = Point3(0,0,0); Point3 o = Point3(0,0,0); double all = 0; for(int i = 0;i &lt; num;i++)&#123; double vol = volume(o,P[F[i].a],P[F[i].b],P[F[i].c]); ans = ans + (((o+P[F[i].a]+P[F[i].b]+P[F[i].c])/4.0)*vol); all += vol; &#125; ans = ans/all; return ans; &#125; //点到面的距离 //`测试：HDU4273` double ptoface(Point3 p,int i)&#123; double tmp1 = fabs(volume(P[F[i].a],P[F[i].b],P[F[i].c],p)); double tmp2 = ((P[F[i].b]-P[F[i].a])^(P[F[i].c]-P[F[i].a])).len(); return tmp1/tmp2; &#125;&#125;;CH3D hull;int main()&#123; while(scanf("%d",&amp;hull.n) == 1)&#123; for(int i = 0;i &lt; hull.n;i++)hull.P[i].input(); hull.create(); Point3 p = hull.barycenter(); double ans = 1e20; for(int i = 0;i &lt; hull.num;i++) ans = min(ans,hull.ptoface(p,i)); printf("%.3lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的知识星球]]></title>
    <url>%2F2019%2F01%2F06%2F20190106zsxq%2F</url>
    <content type="text"><![CDATA[最近开始玩知识星球了。 在知识星球里面主要分享一些个人心得： 工作学习的心得体会，分享学习资料。 给热爱并愿意坚持ACM，并希望提高编程和算法能力的一些建议。 有兴趣的可以加入，希望有一群人可以共同进步提高~ 最新分享了一篇个人经历介绍：如何在ICPC中从铁到金。 此外我以前创建的ACM交流群好像人满了，应该加不进去了== 后续一段时间计划开始一些在线课程，按照专题的形式讲解常用算法（偏刷题实践，理论较少），目前计划按照新模板的目录进行。确定时间了会在群里和博客更新。 现在在找比较好用的直播讲课平台。第一次将开始将字符串基础算法（KMP、扩展KMP、Trie、AC自动机等）。目标听众是刚刚入门，刷了一定题量，想进一步提高的。对这些基础算法非常熟悉的可以忽略~]]></content>
      <categories>
        <category>其他</category>
        <category>杂言</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC-Nanjing-online-L]]></title>
    <url>%2F2018%2F09%2F01%2F2018-ACM-ICPC-Nanjing-online-L%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2018 南京赛区网络预赛 L题题目链接： https://nanti.jisuanke.com/t/31001 There are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance. InputThe first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases. For each test case, the first line has three integers N, MN,M and KK. Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv. It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN. OutputFor each test case, print the minimum distance. 样例输入复制1234567815 6 11 2 21 3 42 4 33 4 13 5 64 5 2 样例输出复制13 题目来源ACM-ICPC 2018 南京赛区网络预赛 这个没啥好说的。 就是模板题。我的模板稍微修改一下就过了。 其实可以把一个点拆分成k个点，或者Dij转移的时候加一维记录状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const long long INF=10000000000000000LL;const int MAXN=100010;int K;struct qnode&#123; int v; int tt; long long c; qnode(int _v=0, int _tt = 0,int _c=0):v(_v),tt(_tt),c(_c)&#123;&#125; bool operator &lt;(const qnode &amp;r)const&#123; return c&gt;r.c; &#125;&#125;;struct Edge&#123; int v,cost; Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125;&#125;;vector&lt;Edge&gt;E[MAXN];bool vis[MAXN][11];long long dist[MAXN][11];void Dijkstra(int n,int start)&#123; memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=n;i++) &#123; for (int k = 0; k &lt;= K; k++) dist[i][k] = INF; &#125; priority_queue&lt;qnode&gt;que; while(!que.empty())que.pop(); dist[start][0]=0; que.push(qnode(start, 0, 0)); qnode tmp; while(!que.empty())&#123; tmp=que.top(); que.pop(); int u=tmp.v; int k = tmp.tt; if(vis[u][k])continue; vis[u][k]=true; for(int i=0;i&lt;E[u].size();i++)&#123; int v=E[tmp.v][i].v; int cost=E[u][i].cost; if(!vis[v][k]&amp;&amp;dist[v][k]&gt;dist[u][k]+cost)&#123; dist[v][k]=dist[u][k]+cost; que.push(qnode(v,k,dist[v][k])); &#125; if (k &lt; K &amp;&amp; !vis[v][k+1] &amp;&amp; dist[v][k+1] &gt; dist[u][k]) &#123; dist[v][k+1] = dist[u][k]; que.push(qnode(v, k+1, dist[v][k+1])); &#125; &#125; &#125;&#125;void addedge(int u,int v,int w)&#123; E[u].push_back(Edge(v,w));&#125;int main() &#123; int T; int N,M; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;K); for (int i = 1; i &lt;= N; i++)E[i].clear(); int u,v,w; while (M--) &#123; scanf("%d%d%d", &amp;u,&amp;v, &amp;w); addedge(u,v,w); &#125; Dijkstra(N, 1); long long ans = INF; for (int i = 0; i &lt;= K; i++) ans = min(ans, dist[N][i]); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC-Nanjing-online-J]]></title>
    <url>%2F2018%2F09%2F01%2F2018-ACM-ICPC-Nanjing-online-J%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2018 南京赛区网络预赛 J题题目链接：https://nanti.jisuanke.com/t/30999 A square-free integer is an integer which is indivisible by any square number except 11. For example, $6 = 2 \cdot 36=2⋅3$ is square-free, but $12 = 2^2 \cdot 312=22⋅3$ is not, because 2^222 is a square number. Some integers could be decomposed into product of two square-free integers, there may be more than one decomposition ways. For example, 6 = 1\cdot 6=6 \cdot 1=2\cdot 3=3\cdot 2, n=ab6=1⋅6=6⋅1=2⋅3=3⋅2,n=aband n=ban=ba are considered different if a \not = ba̸=b. f(n)f(n) is the number of decomposition ways that n=abn=ab such that aa and bb are square-free integers. The problem is calculating \sum_{i = 1}^nf(i)∑i=1nf(i). InputThe first line contains an integer T(T\le 20)T(T≤20), denoting the number of test cases. For each test case, there first line has a integer n($n \le 2\cdot 10^7$)n(n≤2⋅107). OutputFor each test case, print the answer $\sum_{i = 1}^n f(i)∑i=1nf(i)$. Hint$$\sum_{i = 1}^8 f(i)=f(1)+ \cdots +f(8)∑i=18f(i)=f(1)+⋯+f(8)=1+2+2+1+2+4+2+0=14=1+2+2+1+2+4+2+0=14.$$ 样例输入复制123258 样例输出复制12814 题目来源ACM-ICPC 2018 南京赛区网络预赛 首先我们先研究一下$f(n)$. 如果对$n$进行素因子分解的话，只要有一个素数的指数大于2, 那么$f(n)$ 就是0. 比如$f(2^3) = 0$, $f(2*3^4)=0$. 如果要$f(n)$非0，只能是每个素因子的指数要么是1，要么是2. 而且指数是1的话贡献为2，指数为2的话贡献只有1. （因为指数为1，可以取0个或者1个，指数为2只能取1一个了）。 比如$f(2^1 \times 3^2) = 2 \times 1$. $f(2^1 \times 3^1 \times 5^1) = 2 \times 2 \times 2$. 所有如果单独求一个$f(n)$的话，只需要对$n$进行素因素分解。 但是现在需要求$1 \sim 2 \times 10^7$的$f(n)$, 我们需要进行递推。 假如我们知道$n$的最小素因子是p的话，而且p的指数是x的话，即$n = p^x \times y$. 那么很显然，如果x == 1, 那么$f(n) = 2 \times f(y)$, 如果x == 2, 那么$f(n) = f(y)$, 如果x &gt; 2, 那么$f(n) = 0$. 所以只要我们可以求到一个数的最小素因子，这个问题递推一下就解决了。 幸好我们可以用线性筛。我模板里面有，不懂原理的可以搜一下。 线性时间可以求得每个数最小的素因子，然后搞一搞。 本题有点卡常，减少循环次数，小心谨慎。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 20000010;int prime[MAXN+1];int minPrime[MAXN+1];void getPrime() &#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; minPrime[i] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN/i; j++) &#123; prime[prime[j] * i] = 1; minPrime[prime[j] * i] = prime[j]; if (i % prime[j] == 0)break; &#125; &#125;&#125;long long a[MAXN+1];int main() &#123; getPrime(); a[0] = 0; a[1] = 1; for (int i = 2; i &lt;= MAXN; i++) &#123; int cnt = 0; int tmp = i; int mm = minPrime[i]; if ((long long)mm*mm &lt; MAXN &amp;&amp; (long long)mm*mm*mm &lt; MAXN &amp;&amp; i%(mm*mm*mm) == 0) a[i] = 0; else if ((long long)mm*mm &lt; MAXN &amp;&amp; i%(mm*mm) == 0)a[i] = a[i/mm/mm]; else a[i] = 2*a[i/mm]; &#125; for (int i = 1; i &lt;= MAXN; i++) a[i] += a[i-1]; int n; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); cout&lt;&lt;a[n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC-Nanjing-online-G]]></title>
    <url>%2F2018%2F09%2F01%2F2018-ACM-ICPC-Nanjing-online-G%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2018 南京赛区网络预赛 G题题目链接：https://nanti.jisuanke.com/t/30996 During tea-drinking, princess, amongst other things, asked why has such a good-natured and cute Dragon imprisoned Lpl in the Castle? Dragon smiled enigmatically and answered that it is a big secret. After a pause, Dragon added: — We have a contract. A rental agreement. He always works all day long. He likes silence. Besides that, there are many more advantages of living here in the Castle. Say, it is easy to justify a missed call: a phone ring can’t reach the other side of the Castle from where the phone has been left. So, the imprisonment is just a tale. Actually, he thinks about everything. He is smart. For instance, he started replacing incandescent lamps with energy-saving lamps in the whole Castle… Lpl chose a model of energy-saving lamps and started the replacement as described below. He numbered all rooms in the Castle and counted how many lamps in each room he needs to replace. At the beginning of each month, Lpl buys mmenergy-saving lamps and replaces lamps in rooms according to his list. He starts from the first room in his list. If the lamps in this room are not replaced yet and Lpl has enough energy-saving lamps to replace all lamps, then he replaces all ones and takes the room out from the list. Otherwise, he’ll just skip it and check the next room in his list. This process repeats until he has no energy-saving lamps or he has checked all rooms in his list. If he still has some energy-saving lamps after he has checked all rooms in his list, he’ll save the rest of energy-saving lamps for the next month. As soon as all the work is done, he ceases buying new lamps. They are very high quality and have a very long-life cycle. Your task is for a given number of month and descriptions of rooms to compute in how many rooms the old lamps will be replaced with energy-saving ones and how many energy-saving lamps will remain by the end of each month. InputEach input will consist of a single test case. The first line contains integers nn and m (1 \le n \le 100000, 1 \le m \le 100)m(1≤n≤100000,1≤m≤100) — the number of rooms in the Castle and the number of energy-saving lamps, which Lpl buys monthly. The second line contains nn integers k_1, k_2, …, k_nk1,k2,…,kn(1 \le k_j \le 10000, j = 1, 2, …, n)(1≤kj≤10000,j=1,2,…,n) — the number of lamps in the rooms of the Castle. The number in position jj is the number of lamps in jj-th room. Room numbers are given in accordance with Lpl’s list. The third line contains one integer q (1 \le q \le 100000)q(1≤q≤100000) — the number of queries. The fourth line contains qq integers d_1, d_2, …, d_qd1,d2,…,dq(1 \le d_p \le 100000, p = 1, 2, …, q)(1≤dp≤100000,p=1,2,…,q) — numbers of months, in which queries are formed. Months are numbered starting with 11; at the beginning of the first month Lpl buys the first m energy-saving lamps. OutputPrint qq lines. Line pp contains two integers — the number of rooms, in which all old lamps are replaced already, and the number of remaining energy-saving lamps by the end of d_pdp month. HintExplanation for the sample: In the first month, he bought 44 energy-saving lamps and he replaced the first room in his list and remove it. And then he had 11 energy-saving lamps and skipped all rooms next. So, the answer for the first month is 1,1——11,1−−−−−−1 room’s lamps were replaced already, 11 energy-saving lamp remain. 样例输入复制12345 43 10 5 2 7105 1 4 8 7 2 3 6 4 7 样例输出复制123456789104 01 13 65 15 12 03 24 43 65 1 题目来源ACM-ICPC 2018 南京赛区网络预赛 首先认真读题。 其实发现模拟一下就是每次从左往右找到一个不大于某个值的数，然后干掉。 这个题目范围还比较水。就是暴力枚举每个月，然后每个月找满足条件的数的时候用线段树维护一下。 线段树水题！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100010;struct Node &#123; int l,r; int mi;&#125;segTree[MAXN*4];int a[MAXN];void push_up(int i) &#123; if (segTree[i].l == segTree[i].r) return; if (a[segTree[i&lt;&lt;1].mi] &gt; a[segTree[(i&lt;&lt;1)|1].mi]) segTree[i].mi = segTree[(i&lt;&lt;1)|1].mi; else segTree[i].mi = segTree[i&lt;&lt;1].mi;&#125;int Index[MAXN];void build(int i, int l, int r) &#123; segTree[i].l = l; segTree[i].r = r; if (l == r) &#123; segTree[i].mi = l; Index[l] = i; return; &#125; int mid = (l + r)/2; build(i&lt;&lt;1, l, mid); build((i&lt;&lt;1)|1, mid+1, r); push_up(i);&#125;int query(int i, int l, int r, int val) &#123; if (l &gt; r) return -1; if (a[segTree[i].mi] &gt; val) return -1; if (l == segTree[i].l &amp;&amp; r == segTree[i].l) &#123; if (a[segTree[i].mi] &lt;= val) return segTree[i].mi; else return -1; &#125; int mid = (segTree[i].l + segTree[i].r)/2; int li = -1; int ri = -1; if (l &lt;= mid) &#123; li = query(i&lt;&lt;1, l, mid, val); &#125; if (li != -1) return li; if (r &gt; mid) &#123; ri = query((i&lt;&lt;1)|1, mid+1, r, val); &#125; if (ri != -1) return ri; return -1;&#125;const int INF = 0x3f3f3f3f;void update(int i) &#123; a[i] = INF; int tmp = Index[i]; while (tmp) &#123; push_up(tmp); tmp /= 2; &#125;&#125;int ans1[100010], ans2[100010];int main() &#123; int n,m; while(scanf("%d%d", &amp;n, &amp;m) == 2) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); build(1, 1, n); int num1 = 0; int val = 0; for (int k = 1; k &lt;= 100000; k++) &#123; val += m; int now = 1; while (1) &#123; int mi = query(1, now, n, val); if (mi == -1)break; val -= a[mi]; num1++; update(mi); now = mi+1; &#125; ans1[k] = num1; ans2[k] = val; &#125; int Q; scanf("%d", &amp;Q); int d; while (Q--) &#123; scanf("%d", &amp;d); printf("%d %d\n", ans1[d], ans2[d]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC-Nanjing-online-E]]></title>
    <url>%2F2018%2F09%2F01%2F2018-ACM-ICPC-Nanjing-online-E%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2018 南京赛区网络预赛 E题题目链接： https://nanti.jisuanke.com/t/30994 Dlsj is competing in a contest with n (0 &lt; n \le 20)n(0&lt;n≤20) problems. And he knows the answer of all of these problems. However, he can submit ii-th problem if and only if he has submitted (and passed, of course) s_isi problems, the p_{i, 1}pi,1-th, p_{i, 2}pi,2-th, ……, p_{i, s_i}pi,si-th problem before.(0 &lt; p_{i, j} \le n,0 &lt; j \le s_i,0 &lt; i \le n)(0&lt;pi,j≤n,0&lt;j≤si,0&lt;i≤n)After the submit of a problem, he has to wait for one minute, or cooling down time to submit another problem. As soon as the cooling down phase ended, he will submit his solution (and get “Accepted” of course) for the next problem he selected to solve or he will say that the contest is too easy and leave the arena. “I wonder if I can leave the contest arena when the problems are too easy for me.”“No problem.”—— CCF NOI Problem set If he submits and passes the ii-th problem on tt-th minute(or the tt-th problem he solve is problem ii), he can get t \times a_i + b_it×ai+bi points. (|a_i|, |b_i| \le 10^9)(∣ai∣,∣bi∣≤109). Your task is to calculate the maximum number of points he can get in the contest. InputThe first line of input contains an integer, nn, which is the number of problems. Then follows nn lines, the ii-th line contains s_i + 3si+3 integers, a_i,b_i,s_i,p_1,p_2,…,p_{s_i}ai,bi,si,p1,p2,…,psias described in the description above. OutputOutput one line with one integer, the maximum number of points he can get in the contest. HintIn the first sample. On the first minute, Dlsj submitted the first problem, and get 1 \times 5 + 6 = 111×5+6=11 points. On the second minute, Dlsj submitted the second problem, and get 2 \times 4 + 5 = 132×4+5=13points. On the third minute, Dlsj submitted the third problem, and get 3 \times 3 + 4 = 133×3+4=13 points. On the forth minute, Dlsj submitted the forth problem, and get 4 \times 2 + 3 = 114×2+3=11 points. On the fifth minute, Dlsj submitted the fifth problem, and get 5 \times 1 + 2 = 75×1+2=7 points. So he can get 11+13+13+11+7=5511+13+13+11+7=55points in total. In the second sample, you should note that he doesn’t have to solve all the problems. 样例输入1复制12345655 6 04 5 1 13 4 1 22 3 1 31 2 1 4 样例输出1复制155 样例输入2复制121-100 0 0 样例输出2复制10 题目来源ACM-ICPC 2018 南京赛区网络预赛 看到了n&lt;20, 很显然就是要状态压缩了。 然后那个前提条件，其实就是状态转移时候的条件了，只要判断一下就可以了。 状态压缩就是用一个二进制数来表示当前的状态，这个数需要有n个二进制位，如果为0表示没有submit这个题，1表示submit了。 dp[i]表示到状态i获得的最多points. 根据i有多少1就知道现在的时间了（每分钟submit一个）。 具体看代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int bit[22];int a[22];int b[22];int state[22];long long dp[1&lt;&lt;20];int numbit[1&lt;&lt;20];const long long INF = 1000000000000000LL;int main() &#123; bit[0] = 1; for (int i = 1; i &lt; 22; i++) bit[i] = bit[i-1]&lt;&lt;1; numbit[0] = 0; for (int i = 1; i &lt; bit[20]; i++) &#123; numbit[i] = 1 + numbit[i&amp;(i-1)]; &#125; int n; while(scanf("%d", &amp;n) == 1) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;a[i], &amp;b[i]); int s; scanf("%d", &amp;s); int tmp = 0; state[i] = 0; while (s--) &#123; scanf("%d", &amp;tmp); state[i] |= bit[tmp-1]; &#125; &#125; dp[0] = 0; for (int i = 1; i &lt; bit[n]; i++)dp[i] = -INF; long long ans = 0; for (int i = 0; i &lt; bit[n]; i++) &#123; if (dp[i] == -INF)continue; ans = max(ans, dp[i]); for (int j = 0; j &lt; n; j++) &#123; if (i &amp; bit[j])continue; if ((i&amp;state[j]) != state[j])continue; dp[i|bit[j]] = max(dp[i|bit[j]], dp[i] + (long long)(numbit[i]+1)*a[j] + b[j]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM新模板]]></title>
    <url>%2F2018%2F08%2F01%2FACM-template%2F</url>
    <content type="text"><![CDATA[新模板下载地址：here 有任何问题或者反馈，发送到kuangbin2009@126.com. 谢谢！ ACM交流群：181826055]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_my_site]]></title>
    <url>%2F2018%2F07%2F28%2Ftest-my-site%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[I'm back！]]></title>
    <url>%2F2016%2F08%2F13%2F20160724%2F</url>
    <content type="text"><![CDATA[I’m back! Come on~原来的kuangbin.net到期之后，网站就挂了两个多月了，一直没空重新搞。 现在重新注册了一个新域名：kuangbin.org 继续努力。 最近半年经历了毕业，开始工作了。硕士毕业和本科毕业时候的心态也是不一样的，只是感觉又会离开一大批人，好多人或许以后都没机会再见了，好多人也联系越来越少，想起来也是挺伤感的一件事情。 但是每个人都要去承担不同阶段该扮演的角色，适应不同的挑战。 我仍然会不断地学习，提高自己，最近想学习的东西太多了，工作以后自己学习的时候也比较少了， however, keep going! 继续学习算法，刷题ing! 继续参加各种比赛！ 仍然希望以前认识的人，能不断保持联系。 或者你们有什么问题，也非常高兴一起交流共同进步，愿你们都能成功，不管在哪方面都有所成就。 也决定把博客抬头上的那句话撤下了，那个是刚开始接触acm时候用来激励自己的话，亦希望跟其他acmer共勉。 不过目前没有想好放什么上去，先TBD（to be decided）吧。 If you want to contract with me, you can see the “about me”. Updates: kuangbin.org也到期了，现在在用kuangbin.github.io]]></content>
      <categories>
        <category>其他</category>
        <category>杂言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FOJ有奖月赛-2015年10月 题解]]></title>
    <url>%2F2015%2F10%2F06%2Ffoj-2015-10%2F</url>
    <content type="text"><![CDATA[FOJ有奖月赛-2015年10月 比赛链接： here 注意此乃非官方题解，只是个人解法，如有不对，敬请指出。 A题： 题目链接：http://acm.fzu.edu.cn/problem.php?pid=2198 很水，一看就是写递推式，然后矩阵递推。 递推式为 t[n] = 6*t[n-1] - t[n-2]. 然后对t[n]从1~n求和。 所以需要3*3的矩阵。 然后快速敲完，非常遗憾，TLE了。。。。 怎么办？？？？？ 暴力打一些表，然后飘过~~~ 为何要卡矩阵乘法！！！！！！ 代码君： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/* ***************Author :kuangbinCreated Time :2015/10/6 13:04:18File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\A.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;struct Matrix &#123; int mat[3][3]; void init() &#123; memset(mat,0,sizeof(mat)); &#125; Matrix operator *(const Matrix &amp;b)const &#123; Matrix ret; for(int i = 0;i &lt; 3;i++) for(int j = 0;j &lt; 3;j++) &#123; ret.mat[i][j] = 0; for(int k = 0;k &lt; 3;k++) &#123; ret.mat[i][j] += (long long)mat[i][k]*b.mat[k][j]%MOD; if(ret.mat[i][j] &gt;= MOD) ret.mat[i][j] -= MOD; &#125; &#125; return ret; &#125;&#125;;Matrix mm[70];Matrix pow_M(Matrix a,long long n) &#123; Matrix ret; ret.init(); ret.mat[0][0] = ret.mat[1][1] = ret.mat[2][2] = 1; int cnt = 0; while(n) &#123; if(n&amp;1)ret = ret*mm[cnt]; cnt++; n &gt;&gt;= 1; &#125; return ret; /* Matrix tmp = a; while(n) &#123; if(n&amp;1)ret = ret*tmp; tmp = tmp*tmp; n &gt;&gt;= 1; &#125; */ return ret;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; long long n; scanf("%d",&amp;T); Matrix b; b.init(); b.mat[0][0] = 0; b.mat[1][0] = 1; b.mat[0][1] = MOD-1; b.mat[1][1] = 6; b.mat[2][2] = 1; b.mat[0][2] = 0; b.mat[1][2] = 1; mm[0] = b; for(int i = 1;i &lt;= 60;i++) mm[i] = mm[i-1]*mm[i-1]; while(T--) &#123; Matrix a; scanf("%I64d",&amp;n); a = pow_M(b,n); printf("%d\n",(int) ((a.mat[0][2] + 6LL*a.mat[1][2])%MOD)); &#125; return 0;&#125; B题： 题目链接：http://acm.fzu.edu.cn/problem.php?pid=2199 本场比赛的压轴题，比赛期间无人AC，因为中间题目不清，改题意了，我是赛后改了下才AC的。 题目要求一口气吃完所以萝卜。 就是你从起点开始，可以先不吃萝卜，一旦碰到萝卜，就要一直吃完，然后走到洞口走人。 所以你首先枚举第一个吃到的是哪个萝卜！ 从起点进行一遍bfs, 就是知道从起点可以到哪个萝卜了，距离和种数都知道了。 假如吃萝卜的起点和终点都确定了，就是单路径问题。 非常裸的插头DP就可以解决。 插头DP参考：here 我是按照ZOJ3213代码进行修改的，而且简化了，因为起点和终点都确定了。 走的距离其实可以不用记录的，我一开始理解错 了，加了记录，后面发现没有必要。 代码君： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659/* ***************Author :kuangbinCreated Time :2015/10/6 14:26:33File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\B.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXD=18;const int HASH=10007;const int STATE=2000010;const int MOD = 1e9+7;void Add(int &amp;a,int b) &#123; a += b; if(a &gt;= MOD)a -= MOD;&#125;int N,M;char maze[MAXD][MAXD];int code[MAXD];int ch[MAXD];struct HASHMAP&#123; int head[HASH],next[STATE],size; int state[STATE],dp[STATE]; int num[STATE]; void init() &#123; size=0; memset(head,-1,sizeof(head)); &#125; void push(int st,int ans, int nn) &#123; int i,h=st%HASH; for(i=head[h];i!=-1;i=next[i]) if(state[i]==st) &#123; if(num[i] &gt; nn) &#123; num[i] = nn; dp[i] = ans; &#125; else if(num[i] == nn) &#123; Add(dp[i],ans); &#125; return; &#125; state[size]=st; dp[size]=ans; num[size] = nn; next[size]=head[h]; head[h]=size++; &#125;&#125;hm[2];void decode(int *code,int m,int st)&#123; for(int i=m;i&gt;=0;i--) &#123; code[i]=st&amp;7; st&gt;&gt;=3; &#125;&#125;int encode(int *code,int m)&#123; int cnt=1; memset(ch,-1,sizeof(ch)); ch[0]=0; int st=0; for(int i=0;i&lt;=m;i++) &#123; if(ch[code[i]]==-1)ch[code[i]]=cnt++; code[i]=ch[code[i]]; st&lt;&lt;=3; st|=code[i]; &#125; return st;&#125;void shift(int *code,int m)&#123; for(int i=m;i&gt;0;i--)code[i]=code[i-1]; code[0]=0;&#125;//没有萝卜的void dpblank(int i,int j,int cur)&#123; int k,left,up; for(k=0;k&lt;hm[cur].size;k++) &#123; decode(code,M,hm[cur].state[k]); left=code[j-1]; up=code[j]; if(left&amp;&amp;up) &#123; &#125; else if(left||up) &#123; &#125; else &#123; code[j-1]=code[j]=0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].dp[k], hm[cur].num[k]); &#125; &#125;&#125;//有萝卜的void dpluobo(int i,int j,int cur)&#123; int k,left,up; for(k=0;k&lt;hm[cur].size;k++) &#123; decode(code,M,hm[cur].state[k]); left=code[j-1]; up=code[j]; if(left&amp;&amp;up) &#123; if(left!=up) &#123; code[j-1]=code[j]=0; for(int t=0;t&lt;=M;t++) if(code[t]==up) code[t]=left; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; &#125; else if(left||up) &#123; int t; if(left)t=left; else t=up; if(maze[i][j+1]) &#123; code[j-1]=0; code[j]=t; hm[cur^1].push(encode(code,M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; if(maze[i+1][j]) &#123; code[j-1]=t; code[j]=0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; &#125; else &#123; if(maze[i][j+1]&amp;&amp;maze[i+1][j]) &#123; code[j-1]=code[j]=15; hm[cur^1].push(encode(code,M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; &#125; &#125;&#125;//起点和终点void dpstart(int i,int j,int cur)&#123; int k,left,up; for(k=0;k&lt;hm[cur].size;k++) &#123; decode(code,M,hm[cur].state[k]); left=code[j-1]; up=code[j]; if(left&amp;&amp;up) &#123; &#125; else if(left||up) &#123; code[j-1]=code[j]=0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; else &#123; if(maze[i][j+1]) &#123; code[j]=15; code[j-1]=0; hm[cur^1].push(encode(code,M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; if(maze[i+1][j]) &#123; code[j-1]=15; code[j]=0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].dp[k], hm[cur].num[k]+1); &#125; &#125; &#125;&#125;int dp1[20][20];int dp2[20][20];int sx,sy;int ex,ey;int Move[][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;void bfs() &#123; for(int i = 1;i &lt;= N;i++) for(int j = 1;j &lt;= M;j++) &#123; if(maze[i][j] == 'X') &#123; sx = i; sy = j; &#125; if(maze[i][j] == 'O') &#123; ex = i; ey = j; &#125; &#125; memset(dp1,-1,sizeof(dp1)); memset(dp2,0,sizeof(dp2)); queue&lt;pair&lt;int,int&gt; &gt;q; q.push(make_pair(sx,sy)); dp1[sx][sy] = 0; dp2[sx][sy] = 1; while(!q.empty()) &#123; pair&lt;int,int&gt;tmp = q.front(); q.pop(); int x = tmp.first; int y = tmp.second; if(maze[x][y] == '#' || maze[x][y] == 'O')continue; for(int i = 0;i &lt; 4;i++) &#123; int nx = x+Move[i][0]; int ny = y+Move[i][1]; if(nx &lt; 1 || nx &gt; N)continue; if(ny &lt; 1 || ny &gt; M)continue; if(dp1[nx][ny] == -1) &#123; dp1[nx][ny] = dp1[x][y]+1; dp2[nx][ny] = dp2[x][y]; q.push(make_pair(nx,ny)); &#125; else if (dp1[nx][ny] == dp1[x][y]+1) Add(dp2[nx][ny],dp2[x][y]); &#125; &#125;&#125;void init()&#123; scanf("%d%d",&amp;N,&amp;M); memset(maze,0,sizeof(maze)); for(int i=1;i&lt;=N;i++) &#123; scanf("%s",maze[i]+1); &#125; bfs();&#125;pair&lt;int,int&gt; solve()&#123; int i,j,cur=0; hm[cur].init(); hm[cur].push(0,1,0); for(i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++) &#123; hm[cur^1].init(); if(maze[i][j] == '.')dpblank(i,j,cur); else if(maze[i][j] == '#')dpluobo(i,j,cur); else dpstart(i,j,cur); cur^=1; &#125; int ans = 10000000; int ans2 = 0; for(i=0;i&lt;hm[cur].size;i++) &#123; int num = hm[cur].num[i]; if(num &lt; ans) &#123; ans = num; ans2 = hm[cur].dp[i]; &#125; else if(num == ans) &#123; ans2 += hm[cur].dp[i]; if(ans2 &gt;= MOD)ans2 -= MOD; &#125; &#125; if(ans &gt; 10000)return make_pair(-1,-1); else return make_pair(ans-1,ans2);&#125;void gao() &#123; int cnt = 0; for(int i = 1;i &lt;= N;i++) for(int j = 1;j &lt;= M;j++) if(maze[i][j] == '#')cnt++; if(cnt == 0) &#123; if(dp1[ex][ey] == -1)printf("-1\n"); else printf("%d %d\n",dp1[ex][ey],dp2[ex][ey]); return; &#125; pair&lt;int,int&gt;ans = make_pair(-1,-1); pair&lt;int,int&gt;tmp = solve(); if(tmp.first != -1) &#123; if(ans.first == -1 || ans.first &gt; tmp.first) &#123; ans = tmp; &#125; else if(ans.first == tmp.first) Add(ans.second,tmp.second); &#125; if(ans.first != -1) &#123; if(ans.first == -1)printf("-1\n"); else printf("%d %d\n",ans.first,ans.second); return; &#125; maze[sx][sy] = '.'; for(int i = 1;i &lt;= N;i++) for(int j = 1;j &lt;= M;j++) if(maze[i][j] == '#' &amp;&amp; dp1[i][j] != -1) &#123; maze[i][j] = 'X'; pair&lt;int,int&gt;tmp = solve(); if(tmp.first == -1) &#123; maze[i][j] = '#'; continue; &#125; if(ans.first == -1 || ans.first &gt; tmp.first + dp1[i][j]) &#123; ans = make_pair(tmp.first+dp1[i][j],((long long)dp2[i][j]*tmp.second)%MOD); &#125; else if(ans.first == tmp.first + dp1[i][j]) Add(ans.second, (long long)dp2[i][j]*tmp.second%MOD); maze[i][j] = '#'; &#125; if(ans.first == -1)printf("-1\n"); else printf("%d %d\n",ans.first,ans.second);&#125;int main()&#123; int T; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; init(); printf("Case #%d: ",iCase); gao(); &#125; return 0;&#125; C题： 题目链接：http://acm.fzu.edu.cn/problem.php?pid=2200 题目讲得很清楚了，但是因为是个环！ 如果是线性的，比较好办，直接DP。 环的换，就枚举前两个点，这样就分割成了一个线性的，然后进行DP。 DP的时候，我记录了最前面的状态，以及结束的状态 。转移非常裸。 这题思路和G类似了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/* ***************Author :kuangbinCreated Time :2015/10/6 13:55:42File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\C.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;int dp[2][2][1010][1010][2][2];void Add(int &amp;a,int b) &#123; a += b; if(a &gt;= MOD)a -= MOD;&#125;int a[10];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); int n,k; memset(dp,0,sizeof(dp)); for(int i = 0;i &lt; 2;i++) for(int j = 0;j &lt; 2;j++) &#123; dp[i][j][0][0][i][j] = 1; &#125; for(int t1 = 0;t1 &lt; 2;t1++) for(int t2 = 0;t2 &lt; 2;t2++) &#123; for(int i = 0;i &lt;= 1000;i++) for(int j = 0;j &lt;= i;j++) for(int x = 0;x &lt; 2;x++) for(int y = 0;y &lt; 2;y++) &#123; if(!dp[t1][t2][i][j][x][y])continue; Add(dp[t1][t2][i+1][j][y][0],dp[t1][t2][i][j][x][y]); if(x == 0) Add(dp[t1][t2][i+1][j+1][y][1],dp[t1][t2][i][j][x][y]); &#125; &#125; while(T--) &#123; scanf("%d%d",&amp;n,&amp;k); if(n &lt;= 5) &#123; int ans = 0; for(int i = 0;i &lt; (1&lt;&lt;n);i++) &#123; int cnt = 0; for(int j = 0;j &lt; n;j++) &#123; if(i &amp; (1&lt;&lt;j))&#123;a[j] = 1;cnt++;&#125; else a[j] = 0; &#125; if(cnt != k)continue; bool flag = true; for(int j = 0;j &lt; n;j++) if(a[j] &amp;&amp; a[(j+2)%n])flag = false; if(flag)ans++; &#125; printf("%d\n",ans); continue; &#125; int ans = 0; for(int i = 0;i &lt; 2;i++) for(int j = 0;j &lt; 2;j++) &#123; int tt = (i==1)+(j==1); if(k &lt; tt)continue; for(int x = 0;x &lt; 2;x++) for(int y = 0;y &lt; 2;y++) &#123; if(x &amp;&amp; i)continue; if(y &amp;&amp; j)continue; Add(ans,dp[i][j][n-2][k-tt][x][y]); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; D题： 题目链接：http://acm.fzu.edu.cn/problem.php?pid=2201 非常显然要用数据结构！ 怎么维护呢？ 关键就是第一个操作了。 如何求 gcd(c-a,c-b) ? 可以发现是 gcd(c-a,c-b) = gcd(c-a,a-b). 如果有很多数呢？ 如何求 gcd(c-a[1], c-a[2], …. c-a[n]) ? 可以发现是这样的 gcd(c-a[1], a[1]-a[2], …. a[n-1]-a[n]) 发现就是差分和其中一个数了。 所以用线段树搞，记录第一个和最后一个就可以维护差分了， 然后GCD就出来了。 本题我int就不过了，没有上long long….. 数据范围比较小吧。 英神教我的，英神果然牛逼！。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239/* ***************Author :kuangbinCreated Time :2015/10/6 19:00:42File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;long long gcd(long long a,long long b)&#123; if(b == 0)return a; return gcd(b,a%b);&#125;struct Node &#123; int l,r; int a,b; int first,last; int g; int val;&#125;segTree[MAXN&lt;&lt;2];void push_up(int i) &#123; segTree[i].first = segTree[i&lt;&lt;1].first; segTree[i].last = segTree[(i&lt;&lt;1)|1].last; segTree[i].val = gcd(segTree[i&lt;&lt;1].val,segTree[(i&lt;&lt;1)|1].val); segTree[i].val = gcd(segTree[i].val,abs(segTree[i&lt;&lt;1].last-segTree[(i&lt;&lt;1)|1].first)); segTree[i].g = gcd(segTree[i].val,segTree[i].first);&#125;void Update_node(int i,int a,int b) &#123; segTree[i].first = a*segTree[i].first+b; segTree[i].last = a*segTree[i].last+b; segTree[i].g = gcd(segTree[i].first,segTree[i].val); segTree[i].a *= a; segTree[i].b = a*segTree[i].b+b;&#125;void push_down(int i) &#123; if(segTree[i].l == segTree[i].r)return; int a = segTree[i].a; int b = segTree[i].b; if(a != 1 || b != 0) &#123; Update_node(i&lt;&lt;1,a,b); Update_node((i&lt;&lt;1)|1,a,b); a = 1; b = 0; &#125;&#125;int a[MAXN];void build(int i,int l,int r) &#123; segTree[i].l = l; segTree[i].r = r; segTree[i].a = 1; segTree[i].b = 0; if(l == r) &#123; segTree[i].first = a[l]; segTree[i].last = a[l]; segTree[i].val = 0; segTree[i].g = a[l]; return; &#125; int mid = (l+r)/2; build(i&lt;&lt;1,l,mid); build((i&lt;&lt;1)|1,mid+1,r); push_up(i);&#125;void update(int i,int l,int r,int a,int b) &#123; if(segTree[i].l == l &amp;&amp; segTree[i].r == r) &#123; Update_node(i,a,b); return; &#125; push_down(i); int mid = (segTree[i].l+segTree[i].r)/2; if(r &lt;= mid)update(i&lt;&lt;1,l,r,a,b); else if(l &gt; mid)update((i&lt;&lt;1)|1,l,r,a,b); else &#123; update(i&lt;&lt;1,l,mid,a,b); update((i&lt;&lt;1)|1,mid+1,r,a,b); &#125; push_up(i);&#125;int query(int i,int l,int r) &#123; if(segTree[i].l == l &amp;&amp; segTree[i].r == r) return segTree[i].g; push_down(i); int mid = (segTree[i].l+segTree[i].r)/2; if(r &lt;= mid)return query(i&lt;&lt;1,l,r); else if (l &gt; mid)return query((i&lt;&lt;1)|1,l,r); else return gcd(query(i&lt;&lt;1,l,mid),query((i&lt;&lt;1)|1,mid+1,r));&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m; while(scanf("%d%d",&amp;n,&amp;m) == 2) &#123; for(int i = 1;i &lt;= n;i++)scanf("%d",&amp;a[i]); build(1,1,n); int op; int l,r,x; while(m--) &#123; scanf("%d",&amp;op); if(op == 1) &#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;x); update(1,l,r,-1,x); &#125; else &#123; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",query(1,l,r)); &#125; &#125; &#125; return 0;&#125; E题： 题目链接：http://acm.fzu.edu.cn/problem.php?pid=2202 题目也很清楚，最后要输出每个人是不是可以确定说真话还是假话。 首先枚举，加上第 i 个人犯罪了，那么你要判断是不是说真话的有m个。 判断的时候肯定要 O(1) 啦， 其实如果i是犯罪的，说别人犯罪的都是说假话的，说别人不犯罪的也是假话的，直接就求出了有多少人说真话。 然后输出时候特判就可以了。 具体不分析了，自己看看代码。 代码君： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* ***************Author :kuangbinCreated Time :2015/10/6 13:28:08File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;int a[MAXN];int n,m;int numa[MAXN],numb[MAXN];bool can[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); memset(numa,0,sizeof(numa)); int sa = 0; int sb = 0; memset(numb,0,sizeof(numb)); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;a[i]); if(a[i] &gt; 0) &#123; numa[a[i]]++; sa++; &#125; else &#123; numb[-a[i]]++; sb++; &#125; &#125; memset(can,false,sizeof(can)); int ret = 0; for(int i = 1;i &lt;= n;i++) &#123; if (numa[i] + sb - numb[i] == m) &#123; ret++; can[i] = true; &#125; &#125; for(int i = 1;i &lt;= n;i++) &#123; if(a[i] &gt; 0) &#123; if(can[a[i]]) &#123; if(ret == 1)puts("Truth"); else puts("Not defined"); &#125; else puts("Lie"); &#125; else &#123; if(can[-a[i]]) &#123; if(ret == 1)puts("Lie"); else puts("Not defined"); &#125; else puts("Truth"); &#125; &#125; &#125; return 0;&#125; F题： 题目链接：[http://acm.fzu.edu.cn/problem.php?pid=2203](http://acm.fzu.edu.cn/problem.php?pid=2203) 很水。全场最水。 二分，然后判断就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* ***************Author :kuangbinCreated Time :2015/10/6 20:04:50File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 200010;int N,K,A;bool used[MAXN];int a[MAXN];bool check(int n) &#123; memset(used,false,sizeof(used)); for(int i = 0;i &lt; n;i++)used[a[i]] = true; int cnt = 0; int num = 0; for(int i = 1;i &lt;= N;i++) &#123; if(used[i]) &#123; num += (cnt+1)/(A+1); cnt = 0; &#125; else cnt++; &#125; num += (cnt+1)/(A+1); return num &gt;= K;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d%d%d",&amp;N,&amp;K,&amp;A) == 3) &#123; int m; scanf("%d",&amp;m); for(int i = 0;i &lt; m;i++) &#123; scanf("%d",&amp;a[i]); &#125; int ans = 0; int l = 0, r = m; while(l &lt;= r) &#123; int mid = (l+r)/2; if(check(mid)) &#123; ans = mid; l = mid+1; &#125; else r = mid-1; &#125; if(ans == m)printf("-1\n"); else printf("%d\n",ans+1); &#125; return 0;&#125; G题： 题目链接：http://acm.fzu.edu.cn/problem.php?pid=2204 要对n个点的环进行黑白染色，没有&gt;=7个连续的都是黑或者白。 一样的思路，环转化为线性。 假设第一个是黑色的。 （如果第一个是白色的，情况是对称的，结果乘于2就OK了） 所以可以算第一个是黑色的。 你首先要枚举前x个是黑色的，第x+1个是白色的，枚举肯定 x &lt;7了。 这样你对剩下部分进行DP转移，注意这个时候DP的时候，你要默认第一个一定涂白色。（这里的第一个其实是第x+1个）。 然后转移 n-x 个，看最后的状态合并起来不会冲突，不冲突就累加了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/* ***************Author :kuangbinCreated Time :2015/10/6 13:23:07File Name :F:\ACM\2015ACM\比赛练习\2015-10-6\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 2015;int dp[100010][7][2];void Add(int &amp;a,int b) &#123; a += b; if(a &gt;= MOD)a -= MOD;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); memset(dp,0,sizeof(dp)); dp[0][0][0] = 1; for(int i = 0;i &lt;= 100000;i++) for(int j = 0;j &lt;= i &amp;&amp; j &lt; 7;j++) for(int c = 0;c &lt; 2;c++) &#123; if(dp[i][j][c] == 0)continue; if(c == 0 &amp;&amp; j+1 &lt; 7) Add(dp[i+1][j+1][0],dp[i][j][c]); if(c == 1) Add(dp[i+1][1][0],dp[i][j][c]); if(i == 0)continue; if(c == 1 &amp;&amp; j+1 &lt; 7) Add(dp[i+1][j+1][1],dp[i][j][c]); if(c == 0) Add(dp[i+1][1][1],dp[i][j][c]); &#125; int T; int n; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; scanf("%d",&amp;n); printf("Case #%d: ",iCase); if(n &lt;= 6) &#123; printf("%d\n",(1&lt;&lt;n)%MOD); continue; &#125; int ans = 0; for(int i = 1;i &lt;= 6;i++) &#123; for(int j = 0;j &lt; 7 &amp;&amp; j &lt;= n-i;j++) for(int c = 0;c &lt; 2;c++) &#123; if(dp[n-i][j][c] == 0)continue; if(i + (c==1)*j &gt;= 7)continue; Add(ans,dp[n-i][j][c]); &#125; &#125; Add(ans,ans); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>算法</category>
        <category>DP</category>
        <category>水题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>暴力</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5486 Difference of Clustering]]></title>
    <url>%2F2015%2F10%2F01%2Fhdu5486%2F</url>
    <content type="text"><![CDATA[记录下网络赛写的代码～ 题目链接： hdu5486 Difference of ClusteringTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 321 Accepted Submission(s): 113 Problem Description Given two clustering algorithms, the old and the new, you want to find the difference between their results. A clustering algorithm takes many memberentities as input and partition them into clusters. In this problem, a member entity must be clustered into exactly one cluster. However, we don’t have any pre-knowledge of the clusters, so different algorithms may produce different number of clusters as well as different cluster IDs. One thing we are sure about is that the memberIDs are stable, which means that the same member ID across different algorithms indicates the same member entity. To compare two clustering algorithms, we care about three kinds of relationship between the old clusters and the new clusters: split, merge and 1:1. Please refer to the figure below. Let’s explain them with examples. Say in the old result, m0, m1, m2 are clustered into one cluster c0, but in the new result, m0 and m1 are clustered into c0, but m2 alone is clustered into c1. We denote the relationship like the following: ● In the old, c0 = [m0, m1, m2] ● In the new, c0 = [m0, m1], c1 = [m2] There is no other members in the new c0 and c1. Then we say the old c0 is split into new c0 and new c1. A few more examples: ● In the old, c0 = [m0, m1, m2] ● In the new, c0 = [m0, m1, m2]. This is 1:1. ● In the old, c0 = [m0, m1], c1 = [m2] ● In the new, c0 = [m0, m1, m2] This is merge. Please note, besides these relationship, there is another kind called “n:n”: ● In the old, c0 = [m0, m1], c1 = [m2, m3] ● In the new, c0 = [m0, m1, m2], c1 = [m3] We don’t care about n:n. In this problem, we will give you two sets of clustering results, each describing the old and the new. We want to know the total number of splits, merges, and 1:1 respectively. Input The first line of input contains a number T indicating the number of test cases (T≤100). Each test case starts with a line containing an integer N indicating the number of member entities (0≤N≤106 ). In the following N lines, the i-th line contains two integers c1 and c2, which means that the member entity with ID i is partitioned into cluster c1 and cluster c2 by the old algorithm and the new algorithm respectively. The cluster IDs c1 and c2 can always fit into a 32-bit signed integer. Output For each test case, output a single line consisting of “Case #X: A B C”. X is the test case number starting from 1. A, B, and C are the numbers of splits, merges, and 1:1s. Sample Input 2 3 0 0 0 0 0 1 4 0 0 0 0 1 1 1 1 Sample Output Case #1: 1 0 0 Case #2: 0 0 2 Source 2015 ACM/ICPC Asia Regional Hefei Online 这题题意有点难懂，但是其实不难。 要找出一对多，多对一，以及一对一的有多少。 可以看成两个图。 从一的那一侧把所有点找出来，然后在另外一侧对每个点关联的点，只要总度数一样就可以的。 我写暴力了，vector 导致了MLE。 然后上邻接表，然后AC。 /* ***Author :kuangbinCreated Time :2015/9/27 14:13:19File Name :F:\ACM\2015ACM\2015ÍøÂçÈü\2015ºÏ·Ê\1003.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 1000010;int a[MAXN],b[MAXN];int tot;bool used[MAXN]; struct Vec { struct Node { int to,next; }node[MAXN]; int head[MAXN],tot; int size[MAXN]; void init() { tot = 0; memset(head,-1,sizeof(head)); memset(size,0,sizeof(size)); } void Add(int i,int v) { node[tot].to = v; node[tot].next = head[i]; head[i] = tot++; size[i]++; }}V1,V2; int main(){ int T; int n; scanf(“%d”,&amp;T); int iCase = 0; while(T–) { iCase++; scanf(“%d”,&amp;n); map&lt;int,int&gt;mp1,mp2; int tot1 = 0; int tot2 = 0; mp1.clear(); mp2.clear(); V1.init(); V2.init(); for(int i = 0;i &lt; n;i++) { scanf(“%d%d”,&amp;a[i],&amp;b[i]); if(mp1.find(a[i]) == mp1.end()) { mp1[a[i]] = tot1++; } if(mp2.find(b[i]) == mp2.end()) { mp2[b[i]] = tot2++; } a[i] = mp1[a[i]]; b[i] = mp2[b[i]]; V1.Add(a[i],i); V2.Add(b[i],i); } int ans1 = 0; int ans2 = 0; int ans3 = 0; memset(used,false,sizeof(used)); for(int i = 0;i &lt; tot1;i++) { if(V1.size[i] &lt; 1)continue; int cnt = 0; int num = 0; for(int j = V1.head[i]; j != -1;j = V1.node[j].next) { int v = V1.node[j].to; if(!used[b[v]]) { cnt += V2.size[b[v]]; used[b[v]] = true; num++; } } if(cnt == V1.size[i] &amp;&amp; num &gt; 1)ans1++; if(cnt == V1.size[i] &amp;&amp; num == 1)ans3++; for(int j = V1.head[i]; j != -1;j = V1.node[j].next) { int v = V1.node[j].to; used[b[v]] = false; } } for(int i = 0;i &lt; tot2;i++) { if(V2.size[i] &lt; 1)continue; int cnt = 0; int num = 0; for(int j = V2.head[i]; j != -1;j = V2.node[j].next) { int v = V2.node[j].to; if(!used[a[v]]) { cnt += V1.size[a[v]]; used[a[v]] = true; num++; } } if(cnt == V2.size[i] &amp;&amp; num &gt; 1)ans2++; for(int j = V2.head[i]; j != -1;j = V2.node[j].next) { int v = V2.node[j].to; used[a[v]] = false; } } printf(“Case #%d: %d %d %d\n”,iCase,ans1,ans2,ans3); } return 0; }]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>图论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5487 Difference of Languages]]></title>
    <url>%2F2015%2F10%2F01%2Fhdu5487%2F</url>
    <content type="text"><![CDATA[写一些题解，把网络赛时候写的题记录下，免得以后找不到代码了～ 题目链接： hdu5487 Difference of LanguagesTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 376 Accepted Submission(s): 86 Problem Description A regular language can be represented as a deterministic finite automaton (DFA). A DFA contains a finite set of states Q and a finite set of input symbols called the alphabet Σ. Initially, the DFA is positioned at the start state q0∈Q. Given the transition function δ(q,a) and an input symbol a, the DFA transit to state δ(q,a) if its current state is q. Let w=a1a2…an be a string over the alphabet Σ. According to the above definition, the DFA transits through the following sequence of states. q0,q1=δ(q0,a1),q2=δ(q1,a2),…,qn=δ(qn−1,an) The DFA also contains a set of accept states F⊆Q. If the last state qn is an accept state, we say that the DFA accepts the string w. The set of accepted strings is referred as the language that the DFA represents. You are given two DFAs, and the languages that they represent may be different. You want to find the difference between the two languages. Specifically, you are trying to find a string that is accepted by one DFA but not accepted by the other DFA. As there could be multiple such strings, you only want the shortest one. If there are still multiple such strings, you would like the smallest one in lexicographical order. Input The first line of input contains a number T indicating the number of test cases (T≤200). Each test case contains the description of two DFAs. For the first DFA, the first line contains three integers N, M, and K, indicating the number of states, the number of rules describing the transition function, and the number of accept states (1≤K≤N≤1000,0≤M≤26N). The states are numbered from 0 to N–1. The start state is always 0. The second line contains K integers representing the accept states. All these numbers are distinct. Each of the next M lines consists of two states p and q, and an input symbol a, which means that the DFA transits from p to q when it receives the symbol a. You may assume that the alphabet in consideration consists of the 26 lowercase letters (a-z). It is guaranteed that, given p and a, the next state q is unique. The description of the second DFA follows the same format as the above. Output For each test case, output a single line consisting of “Case #X: Y”. X is the test case number starting from 1. Y is the shortest string that is accepted by one DFA but not accepted by the other DFA. If no such string exists, output the digit “0” instead. Note that an empty string is also considered a string. Sample Input 2 3 3 1 2 0 1 a 1 2 b 2 0 c 4 4 1 3 0 1 a 1 2 b 2 3 c 3 0 a 3 3 1 2 0 1 a 1 2 b 2 0 c 3 4 1 2 0 1 a 1 2 b 1 2 c 2 0 c Sample Output Case #1: ab Case #2: ac Source 2015 ACM/ICPC Asia Regional Hefei Online 题意大致就是两个自动机， 要求出一个最短的字符串，可以被其中一个自动机接受，不能被另外一个接受。 直接暴力，BFS转移就可。 BFS出来第一个就是最短的了，而且字典序是最小的。 注意转移的一些细节就好。 /* ***Author :kuangbinCreated Time :2015/9/27 15:29:44File Name :F:\ACM\2015ACM\2015ÍøÂçÈü\2015ºÏ·Ê\1004.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;struct Trie { int next[2010][26]; bool end[2010]; int n; void init(int _n) { memset(next,-1,sizeof(next)); for(int i = 0;i &lt; 26;i++) next[_n][i] = _n; n = _n; memset(end,false,sizeof(end)); } void add(int u,int v,char ch) { next[u][ch-‘a’] = v; }}tree1,tree2; struct Node { int s1,s2; Node(int _s1=0,int _s2=0) { s1 = _s1; s2 = _s2; } Node next(int i) { Node ret; ret.s1 = tree1.next[s1][i]; ret.s2 = tree2.next[s2][i]; if(ret.s1 == -1)ret.s1 = tree1.n; if(ret.s2 == -1)ret.s2 = tree2.n; return ret; }};int dp[1020][1020];pair&lt;int,int&gt; pres[1020][1020];int prech[1020][1020];char str[1020]; bool bfs() { queueq; memset(dp,-1,sizeof(dp)); q.push(Node(0,0)); dp[0][0] = 0; while(!q.empty()) { Node now = q.front(); int s1 = now.s1; int s2 = now.s2; q.pop(); if ( (tree1.end[now.s1]^tree2.end[now.s2]) ) { str[dp[s1][s2]] = 0; int len = dp[s1][s2]; for(int i = 0;i &lt; len;i++) { str[len-1-i] = (prech[s1][s2]+’a’); pair&lt;int,int&gt;tmp = pres[s1][s2]; s1 = tmp.first; s2 = tmp.second; } return true; } for(int i = 0;i &lt; 26;i++) { if(!tree1.next[s1][i] &amp;&amp; !tree2.next[s2][i])continue; Node nn = now.next(i); if(dp[nn.s1][nn.s2] != -1)continue; dp[nn.s1][nn.s2] = dp[s1][s2]+1; pres[nn.s1][nn.s2] = make_pair(s1,s2); prech[nn.s1][nn.s2] = i; q.push(nn); } } return false;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; scanf(“%d”,&amp;T); while(T–) { iCase++; int n,m,k; scanf(“%d%d%d”,&amp;n,&amp;m,&amp;k); tree1.init(n); int u,v; while(k–) { scanf(“%d”,&amp;u); tree1.end[u] = true; } char ss[10]; while(m–) { scanf(“%d%d%s”,&amp;u,&amp;v,ss); tree1.add(u,v,ss[0]); } scanf(“%d%d%d”,&amp;n,&amp;m,&amp;k); tree2.init(n); while(k–){ scanf(“%d”,&amp;u); tree2.end[u] = true; } while(m–) { scanf(“%d%d%s”,&amp;u,&amp;v,ss); tree2.add(u,v,ss[0]); } if(bfs())printf(“Case #%d: %s\n”,iCase,str); else printf(“Case #%d: 0\n”,iCase); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning]]></title>
    <url>%2F2015%2F08%2F13%2Fmachine-learning%2F</url>
    <content type="text"><![CDATA[coursera: https://www.coursera.org/learn/machine-learning/home/welcome (start !!!) http://cs229.stanford.edu/]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习和深度学习资料]]></title>
    <url>%2F2015%2F06%2F10%2Fml-dl-links%2F</url>
    <content type="text"><![CDATA[machine learning and deep learning 一些学习资料 http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=MachineLearning https://github.com/rasmusbergpalm/DeepLearnToolbox https://www.coursera.org/course/ml 人工智能和机器学习领域的一些开源项目： here]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后一场ICPC比赛]]></title>
    <url>%2F2015%2F05%2F20%2Flasticpc%2F</url>
    <content type="text"><![CDATA[明天就是2015 world finals了。 作为我的最后一场ICPC比赛，我还是充满着期待和不舍的。接触ICPC也差不多刚好要四年了，明天过后就彻底滚粗了。金银铜铁都拿过了，也进过一次final，虽然也好多没有实现，留下过很多遗憾，但是也是时候告别ICPC了。我们都需要展望明天，不断实现新的目标！ Goodbye, ICPC! 祝所有参赛的人好运，good luck!]]></content>
      <categories>
        <category>其他</category>
        <category>杂言</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6773 - Game Strategy]]></title>
    <url>%2F2015%2F05%2F11%2Fuvalive6773%2F</url>
    <content type="text"><![CDATA[题目链接：UVALive6773 比较简单的博弈。 直接进行状态压缩，然后DP就可以了。水题！ /* ***Author :kuangbinCreated Time :2015/5/11 15:00:44File Name :F:\ACM\2015ACM\比赛练习\2014final\D.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; vectorvec[30];int ans[30][30];char str[30]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ for(int i = 0;i &lt; n;i++){ vec[i].clear(); int num; scanf(“%d”,&amp;num); while(num–){ scanf(“%s”,str); int len = strlen(str); int tmp = 0; for(int j = 0;j &lt; len;j++) tmp |= (1&lt;&lt;(str[j]-‘a’)); vec[i].push_back(tmp); } } memset(ans,-1,sizeof(ans)); for(int j = 0;j &lt; n;j++){ int s = (1&lt;&lt;j); ans[j][j] = 0; for(int cnt = 1;cnt &lt; n;cnt++){ int ns = s; for(int i = 0;i &lt; n;i++) if(ans[i][j] == -1){ bool flag = false; for(int k = 0;k &lt; vec[i].size();k++) if((s&amp;vec[i][k]) == vec[i][k]){ flag = true; break; } if(flag){ ns |= (1&lt;&lt;i); ans[i][j] = cnt; } } s = ns; } } for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) printf(“%d%c”,ans[i][j],j==n-1?’\n’:’ ‘); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015编程之美复赛题解]]></title>
    <url>%2F2015%2F05%2F10%2F2015bop%2F</url>
    <content type="text"><![CDATA[比赛链接： here 编程之美复赛，四个简单题！ 勉强可以混了个#26。 A题：here 时间限制:2000ms 单点时限:1000ms 内存限制:256MB 描述Z国有n个城市，编号为1, 2, …, n。城市间通过n – 1条道路相连，任意两个城市间有且仅有一条路径可以相互到达。每个城市都有一些货物，政府希望将所有的货物运送到港口城市s以便出口。由于交通条件限制，每一条道路上单位时间只能通过1单位量的货物，这导致运输所有货物可能非常耗时。因而，政府希望知道，最快什么时候能将所有货物运送到港口。 输入第一行一个整数T，表示数据组数，以下是T组数据。 每组数据第一行有两个整数n和s，表示城市个数和港口城市的编号。接下来n - 1行每行两个整数i和j，表示城市i和j之间有一条道路。接下来n行每行一个数x，表示各城市的货物数量。 输出对每组数据输出一行”Case #X: Y”，X表示数据编号（从1开始），Y为完成运输任务的最短时间。 数据范围1 ≤ T ≤ 20 小数据 1 ≤ n ≤ 500 0 ≤ x ≤ 20 大数据 1 ≤ n ≤ 100000 0 ≤ x ≤ 100000 样例输入 23 21 22 31215 11 22 32 42 551221 样例输出 Case #1: 1Case #2: 6 A题感觉题意没有非常清楚。 好像一个单位时间是可以走任意条边的。然后只需要输出 s 的子树大小的最大值。 好多做法都可以水过，不能多说。 复杂的方法就不会了。TAT 代码就不贴了。 B题： here #1169 : 猜数字时间限制:10000ms 单点时限:5000ms 内存限制:256MB 描述你正在和小冰玩一个猜数字的游戏。小冰首先生成一个长为N的整数序列A1, A2, …, AN。在每一轮游戏中，小冰会给出一个区间范围[L, R]，然后你要猜一个数K。如果K在AL, AL+1, …, AR中，那么你获胜。 在尝试了几轮之后，你发现这个游戏太难（无聊）了。小冰决定给你一些提示，你每猜一次，小冰会告诉你K与AL, AL+1, …, AR中最接近的数的绝对差值，即min(|Ai - K|), L ≤ i ≤ R。 现在，请你实现这个新功能。 输入第一行为一个整数T，表示数据组数。 每组数据的第一行为两个整数N和Q。 第二行为N个由空格分开的整数，分别代表A1, A2, …, AN。 接下来Q行，每行三个由空格隔开的整数L、R、K。 输出每组数据的先输出一行”Case #X:”，X为测试数据编号。 接下来对每个询问输出一行，每行为一个整数，即为所求的值。 数据范围1 ≤ T ≤ 20 0 ≤ Ai, K ≤ 109 1 ≤ L ≤ R ≤ N 小数据 1 ≤ N, Q ≤ 1000 大数据 1 ≤ N, Q ≤ 200000 输入数据量较大，推荐使用scanf / BufferedReader等IO方法。 样例输入 19 31 8 3 4 9 2 7 6 51 9 103 7 95 6 5 样例输出 Case #1:103 裸题。 我是直接上的主席树。然后比赛时候姿势不够优美，TLE了大数据。 赛后修改下过了。 另外一种方法就是离线一发。然后直接从小大到一遍，只需要查询区间最大值。 然后从大到小一遍，查询区间最小值。 一个线段树足矣。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/* ***************Author :kuangbinCreated Time :2015/5/9 14:09:29File Name :F:\ACM\2015ACM\比赛练习\编程之美2015复赛\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 200010;const int M = MAXN * 30;int n,q,m,tot;int a[MAXN];int bb[MAXN];int T[MAXN], lson[M], rson[M], c[M];int build(int l,int r)&#123; int root = tot++; c[root] = 0; if(l != r)&#123; int mid = (l+r)&gt;&gt;1; lson[root] = build(l,mid); rson[root] = build(mid+1,r); &#125; return root;&#125;int update(int root,int pos,int val)&#123; int newroot = tot++, tmp = newroot; c[newroot] = c[root] + val; int l = 1, r = m; while(l &lt; r)&#123; int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid)&#123; lson[newroot] = tot++; rson[newroot] = rson[root]; newroot = lson[newroot]; root = lson[root]; r = mid; &#125; else&#123; rson[newroot] = tot++; lson[newroot] = lson[root]; newroot = rson[newroot]; root = rson[root]; l = mid+1; &#125; c[newroot] = c[root] + val; &#125; return tmp;&#125;//查询小于等于k的最大的int query1(int left_root,int right_root,int l,int r,int k)&#123; if(c[left_root] - c[right_root] == 0)return -1; if(bb[l] &gt; k)return -1; if(l == r)return l; int mid = (l+r)/2; int t1 = query1(rson[left_root],rson[right_root],mid+1,r,k); if(t1 != -1)return t1; else return query1(lson[left_root],lson[right_root],l,mid,k);&#125;//查询大于等于k的最小的int query2(int left_root,int right_root,int l,int r,int k)&#123; if(c[left_root]-c[right_root] == 0)return -1; if(bb[r] &lt; k)return -1; if(l == r)return l; int mid = (l+r)/2; int t1 = query2(lson[left_root],lson[right_root],l,mid,k); if(t1 != -1)return t1; else return query2(rson[left_root],rson[right_root],mid+1,r,k);&#125;//适用于正负整数template &lt;class T&gt;inline bool scan_d(T &amp;ret) &#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar(); sgn=(c=='-')?-1:1; ret=(c=='-')?0:(c-'0'); while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9') ret=ret*10+(c-'0'); ret*=sgn; return 1;&#125;inline void out(int x) &#123; if(x&gt;9) out(x/10); putchar(x%10+'0');&#125;struct QQ&#123; int l,r,k; void input()&#123; scan_d(l); scan_d(r); scan_d(k); &#125;&#125;qq[200010];int main()&#123; int TT; int iCase = 0; scanf("%d",&amp;TT); while(TT--)&#123; scanf("%d%d",&amp;n,&amp;q); tot = 0; int cnt = 0; for(int i = 1;i &lt;= n;i++)&#123; scan_d(a[i]); bb[++cnt] = a[i]; &#125; for(int i = 0;i &lt; q;i++)&#123; qq[i].input(); &#125; sort(bb+1,bb+cnt+1); cnt = unique(bb+1,bb+cnt+1)-bb-1; m = cnt; for(int i = 1;i &lt;= n;i++) a[i] = lower_bound(bb+1,bb+m+1,a[i])-bb; T[n+1] = build(1,m); for(int i = n;i ;i--)&#123; int pos = a[i]; T[i] = update(T[i+1],pos,1); &#125; iCase++; printf("Case #%d:\n",iCase); for(int i = 0;i &lt; q;i++)&#123; int l = qq[i].l; int r = qq[i].r; int k = qq[i].k; int ans = 2000000000; int t1 = query1(T[l],T[r+1],1,m,k); if(t1 != -1)ans = min(ans,k-bb[t1]); int t2 = query2(T[l],T[r+1],1,m,k); if(t2 != -1)ans = min(ans,bb[t2]-k); out(ans); puts(""); &#125; &#125; return 0;&#125; C题： here #1170 : 机器人时间限制:2000ms 单点时限:1000ms 内存限制:256MB 描述小冰的N个机器人兄弟排成一列，每个机器人有一个颜色。现在小冰想让同一颜色的机器人聚在一起，即任意两个同颜色的机器人之间没有其他颜色的的机器人。 假设任意相邻的两个机器人可以交换位置，请问最少需要多少次交换？ 输入第一行为一个整数T，为数据组数，之后每组数据两行。 第一行为N和K，表示机器人的个数与颜色的总数。 接下来一行N个数，第i个数表示第i个机器人的颜色，取值范围为1到K。 输出对于每组数据输出一行，形如”Case #X: Y”。X为数据组数，从1开始，Y为最少的交换步数。 数据范围1 ≤ T ≤ 20 1 ≤ N ≤ 105 小数据 1 ≤ K ≤ 3 大数据 1 ≤ K ≤ 16 样例输入 34 21 2 1 26 42 1 4 3 1 28 61 3 2 5 5 4 5 2 样例输出 Case #1: 1Case #2: 6Case #3: 5 首先相同颜色的相对顺序是不会改变的。交换次数其实就是逆序数。 然后就可以进行状态压缩DP。 我只需要知道前面选了哪些颜色。然后后面加入一种颜色的时候，就可以算出增加多少逆序对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/* ***************Author :kuangbinCreated Time :2015/5/9 15:40:20File Name :F:\ACM\2015ACM\比赛练习\编程之美2015复赛\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;int a[MAXN];template &lt;class T&gt;inline bool scan_d(T &amp;ret) &#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar(); sgn=(c=='-')?-1:1; ret=(c=='-')?0:(c-'0'); while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9') ret=ret*10+(c-'0'); ret*=sgn; return 1;&#125;long long num[20][20];int b[20];long long dp[1&lt;&lt;16];const long long INF = 10000000000000000LL;long long f[1&lt;&lt;16][16];int bit[20];int loc[1&lt;&lt;20];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); bit[0] = 1; loc[1] = 0; for(int i = 1;i &lt; 20;i++)&#123; bit[i] = 2*bit[i-1]; loc[bit[i]] = i; &#125; int T; int iCase = 0; int n,k; scanf("%d",&amp;T); while(T--)&#123; iCase++; scanf("%d%d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++)&#123; scan_d(a[i]); a[i]--; &#125; memset(num,0,sizeof(num)); memset(b,0,sizeof(b)); for(int i = n;i &gt;= 1;i--)&#123; for(int j = 0;j &lt; k;j++) if(j != a[i]) num[a[i]][j] += b[j]; b[a[i]]++; &#125; int tot = (1&lt;&lt;k); for(int i = 0;i &lt; tot;i++)dp[i] = INF; dp[0] = 0; for(int j = 0;j &lt; 16;j++)&#123; f[0][j] = 0; for(int i = 1;i &lt; tot;i++)&#123; int tmp = i&amp;(-i); f[i][j] = f[i^tmp][j] + num[j][loc[tmp]]; &#125; &#125; for(int i = 0;i &lt; tot;i++)&#123; if(dp[i] == INF)continue; for(int j = 0;j &lt; k;j++)&#123; if(i &amp; bit[j])continue; dp[i|bit[j]] = min(dp[i|bit[j]],dp[i]+f[i][j]); &#125; &#125; printf("Case #%d: ",iCase); cout&lt;&lt;dp[tot-1]&lt;&lt;endl; &#125; return 0;&#125; D题： here #1171 : 城市和魔法塔时间限制:2000ms 单点时限:1000ms 内存限制:256MB 描述2D平面上有M座城市，你被任命保卫这些城市。有两种方案可供选择。 1. 直接使用G枚金币为一座城市构建城防系统。 2. 平面上还有N座古老的魔法塔。你可以激活它们，代价为一座魔法塔P枚金币。任意两座激活的魔法塔之间可以直线连接，构建魔法屏障，被魔法屏障包围的那些城市会被保护。 现在给定城市与魔法塔的坐标，求最小的代价。 如上图所示，方块表示城市，黑色圆表示激活的魔法塔，白色圆表示未激活的魔法塔，直线表示构建的魔法屏障。按照上图的方式，费用为6P + G。 输入第一行为一个整数T，为数据组数，之后每组数据若干行。 第一行为四个整数，N, M, G, P，分别代表魔法塔个数、城市个数、城防系统代价、激活魔法塔代价。 接下来N行，每行两个整数，表示魔法塔的坐标。 接下来M行，每行两个整数，表示城市的坐标。 输出对于每组数据输出一行”Case #X: Y”，X为数据组数，从1开始，Y为最少的代价。 数据范围1 ≤ T ≤ 100 1000 ≤ G ≤ 2000 100 ≤ P ≤ 200 所有坐标范围在0至1000之间，所有点（包括城市与魔法塔）没有重合，没有三点共线。 小数据 0 ≤ N, M ≤ 10 大数据 0 ≤ N, M ≤ 100 样例输入 27 6 1000 1000 020 01 1039 101 2039 2020 303 937 93 2137 2118 2450 244 3 1500 1000 00 1010 010 105 44 18 6 样例输出 Case #1: 1600Case #2: 300 原题。 当年写过一发题解： here 能圈的肯定要圈起来。 然后就是选最少的点，来圈起来了。 floyed 一发就好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006/* ***************Author :kuangbinCreated Time :2015/5/9 15:08:23File Name :F:\ACM\2015ACM\比赛练习\编程之美2015复赛\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double eps = 1e-8;const double inf = 1e20;const double pi = acos(-1.0);const int maxp = 110;//`Compares a double to zero`int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;//square of a doubleinline double sqr(double x)&#123;return x*x;&#125;/* * Point * Point() - Empty constructor * Point(double _x,double _y) - constructor * input() - double input * output() - %.2f output * operator == - compares x and y * operator &lt; - compares first by x, then by y * operator - - return new Point after subtracting curresponging x and y * operator ^ - cross product of 2d points * operator * - dot product * len() - gives length from origin * len2() - gives square of length from origin * distance(Point p) - gives distance from p * operator + Point b - returns new Point after adding curresponging x and y * operator * double k - returns new Point after multiplieing x and y by k * operator / double k - returns new Point after divideing x and y by k * rad(Point a,Point b)- returns the angle of Point a and Point b from this Point * trunc(double r) - return Point that if truncated the distance from center to r * rotleft() - returns 90 degree ccw rotated point * rotright() - returns 90 degree cw rotated point * rotate(Point p,double angle) - returns Point after rotateing the Point centering at p by angle radian ccw */struct Point&#123; double x,y; Point()&#123;&#125; Point(double _x,double _y)&#123; x = _x; y = _y; &#125; void input()&#123; scanf("%lf%lf",&amp;x,&amp;y); &#125; void output()&#123; printf("%.2f %.2f\n",x,y); &#125; bool operator == (Point b)const&#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0; &#125; bool operator &lt; (Point b)const&#123; return sgn(x-b.x)== 0?sgn(y-b.y)&lt;0:x&lt;b.x; &#125; Point operator -(const Point &amp;b)const&#123; return Point(x-b.x,y-b.y); &#125; //叉积 double operator ^(const Point &amp;b)const&#123; return x*b.y - y*b.x; &#125; //点积 double operator *(const Point &amp;b)const&#123; return x*b.x + y*b.y; &#125; //返回长度 double len()&#123; return hypot(x,y);//库函数 &#125; //返回长度的平方 double len2()&#123; return x*x + y*y; &#125; //返回两点的距离 double distance(Point p)&#123; return hypot(x-p.x,y-p.y); &#125; Point operator +(const Point &amp;b)const&#123; return Point(x+b.x,y+b.y); &#125; Point operator *(const double &amp;k)const&#123; return Point(x*k,y*k); &#125; Point operator /(const double &amp;k)const&#123; return Point(x/k,y/k); &#125; //计算pa 和 pb 的夹角 //就是求这个点看a,b 所成的夹角 //测试 LightOJ1203 double rad(Point a,Point b)&#123; Point p = *this; return fabs(atan2( fabs((a-p)^(b-p)),(a-p)*(b-p) )); &#125; //化为长度为r的向量 Point trunc(double r)&#123; double l = len(); if(!sgn(l))return *this; r /= l; return Point(x*r,y*r); &#125; //逆时针旋转90度 Point rotleft()&#123; return Point(-y,x); &#125; //顺时针旋转90度 Point rotright()&#123; return Point(y,-x); &#125; //绕着p点逆时针旋转angle Point rotate(Point p,double angle)&#123; Point v = (*this) - p; double c = cos(angle), s = sin(angle); return Point(p.x + v.x*c - v.y*s,p.y + v.x*s + v.y*c); &#125;&#125;;/* * Stores two points * Line() - Empty constructor * Line(Point _s,Point _e) - Line through _s and _e * operator == - checks if two points are same * Line(Point p,double angle) - one end p , another end at angle degree * Line(double a,double b,double c) - Line of equation ax + by + c = 0 * input() - inputs s and e * adjust() - orders in such a way that s &lt; e * length() - distance of se * angle() - return 0 &lt;= angle &lt; pi * relation(Point p) - 3 if point is on line * 1 if point on the left of line * 2 if point on the right of line * pointonseg(double p) - return true if point on segment * parallel(Line v) - return true if they are parallel * segcrossseg(Line v) - returns 0 if does not intersect * returns 1 if non-standard intersection * returns 2 if intersects * linecrossseg(Line v) - line and seg * linecrossline(Line v) - 0 if parallel * 1 if coincides * 2 if intersects * crosspoint(Line v) - returns intersection point * dispointtoline(Point p) - distance from point p to the line * dispointtoseg(Point p) - distance from p to the segment * dissegtoseg(Line v) - distance of two segment * lineprog(Point p) - returns projected point p on se line * symmetrypoint(Point p) - returns reflection point of p over se * */struct Line&#123; Point s,e; Line()&#123;&#125; Line(Point _s,Point _e)&#123; s = _s; e = _e; &#125; bool operator ==(Line v)&#123; return (s == v.s)&amp;&amp;(e == v.e); &#125; //根据一个点和倾斜角angle确定直线,0&lt;=angle&lt;pi Line(Point p,double angle)&#123; s = p; if(sgn(angle-pi/2) == 0)&#123; e = (s + Point(0,1)); &#125; else&#123; e = (s + Point(1,tan(angle))); &#125; &#125; //ax+by+c=0 Line(double a,double b,double c)&#123; if(sgn(a) == 0)&#123; s = Point(0,-c/b); e = Point(1,-c/b); &#125; else if(sgn(b) == 0)&#123; s = Point(-c/a,0); e = Point(-c/a,1); &#125; else&#123; s = Point(0,-c/b); e = Point(1,(-c-a)/b); &#125; &#125; void input()&#123; s.input(); e.input(); &#125; void adjust()&#123; if(e &lt; s)swap(s,e); &#125; //求线段长度 double length()&#123; return s.distance(e); &#125; //返回直线倾斜角 0&lt;=angle&lt;pi double angle()&#123; double k = atan2(e.y-s.y,e.x-s.x); if(sgn(k) &lt; 0)k += pi; if(sgn(k-pi) == 0)k -= pi; return k; &#125; //点和直线关系 //`1 在左侧` //`2 在右侧` //`3 在直线上` int relation(Point p)&#123; int c = sgn((p-s)^(e-s)); if(c &lt; 0)return 1; else if(c &gt; 0)return 2; else return 3; &#125; // 点在线段上的判断 bool pointonseg(Point p)&#123; return sgn((p-s)^(e-s)) == 0 &amp;&amp; sgn((p-s)*(p-e)) &lt;= 0; &#125; //两向量平行(对应直线平行或重合) bool parallel(Line v)&#123; return sgn((e-s)^(v.e-v.s)) == 0; &#125; //两线段相交判断 //`2 规范相交` //`1 非规范相交` //`0 不相交` int segcrossseg(Line v)&#123; int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); int d3 = sgn((v.e-v.s)^(s-v.s)); int d4 = sgn((v.e-v.s)^(e-v.s)); if( (d1^d2)==-2 &amp;&amp; (d3^d4)==-2 )return 2; return (d1==0 &amp;&amp; sgn((v.s-s)*(v.s-e))&lt;=0) || (d2==0 &amp;&amp; sgn((v.e-s)*(v.e-e))&lt;=0) || (d3==0 &amp;&amp; sgn((s-v.s)*(s-v.e))&lt;=0) || (d4==0 &amp;&amp; sgn((e-v.s)*(e-v.e))&lt;=0); &#125; //直线和线段相交判断 //-*this line -v seg //`2 规范相交` //`1 非规范相交` //`0 不相交` int linecrossseg(Line v)&#123; int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); if((d1^d2)==-2) return 2; return (d1==0||d2==0); &#125; //两直线关系 //`0 平行` //`1 重合` //`2 相交` int linecrossline(Line v)&#123; if((*this).parallel(v)) return v.relation(s)==3; return 2; &#125; //求两直线的交点 //要保证两直线不平行或重合 Point crosspoint(Line v)&#123; double a1 = (v.e-v.s)^(s-v.s); double a2 = (v.e-v.s)^(e-v.s); return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1)); &#125; //点到直线的距离 double dispointtoline(Point p)&#123; return fabs((p-s)^(e-s))/length(); &#125; //点到线段的距离 double dispointtoseg(Point p)&#123; if(sgn((p-s)(e-s))&lt;0 || sgn((p-e)(s-e))&lt;0) return min(p.distance(s),p.distance(e)); return dispointtoline(p); &#125; //返回线段到线段的距离 //前提是两线段不相交，相交距离就是0了 double dissegtoseg(Line v)&#123; return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e))); &#125; //返回点p在直线上的投影 Point lineprog(Point p)&#123; return s + ( ((e-s)((e-s)(p-s)))/((e-s).len2()) ); &#125; //返回点p关于直线的对称点 Point symmetrypoint(Point p)&#123; Point q = lineprog(p); return Point(2*q.x-p.x,2*q.y-p.y); &#125;&#125;;struct polygon&#123; int n; Point p[maxp]; Line l[maxp]; void input(int _n)&#123; n = _n; for(int i = 0;i &lt; n;i++) p[i].input(); &#125; void add(Point q)&#123; p[n++] = q; &#125; void getline()&#123; for(int i = 0;i &lt; n;i++)&#123; l[i] = Line(p[i],p[(i+1)%n]); &#125; &#125; struct cmp&#123; Point p; cmp(const Point &amp;p0)&#123;p = p0;&#125; bool operator()(const Point &amp;aa,const Point &amp;bb)&#123; Point a = aa, b = bb; int d = sgn((a-p)^(b-p)); if(d == 0)&#123; return sgn(a.distance(p)-b.distance(p)) &lt; 0; &#125; return d &gt; 0; &#125; &#125;; //进行极角排序 //首先需要找到最左下角的点 //需要重载号好Point的 &lt; 操作符(min函数要用) void norm()&#123; Point mi = p[0]; for(int i = 1;i &lt; n;i++)mi = min(mi,p[i]); sort(p,p+n,cmp(mi)); &#125; //得到凸包 //得到的凸包里面的点编号是0$\\sim$n-1的 //两种凸包的方法 //注意如果有影响，要特判下所有点共点，或者共线的特殊情况 //测试 LightOJ1203 LightOJ1239 void getconvex(polygon &amp;convex)&#123; sort(p,p+n); convex.n = n; for(int i = 0;i &lt; min(n,2);i++)&#123; convex.p[i] = p[i]; &#125; if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 if(n &lt;= 2)return; int &amp;top = convex.n; top = 1; for(int i = 2;i &lt; n;i++)&#123; while(top &amp;&amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) &lt;= 0) top--; convex.p[++top] = p[i]; &#125; int temp = top; convex.p[++top] = p[n-2]; for(int i = n-3;i &gt;= 0;i--)&#123; while(top != temp &amp;&amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) &lt;= 0) top--; convex.p[++top] = p[i]; &#125; if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 convex.norm();//原来得到的是顺时针的点，排序后逆时针 &#125; //得到凸包的另外一种方法 //测试 LightOJ1203 LightOJ1239 void Graham(polygon &amp;convex)&#123; norm(); int &amp;top = convex.n; top = 0; if(n == 1)&#123; top = 1; convex.p[0] = p[0]; return; &#125; if(n == 2)&#123; top = 2; convex.p[0] = p[0]; convex.p[1] = p[1]; if(convex.p[0] == convex.p[1])top--; return; &#125; convex.p[0] = p[0]; convex.p[1] = p[1]; top = 2; for(int i = 2;i &lt; n;i++)&#123; while( top &gt; 1 &amp;&amp; sgn((convex.p[top-1]-convex.p[top-2])^(p[i]-convex.p[top-2])) &lt;= 0 ) top--; convex.p[top++] = p[i]; &#125; if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 &#125; //判断是不是凸的 bool isconvex()&#123; bool s[2]; memset(s,false,sizeof(s)); for(int i = 0;i &lt; n;i++)&#123; int j = (i+1)%n; int k = (j+1)%n; s[sgn((p[j]-p[i])^(p[k]-p[i]))+1] = true; if(s[0] &amp;&amp; s[2])return false; &#125; return true; &#125; //判断点和任意多边形的关系 //3 点上 //2 边上 //1 内部 //0 外部 int relationpoint(Point q)&#123; for(int i = 0;i &lt; n;i++)&#123; if(p[i] == q)return 3; &#125; getline(); for(int i = 0;i &lt; n;i++)&#123; if(l[i].pointonseg(q))return 2; &#125; int cnt = 0; for(int i = 0;i &lt; n;i++)&#123; int j = (i+1)%n; int k = sgn((q-p[j])^(p[i]-p[j])); int u = sgn(p[i].y-q.y); int v = sgn(p[j].y-q.y); if(k &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0)cnt++; if(k &lt; 0 &amp;&amp; v &lt; 0 &amp;&amp; u &gt;= 0)cnt--; &#125; return cnt != 0; &#125; //得到面积 double getarea()&#123; double sum = 0; for(int i = 0;i &lt; n;i++)&#123; sum += (p[i]^p[(i+1)%n]); &#125; return fabs(sum)/2; &#125; //得到方向 //1 表示逆时针，0表示顺时针 bool getdir()&#123; double sum = 0; for(int i = 0;i &lt; n;i++) sum += (p[i]^p[(i+1)%n]); if(sgn(sum) &gt; 0)return 1; return 0; &#125;&#125;;polygon po1,po2;Point city[110];Point pp[110];int dp[110][110];const int INF = 0x3f3f3f3f;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m,G,P; int T; int iCase = 0; scanf("%d",&amp;T); while(T--)&#123; iCase++; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;G,&amp;P); po1.input(n); for(int i = 0;i &lt; m;i++) city[i].input(); po1.getconvex(po2); int cnt = 0; for(int i = 0;i &lt; m;i++) if(po2.relationpoint(city[i]) &gt; 0) pp[cnt++] = city[i]; int ans = G*(m-cnt); if(cnt)&#123; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) dp[i][j] = INF; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++)&#123; if(i == j)continue; bool ff = true; for(int k = 0;k &lt; cnt;k++) if( sgn((po1.p[j]-po1.p[i])^(pp[k]-po1.p[i])) &lt;= 0) &#123; ff = false; break; &#125; if(ff)dp[i][j] = 1; &#125; for(int k = 0;k &lt; n;k++) for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]); int tmp = INF; for(int i = 0;i &lt; n;i++) tmp = min(tmp,dp[i][i]); ans += tmp*P; &#125; printf("Case #%d: %d\\n",iCase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6772 - Crane Balancing]]></title>
    <url>%2F2015%2F05%2F07%2Fuvalive6772%2F</url>
    <content type="text"><![CDATA[题目链接： UVALive link2 给了一个多边形。均匀分布的。 问在一个端点可以加多重，可以保持平衡。 简单题。 首先要找出多边形的重心。重心找法就是进行三角剖分，然后加权平均就可以了。 然后进行讨论几种情况，分别选取最左和最右的作为轴心点，然后就可以解决了。主要精度误差。 /* ***Author :kuangbinCreated Time :2015/5/7 19:46:56File Name :F:\ACM\2015ACM\比赛练习\2014final\C.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const double eps = 1e-8;const double INF = 1e30;const int MAXN = 110;struct Point{ int x,y; void input(){ scanf(“%d%d”,&amp;x,&amp;y); }}p[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ int Min = 100000; int Max = -100000; for(int i = 0;i &lt; n;i++){ p[i].input(); if(p[i].y == 0){ Min = min(Min,p[i].x); Max = max(Max,p[i].x); } } double x = 0, y = 0; double tot = 0; for(int i = 0;i &lt; n;i++){ int x1 = p[i].x; int y1 = p[i].y; int x2 = p[(i+1)%n].x; int y2 = p[(i+1)%n].y; double s = (x1*y2 - x2*y1)/2.0; tot += s; x += s(x1+x2)/3; y += s(y1+y2)/3; } x /= tot; y /= tot; tot = fabs(tot); double ans1; double ans2; bool flag = true; if(p[0].x &gt; Max){ if(x &gt; Max+eps)flag = false; else { if(x &lt; Min-eps)ans1 = tot(Min-x)/(p[0].x-Min); else ans1 = 0; ans2 = tot(Max-x)/(p[0].x-Max); } } else if(p[0].x &gt;= Min){ if(x &gt; Min - eps &amp;&amp; x &lt; Max + eps){ ans1 = 0; ans2 = INF; } else if(x &gt; Max+eps){ if(p[0].x == Max)flag = false; else { ans1 = tot(x-Max)/(Max-p[0].x); ans2 = INF; } } else { if(p[0].x == Min)flag = false; else { ans1 = tot(Min-x)/(p[0].x-Min); } } } else { if(x &lt; Min-eps)flag = false; else { if(x &gt; Max+eps)ans1 = tot(x-Max)/(Max-p[0].x); else ans1 = 0; ans2 = tot(x-Min)/(Min-p[0].x); } } if(!flag || ans1 &gt; ans2)printf(“unstable\n”); else { printf(“%.0lf .. “,floor(ans1)); if(ans2 == INF)printf(“inf\n”); else printf(“%.0lf\n”,ceil(ans2)); } } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6771 - Buffed Buffet （斜率优化）]]></title>
    <url>%2F2015%2F05%2F07%2Fuvalive6771%2F</url>
    <content type="text"><![CDATA[题目链接： UVALIVE link2 有两种，一种离散的，一种连续的。 离散的用斜率优化去DP，连续的暴力搞。 题解参考： http://blog.brucemerry.org.za/2014/06/acm-icpc-2014.html This one was deceptively sneaky, but the principles are reasonably simple. It’s not too hard to guess that one will solve the continuous and discrete problems separately, and then consider all partitions between the two. Let’s start with the continuous problem, since it is a little easier. I don’t have a formal proof, but it shouldn’t be too hard to convince yourself that a greedy strategy works. We start by eating the tastiest food. Once it degrades to being as tasty as the second-tastiest food, we then each both, in the proportion that makes them decay at the same rate. In fact, at this point we can treat them as a combined food with a combined (slower) decay rate. We continue eating this mix until tastiness decays to match the third-tastiest, and so on. There are some corner cases that need to be handled if there are foods that don’t decay. xiaodao的题解 代码： /* ***Author :kuangbinCreated Time :2015/5/6 22:21:18File Name :F:\ACM\2015ACM\比赛练习\2014final\B.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const long long LINF = 1e18;const double eps = 1e-8;long long dp[2][10010];int que[10010];long long X[10010],Y[10010];long long det(int k,int j,int i){ long long x1 = X[j] - X[k]; long long y1 = Y[j] - Y[k]; long long x2 = X[i] - X[k]; long long y2 = Y[i] - Y[k]; return x1*y2 - x2*y1;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int D,W; while(scanf(“%d%d”,&amp;D,&amp;W) == 2){ int now = 0; for(int i = 1;i &lt;= W;i++){ dp[now][i] = -LINF; } dp[now][0] = 0; vector&lt;pair&lt;int,int&gt; &gt;C; while(D–){ char op[2]; scanf(“%s”,op); if(op[0] == ‘D’){ int w,t,dt; scanf(“%d%d%d”,&amp;w,&amp;t,&amp;dt); now ^= 1; for(int i = 0;i &lt;= W;i++) dp[now][i] = -LINF; int st,ed; for(int c = 0;c &lt; w;c++){ st = ed = 0; for(int i = 0;iw+c &lt;= W;i++){ if(dp[now^1][iw+c] &gt; -LINF){ X[i] = i; Y[i] = dp[now^1][i*w+c]-t*i-(long long)(i*i+i)/2*dt; while(st+1 &lt; ed &amp;&amp; det(que[ed-2],que[ed-1],i) &gt;= 0)ed–; que[ed++] = i; } int k = -idt; while(st+1 &lt; ed &amp;&amp; Y[que[st]]-k\X[que[st]] &lt;= Y[que[st+1]]-k*X[que[st+1]])st++; if(st &lt; ed){ dp[now][i*w+c] = t*i - (long long)(i*i-i)/2*dt + Y[que[st]] - kX[que[st]]; } } } } else{ int t,dt; scanf(“%d%d”,&amp;t,&amp;dt); C.push_back(make_pair(t,dt)); } } if(C.size() == 0 &amp;&amp; dp[now][W] == -LINF){ printf(“impossible\n”); continue; } double ans = dp[now][W]; if(C.size() == 0){ printf(“%.10lf\n”,ans); continue; } sort(C.begin(),C.end()); reverse(C.begin(),C.end()); int sz = C.size(); int i = 0; int j = 0; double cur = C[0].first; double xx = 0; double del = 0; double ret = 0; double px = 0.0; while(i &lt; W){ while(j &lt; sz &amp;&amp; C[j].first &gt; cur-eps){ if(C[j].second == 0)del += 1e60; else del += 1.0/C[j].second; j++; } if(del &gt; 1e30){ while(i &lt; W){ ret += cur(i+1-max(1.0i,xx)); i++; ans = max(ans,ret+dp[now][W-i]); } break; } if(j == sz){ while(i &lt; W){ ret += (cur-1.0/del(max(1.0*i,xx)-xx)+cur-1.0/del*(i+1-xx))/2(i+1-max(1.0i,xx)); i++; ans = max(ans,ret+dp[now][W-i]); } break; } double nv = C[j].first; double nx = xx + (cur-nv)del; while(i &lt; W &amp;&amp; i+1 &lt; nx+eps){ ret += (cur-1.0/del(max(1.0*i,xx)-xx)+cur-1.0/del*(i+1-xx))/2(i+1-max(1.0i,xx)); i++; px = i; ans = max(ans,ret+dp[now][W-i]); } ret += (cur-1.0/del(px-xx)+nv)/2(nx-px); px = nx; xx = nx; cur = nv; } printf(“%.10lf\n”,ans); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1911: [Apio2010]特别行动队 （斜率优化DP）]]></title>
    <url>%2F2015%2F05%2F05%2Fbzoj1911%2F</url>
    <content type="text"><![CDATA[BZOJ1911 1911: [Apio2010]特别行动队Time Limit: 4 Sec Memory Limit: 64 MB Submit: 2695 Solved: 1209 [Submit][Status][Discuss] Description Input Output Sample Input4 -1 10 -20 2 2 3 4 Sample Output9 HINT 一道比较水的斜率优化的题目。 进行DP，然后把方程写出来就可以了。 mark下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* ***************Author :kuangbinCreated Time :2015/5/5 21:49:21File Name :F:\ACM\2015ACM\专题练习\斜率DP\BZOJ1911.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1000010;long long sum[MAXN];long long X[MAXN],Y[MAXN];long long dp[MAXN];long long det(int k,int j,int i)&#123; long long x1 = X[j] - X[k]; long long y1 = Y[j] - Y[k]; long long x2 = X[i] - X[k]; long long y2 = Y[i] - Y[k]; return x1*y2 - x2*y1;&#125;int que[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int a,b,c; int n; while(scanf("%d",&amp;n) == 1)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); sum[0] = 0; for(int i = 1;i &lt;= n;i++)&#123; int tmp; scanf("%d",&amp;tmp); sum[i] = sum[i-1] + tmp; &#125; dp[0] = 0; X[0] = 0; Y[0] = 0; int st,ed; st = ed = 0; que[ed++] = 0; for(int i = 1;i &lt;= n;i++)&#123; int k = 2*a*sum[i]; while(st+1 &lt; ed &amp;&amp; Y[que[st]]-k*X[que[st]] &lt;= Y[que[st+1]]-k*X[que[st+1]])st++; dp[i] = a*sum[i]*sum[i] + b*sum[i] + c + Y[que[st]] - k*X[que[st]]; X[i] = sum[i]; Y[i] = dp[i] + a*sum[i]*sum[i] - b*sum[i]; while(st+1 &lt; ed &amp;&amp; det(que\[ed-2\],que\[ed-1\],i) &gt;= 0)ed--; que[ed++] = i; &#125; printf("%lld\n",dp[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world finals]]></title>
    <url>%2F2015%2F05%2F04%2Fworld-finals%2F</url>
    <content type="text"><![CDATA[还有半个月就要参加ACM/ICPC world finals 了。不出意外，将会是我的最后一场ICPC比赛。 最近将会忙碌地准备一段时间了，虽然很累，但是感觉还是很有趣的。 人生，总要有那么几次，为梦想拼尽全力。 为了能进final，等待了好长的时间。 曾经和吴神约定要携手final，然后我和吴神都要去final了。 然而我还是这么弱，吴神却已经升级为吴鑫，拿金无数，随手碾压我。 很多时候，但求问心无愧，不留遗憾吧！ 最后一场比赛之后，就将退役了。祝福仍然在努力的人，祝你们成功！ 非常感谢一路走来给予过我帮助的人，也感谢曾经给予我鄙视和嘲讽的人。 很快就要去摩洛哥参加final了，如有需要明信片的，可以在下面留言可以寄到的地址（详细地址+姓名+邮编），算是感谢大家一直的支持吧。 将尽可能满足大家的要求（数量有限的话，将优先满足ACM交流群里面的群巨）！ 谢谢～]]></content>
      <categories>
        <category>其他</category>
        <category>杂言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6770 - Baggage （构造）]]></title>
    <url>%2F2015%2F04%2F21%2Fuvalive6770%2F</url>
    <content type="text"><![CDATA[UVALive6770 ACM ICPC 2014 world finals problem A 构造。 题解传送门： problem a ACM ICPC 2014 solution to problem A - baggage here (需要科学上网) 这题的构造方法。 首先要手算出n=3,4,5,6,7 的解。 然后由n的解，可以推出n+4的解，然后递推一发。 比如 __BABA (BA)^n BABA ABBABA (BA)^n B__A ABBA__ (BA)^n BBAA -&gt; ABBA A^n B^n BBAA AA A^n B^n BBBBAA AAAA A^n B^n BBBB 这样就可以由n的解放，推广到n+2的解放。 除了n=3外，其余的都是往左移动了两格的。 /* ***Author :kuangbinCreated Time :2015/4/21 16:31:24File Name :UVALive6770.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; vector&lt;pair&lt;int,int&gt; &gt;vec[110]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); vec[3].push_back(make_pair(2,-1)); vec[3].push_back(make_pair(5,2)); vec[3].push_back(make_pair(3,-3)); vec\[4\].push\_back(make\_pair(6,-1)); vec\[4\].push\_back(make\_pair(3,6)); vec\[4\].push\_back(make\_pair(0,3)); vec\[4\].push\_back(make\_pair(7,0)); vec\[5\].push\_back(make\_pair(8,-1)); vec\[5\].push\_back(make\_pair(3,8)); vec\[5\].push\_back(make\_pair(6,3)); vec\[5\].push\_back(make\_pair(0,6)); vec\[5\].push\_back(make\_pair(9,0)); vec\[6\].push\_back(make\_pair(10,-1)); vec\[6\].push\_back(make\_pair(7,10)); vec\[6\].push\_back(make\_pair(2,7)); vec\[6\].push\_back(make\_pair(6,2)); vec\[6\].push\_back(make\_pair(0,6)); vec\[6\].push\_back(make\_pair(11,0)); vec\[7\].push\_back(make\_pair(12,-1)); vec\[7\].push\_back(make\_pair(5,12)); vec\[7\].push\_back(make\_pair(8,5)); vec\[7\].push\_back(make\_pair(3,8)); vec\[7\].push\_back(make\_pair(9,3)); vec\[7\].push\_back(make\_pair(0,9)); vec\[7\].push\_back(make\_pair(13,0)); for(int i = 8;i &lt;= 100;i++){ vec\[i\].push\_back(make\_pair(2*i-2,-1)); vec\[i\].push\_back(make\_pair(3,2*i-2)); for(int j = 0;j &lt; i-4;j++) vec\[i\].push\_back(make\_pair(vec\[i-4\]\[j\].first+4,vec\[i-4\]\[j\].second+4)); vec\[i\].push\_back(make\_pair(0,2*i-5)); vec\[i\].push\_back(make\_pair(2*i-1,0)); } int n; bool first = true; while(scanf(&quot;%d&quot;,&amp;n) == 1){ if(first)first = false; else printf(&quot;\\n&quot;); for(int i = 0;i &lt; n;i++) printf(&quot;%d to %d\\n&quot;,vec\[n\]\[i\].first,vec\[n\]\[i\].second); } return 0; }]]></content>
      <categories>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 15th Zhejiang University Programming Contest 部分题解]]></title>
    <url>%2F2015%2F04%2F12%2F15th-zju%2F</url>
    <content type="text"><![CDATA[比赛链接: here 题目对应到ZOJ3860~3868 A ZOJ3860 Find the Spy 水题，不能多说。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* ***************Author :kuangbinCreated Time :2015/4/12 13:29:56File Name :F:\2015ACM\比赛练习\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int a[1100];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); int id; for(int i = 1;i &lt; n;i++) if(a[i] != a[i-1])&#123; id = i; break; &#125; for(int i = 0;i &lt; n;i++) if(i != id &amp;&amp; a[i] == a[id])&#123; id--; break; &#125; printf("%d\n",a[id]); &#125; return 0;&#125; B ZOJ3861 Valid Pattern Lock 水题，暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* ***************Author :kuangbinCreated Time :2015/4/12 13:34:31File Name :F:\2015ACM\比赛练习\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int a[10];bool vis[3][3];int n;bool check()&#123; memset(vis,false,sizeof(vis)); vis[(a[0]-1)/3][(a[0]-1)%3] = true; for(int i = 1;i &lt; n;i++)&#123; int px = (a[i-1]-1)/3; int py = (a[i-1]-1)%3; int nx = (a[i]-1)/3; int ny = (a[i]-1)%3; if(vis[nx][ny])return false; if(px == nx)&#123; if(py+ny == 2 &amp;&amp; !vis[px][1])return false; &#125; if(py == ny)&#123; if(px+nx == 2 &amp;&amp; !vis[1][ny])return false; &#125; if(!vis[1][1])&#123; if(px == 0 &amp;&amp; py == 2 &amp;&amp; nx == 2 &amp;&amp; ny == 0)return false; if(nx == 0 &amp;&amp; ny == 2 &amp;&amp; px == 2 &amp;&amp; py == 0)return false; if(px == 0 &amp;&amp; py == 0 &amp;&amp; nx == 2 &amp;&amp; ny == 2)return false; if(nx == 0 &amp;&amp; ny == 0 &amp;&amp; px == 2 &amp;&amp; py == 2)return false; &#125; vis[nx][ny] = true; &#125; return true;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); int ans = 0; sort(a,a+n); do&#123; if(check())&#123; ans++; &#125; &#125; while(next_permutation(a,a+n)); printf("%d\n",ans); sort(a,a+n); do&#123; if(check())&#123; for(int i = 0;i &lt; n;i++)&#123; printf("%d",a[i]); if(i &lt; n-1)printf(" "); else printf("\n"); &#125; &#125; &#125; while(next_permutation(a,a+n)); &#125; return 0;&#125; C ZOJ3862 Intersection 简单题。 就是给了n对点，有n对边，要最多交换n+10次，让两两之间没有交点。 其实题目骗了你，最多交换n次就可以达到要求的。 首先你先构造出一种连边方案，使得两两间没有交点。 我的构造方法是把点按照x从小到大排序，再按照y从小到大排序。 最后两两相邻的连边就是没有交点的了。 最后其实就是要交换一下编号，使得和原来的一样。最多n次交换完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/* ***************Author :kuangbinCreated Time :2015/4/12 16:22:59File Name :F:\2015ACM\比赛练习\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;struct Point&#123; int x,y; int index; bool operator &lt;(const Point &amp;b)const&#123; if(x != b.x)return x &lt; b.x; else return y &lt; b.y; &#125; void input(int ii)&#123; scanf("%d%d",&amp;x,&amp;y); index = ii; &#125;&#125;p[200010];int a[200010],b[200010];int id[200010];int fid[200010];pair&lt;int,int&gt;pp[200010];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= 2*n;i++)&#123; p[i].input(i); &#125; sort(p+1,p+2*n+1); for(int i = 1;i &lt;= 2*n;i += 2)&#123; a[p[i].index] = p[i+1].index; a[p[i+1].index] = p[i].index; &#125; for(int i = 1;i &lt;= 2*n;i++)&#123; id[i] = i; fid[i] = i; &#125; int u,v; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); b[u] = v; b[v] = u; &#125; int cnt = 0; for(int i = 1;i &lt;= 2*n;i++) if(id[a[i]] != b[id[i]])&#123; pp[cnt++] = make_pair(b[id[i]],id[a[i]]); int tmp = b[id[i]]; id[fid[b[id[i]]]] = id[a[i]]; fid[id[a[i]]] = fid[b[id[i]]]; id[a[i]] = tmp; fid[tmp] = a[i]; &#125; printf("%d\n",cnt); for(int i = 0;i &lt; cnt;i++) printf("%d %d\n",pp[i].first,pp[i].second); &#125; return 0;&#125; D ZOJ3863 Paths on the Tree 留个坑！！！！待填。 E ZOJ3864 Quiz for EXO-L 要把图案识别出来。 进行八邻域的bfs。 搞出黑和白的连通块。 然后发现只有样例的两个连通块个数是一样的。 特判下就好。 可以采用大黑块和小黑块比例去区别。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int g[1010][1010];bool vis[1010][1010];int Move[][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;&#125;;int n;int bfs(int x,int y)&#123; queue&lt;pair&lt;int,int&gt; &gt;q; q.push(make_pair(x,y)); vis[x][y] = true; int cnt = 0; while(!q.empty())&#123; pair&lt;int,int&gt;tmp = q.front(); cnt++; q.pop(); int tx = tmp.first; int ty = tmp.second; for(int i = 0;i &lt; 8;i++)&#123; int nx = tx+Move[i][0]; int ny = ty+Move[i][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n)continue; if(g[nx][ny] != g[x][y])continue; if(vis[nx][ny])continue; vis[nx][ny] = true; q.push(make_pair(nx,ny)); &#125; &#125; return cnt;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); srand(time(NULL)); int m; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); int x = 1, y = 1; int t; for(int i = 0;i &lt; m;i++)&#123; scanf("%d",&amp;t); while(t--)&#123; g[x][y] = (i%2 == 0); y++; if(y == n+1)&#123; x++; y = 1; &#125; &#125; &#125; n += 2; for(int i = 0;i &lt; n;i++)&#123; g[i][0] = 1; g[0][i] = 1; g[n-1][i] = 1; g[i][n-1] = 1; &#125; int c1 = 0, c2 = 0; memset(vis,false,sizeof(vis)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(!vis[i][j])&#123; bfs(i,j); if(g[i][j])c1++; else c2++; &#125; //printf("%d %d\n",c1,c2); if(c1== 2 &amp;&amp; c2 == 9)printf("Baekhyun\n"); else if(c1 == 1 &amp;&amp; c2 == 5)printf("Chanyeol\n"); else if(c1 == 3 &amp;&amp; c2 == 1)printf("Chen\n"); else if(c1 == 2 &amp;&amp; c2 == 1)printf("D.O\n"); else if(c1 &gt;= 10)printf("Kai\n"); else if(c1 == 1 &amp;&amp; c2 == 3 )printf("Kris\n"); else if(c1 == 2 &amp;&amp; c2 == 6)printf("Lay\n"); else if(c1 == 8 &amp;&amp; c2 == 5)printf("Luhan\n"); //else if(c1 == 2 &amp;&amp; c2 == 5)printf("Sehun\n"); else if(c1 == 8 &amp;&amp; c2 == 2)printf("Suho\n"); else if(c1 == 4 &amp;&amp; c2 == 2)printf("Tao\n"); else if(c1 == 2 &amp;&amp; c2 == 5)&#123; memset(vis,false,sizeof(vis)); int a[10]; int cc = 0; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(!vis[i][j] &amp;&amp; g[i][j] == 0)&#123; a[cc++] = bfs(i,j); &#125; sort(a,a+cc); if(1.0*a[cc-1]/a[0] &lt; 20)printf("Xiumin\n"); else printf("Sehun\n"); &#125; else while(1); &#125; return 0;&#125; F ZOJ3865 Superbot 简单搜索。 状态就是当前位置，已经光标的位置。 水题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/* ***************Author :kuangbinCreated Time :2015/4/12 14:27:47File Name :F:\2015ACM\比赛练习\F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int Move[][2] = &#123; &#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;;int dp[20][20][4];char g[20][20];int ex,ey;int n,m,P;bool can(int x,int y)&#123; if(x &lt; 0 || x &gt;= n)return false; if(y &lt; 0 || y &gt;= m)return false; if(g[x][y] == '*')return false; return true;&#125;struct Node&#123; int x,y; int dir; Node(int _x = 0,int _y = 0,int _dir = 0)&#123; x = _x; y = _y; dir = _dir; &#125;&#125;;int bfs(int sx,int sy)&#123; memset(dp,-1,sizeof(dp)); queue&lt;Node&gt;q; q.push(Node(sx,sy,0)); dp[sx][sy][0] = 0; while(!q.empty())&#123; Node tmp = q.front(); q.pop(); int x = tmp.x; int y = tmp.y; int dir = tmp.dir; //printf("%d %d %d %d\n",x,y,dir,dp[x][y][dir]); if(x == ex &amp;&amp; y == ey)return dp[x][y][dir]; int nx,ny,nd; nx = x; ny = y; nd = dir; if(dp\[x\]\[y\]\[dir\] &gt;= 0 &amp;&amp; dp\[x\]\[y\]\[dir\]%P == P-1)&#123; nd = (nd+3)%4; &#125; if(dp\[nx\]\[ny\]\[nd\] == -1)&#123; dp\[nx\]\[ny\]\[nd\] = dp\[x\]\[y\]\[dir\]+1; q.push(Node(nx,ny,nd)); &#125; nx = x+Move\[dir\]\[0\]; ny = y+Move\[dir\]\[1\]; nd = dir; if(can(nx,ny))&#123; if(dp\[x\]\[y\]\[dir\] &gt;= 0 &amp;&amp; dp\[x\]\[y\]\[dir\]%P == P-1) nd = (nd+3)%4; if(dp\[nx\]\[ny\]\[nd\] == -1)&#123; dp\[nx\]\[ny\]\[nd\] = dp\[x\]\[y\]\[dir\]+1; q.push(Node(nx,ny,nd)); &#125; &#125; nx = x; ny = y; nd = (dir+3)%4; if(dp\[x\]\[y\]\[dir\] &gt;= 0 &amp;&amp; dp\[x\]\[y\]\[dir\]%P == P-1)&#123; nd = (nd+3)%4; &#125; if(dp\[nx\]\[ny\]\[nd\] == -1)&#123; dp\[nx\]\[ny\]\[nd\] = dp\[x\]\[y\]\[dir\]+1; q.push(Node(nx,ny,nd)); &#125; nx = x; ny = y; nd = (dir+1)%4; if(dp\[x\]\[y\]\[dir\] &gt;= 0 &amp;&amp; dp\[x\]\[y\]\[dir\]%P == P-1)&#123; nd = (nd+3)%4; &#125; if(dp\[nx\]\[ny\]\[nd\] == -1)&#123; dp\[nx\]\[ny\]\[nd\] = dp\[x\]\[y\]\[dir\]+1; q.push(Node(nx,ny,nd)); &#125; &#125; return -1;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;P); for(int i = 0;i &lt; n;i++) scanf("%s",g\[i\]); int sx,sy; for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; m;j++)&#123; if(g\[i\]\[j\] == '@')&#123; sx = i; sy = j; &#125; if(g\[i\]\[j\] == '$')&#123; ex = i; ey = j; &#125; &#125; &#125; int ans = bfs(sx,sy); if(ans == -1)printf("YouBadbad\\n"); else printf("%d\\n",ans); &#125; return 0;&#125; G ZOJ3866 Cylinder Candy 数学题，推公式。 积分算表面积和体积。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* ***************Author :kuangbinCreated Time :2015/4/12 16:12:16File Name :F:\2015ACM\比赛练习\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double PI = acos(-1.0);int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; double r,h,d; scanf("%d",&amp;T); while(T--)&#123; scanf("%lf%lf%lf",&amp;r,&amp;h,&amp;d); double s = 2*d*r*PI*PI + 2*(r*r+r*h+d*h+2*d*d)*PI; double v = ((6*d*(d*d+r*r)-2*d*d*d)*PI+3*r*d*d*PI*PI)/3 + (r+d)*(r+d)*h*PI; printf("%.10lf %.10lf\n",v,s); &#125; return 0;&#125; H ZOJ3867 Earthstone: Easy Version 水题，不能多说。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* ***************Author :kuangbinCreated Time :2015/4/12 13:58:09File Name :F:\2015ACM\比赛练习\H.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int a,b,c,d; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if(a == 0)&#123; printf("Invalid\n"); continue; &#125; b -= c; d -= a; if(b &gt; 0)printf("%d %d ",a,b); else printf("Discard "); if(d &gt; 0)printf("%d %d\n",c,d); else printf("Discard\n"); &#125; return 0;&#125; I ZOJ3868 GCD Expectation 一眼题。 暴力统计。 比如用dp[i] 表示gcd为i的子集个数。 那么如果i的倍数有x个， 那么gcd为 i的倍数的子集个数就是 2^x - 1。 要算gcd恰好为i的，那么就减掉就好。 dp[i] = 2^x - 1; for(int j = i+i;j &lt;= Max;j += i) dp[i] -= dp[j]; 倒过来求dp[i]就好。 复杂度就是调和级数的复杂度nln n. 简单题啊。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* ***************Author :kuangbinCreated Time :2015/4/12 14:12:03File Name :F:\2015ACM\比赛练习\I.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 998244353;const int MAXN = 1000010;int a[MAXN];int b[MAXN];long long pow_m(long long a,long long n)&#123; long long ret = 1; long long tmp = a; while(n)&#123; if(n&amp;1)ret = ret*tmp%MOD; tmp = tmp*tmp%MOD; n &gt;&gt;= 1; &#125; return ret;&#125;long long dp[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; memset(b,0,sizeof(b)); scanf("%d",&amp;T); int k; int n; while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); int Max = 0; for(int i = 0;i &lt; n;i++)&#123; scanf("%d",&amp;a[i]); b[a[i]]++; Max = max(a[i],Max); &#125; long long ans = 0; for(int i = Max;i &gt;= 1;i--)&#123; dp[i] = 0; int cc = 0; for(int j = i;j &lt;= Max;j+= i)&#123; cc += b[j]; if(j &gt; i)dp[i] = (dp[i]-dp[j]+MOD)%MOD; &#125; dp[i] = (dp[i] + pow_m(2,cc) - 1 + MOD)%MOD; ans += dp[i]*pow_m(i,k)%MOD; ans %= MOD; &#125; for(int i = 0;i &lt; n;i++) b[a[i]]--; printf("%d\n",(int)ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Online Judge</category>
        <category>套题</category>
        <category>ZJU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BestCoder Round #36 （HDU5198 HDU5199 HDU5200 HDU5201）]]></title>
    <url>%2F2015%2F04%2F06%2Fbc36%2F</url>
    <content type="text"><![CDATA[水题四发。 HDU5201 m个猴子要分n个桃子。要使得第一个猴子分到的是最多的。 也就是求\(x_1+x_2+\cdots+x_m=n\),而且满足\(x_1&gt;x_2,x_1&gt;x_3,\cdots,x_1&gt;x_m\)有多少个非负整数解。 做法是枚举+容斥。 枚举假如第一个猴子分到x个。那就是要在后面m-1个猴子里面分n-x个桃子，而且每个猴子分到的要小于x。 这是个经典的容斥问题。 具体推导不细说了，写写公式就出来了。就是要求0个大于等于x的分法有多少种。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* ***************Author :kuangbinCreated Time :2015/4/6 14:34:46File Name :E:\2014ACM\Bestcoder\BC36\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;long long inv(long long a,long long m)&#123; if(a == 1)return 1; return inv(m%a,m)*(m-m/a)%m;&#125;const int MAXN = 200010;int f[MAXN],rf[MAXN];long long C(int n,int m)&#123; return (long long)f[n]*rf[m]%MOD*rf[n-m]%MOD;&#125;long long calc(int x,int n,int m)&#123; if(m == 0)return 1; if(n == 0)return 0; long long ans = 0; for(int i = 0;i*x &lt;= m &amp;&amp; i &lt;= n;i++)&#123; long long tmp = C(n,i)*C(m-i*x + n-1,n-1)%MOD; if(i%2 == 0)ans = (ans+tmp)%MOD; else ans = (ans-tmp+MOD)%MOD; &#125; return ans;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); f[0] = 1; for(int i = 1;i &lt;= 200000;i++)f[i] = (long long)f[i-1]*i%MOD; rf[200000] = inv(f[200000],MOD); for(int i = 200000;i &gt;= 1;i--)rf[i-1] = (long long)rf[i]*i%MOD; int T; int n,m; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); int ans = 0; for(int i = 1;i &lt;= n;i++)&#123; ans = (ans+calc(i,m-1,n-i))%MOD; &#125; printf("%d\n",ans); &#125; return 0;&#125; [HDU5200](http://acm.hdu.edu.cn/showproblem.php?pid=5200) 离线乱搞。从大到小离线，树从大到小加入。 如果加入的两边为空，块加1，如果两边都不为空，块减一。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* ***************Author :kuangbinCreated Time :2015/4/6 15:59:08File Name :E:\2014ACM\Bestcoder\BC36\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;struct Node&#123; int x,index; bool operator &lt;(const Node &amp;b)const&#123; return x &gt; b.x; &#125;&#125;node[MAXN];int a[MAXN];int b[MAXN];bool cmp(int i,int j)&#123; return a[i] &gt; a[j];&#125;int ans[MAXN];bool vis[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,q; while(scanf("%d%d",&amp;n,&amp;q) == 2)&#123; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d",&amp;a[i]); b[i] = i; &#125; sort(b+1,b+n+1,cmp); for(int i = 0;i &lt; q;i++)&#123; scanf("%d",&amp;node[i].x); node[i].index = i; &#125; sort(node,node+q); int cnt = 0; memset(vis,false,sizeof(vis)); int j = 1; for(int i = 0;i &lt; q;i++)&#123; while(j &lt;= n &amp;&amp; a[b[j]] &gt; node[i].x)&#123; if(!vis[b[j]-1] &amp;&amp; !vis[b[j]+1])cnt++; else if(vis[b[j]-1] &amp;&amp; vis[b[j]+1])cnt--; vis[b[j]] = true; j++; &#125; ans[node[i].index] = cnt; &#125; for(int i = 0;i &lt; q;i++) printf("%d\n",ans[i]); &#125; return 0;&#125; HDU5199 开了个map随手乱搞就过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* ***************Author :kuangbinCreated Time :2015/4/6 16:26:59File Name :E:\2014ACM\Bestcoder\BC36\B.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;//适用于正负整数template &lt;class T&gt;inline bool scan_d(T &amp;ret) &#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar(); sgn=(c=='-')?-1:1; ret=(c=='-')?0:(c-'0'); while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9') ret=ret*10+(c-'0'); ret*=sgn; return 1;&#125;inline void out(int x) &#123; if(x&gt;9) out(x/10); putchar(x%10+'0');&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m; while(scanf("%d%d",&amp;n,&amp;m) == 2)&#123; map&lt;int,int&gt;mp; int a; while(n--)&#123; scan_d(a); mp[a]++; &#125; while(m--)&#123; scan_d(a); if(mp.count(a))&#123; printf("%d\n",mp[a]); mp[a] = 0; &#125; else printf("0\n"); &#125; &#125; return 0;&#125; HDU5198 水题，不能多说。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* ***************Author :kuangbinCreated Time :2015/4/6 16:34:50File Name :E:\2014ACM\Bestcoder\BC36\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;char str[1000];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%s",str) == 1)&#123; int n = strlen(str); if(n%3)&#123; printf("NO\n"); continue; &#125; bool flag = true; for(int i = 1;i &lt; n/3;i++) if(str[i] != str[i-1]) flag = false; for(int i = n/3+1;i &lt; n/3*2;i++) if(str[i] != str[i-1]) flag = false; for(int i = n/3*2+1;i &lt; n;i++) if(str[i] != str[i-1]) flag = false; if(str[0] == str[n/3] || str[n/3] == str[n/3*2] || str[0] == str[n/3*2]) flag = false; if(flag)printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2002-2003 ACM-ICPC Northeastern European Regional Contest (NEERC 02)]]></title>
    <url>%2F2015%2F02%2F28%2F2002neerc%2F</url>
    <content type="text"><![CDATA[做了几套题，先来总结一套题。 NEERC2002 题目链接：http://codeforces.com/gym/100002 A 题意：N个数，按照字典序进行排列。Q(N,K)表示数K的位置。 现在给出K,M。 求最小的N，使得 Q(N,K)=M. 不存在输出0. 很明显进行二分答案。然后求Q(N,K) 和 M去比较。 我是用了数位DP的方法去算的Q(N,K)。也可以直接去求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* ***************Author :kuangbinCreated Time :2015/2/26 22:05:49File Name :E:\2015ACM\比赛练习\GYM\NEERC02\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;long long dp[100][100];int bit1[100];int bit2[100];int cnt1,cnt2;long long dfs(int tot,int pos,int cnt2,bool f1,bool f2)&#123; if(pos &gt;= tot)return 1; if(pos &gt;= cnt2 &amp;&amp; f2)return tot==cnt2; if(!f1 &amp;&amp; !f2 &amp;&amp; dp[tot][pos] != -1)return dp[tot][pos]; int end = 9; if(f1)end = min(end,bit1[tot-1-pos]); if(f2)end = min(end,bit2[cnt2-1-pos]); long long ans = 0; for(int i = 0;i &lt;= end;i++)&#123; if(pos == 0 &amp;&amp; i == 0)continue; ans += dfs(tot,pos+1,cnt2,f1 &amp;&amp; i == bit1[tot-1-pos],f2 &amp;&amp; i == bit2[cnt2-1-pos]); &#125; if(!f1 &amp;&amp; !f2)dp[tot][pos] = ans; return ans;&#125;long long calc(long long n,long long K)&#123; cnt1 = 0; while(n)&#123; bit1[cnt1++] = n%10; n /= 10; &#125; cnt2 = 0; while(K)&#123; bit2[cnt2++] = K%10; K /= 10; &#125; long long ans = 0; for(int i = 1;i &lt;= cnt1;i++) ans += dfs(i,0,cnt2,i==cnt1,1); return ans;&#125;int main()&#123; freopen("amusing.in","r",stdin); freopen("amusing.out","w",stdout); int K,M; while(scanf("%d%d",&amp;K,&amp;M) == 2)&#123; memset(dp,-1,sizeof(dp)); long long ans = 0; long long l = K; long long r = 1000000000000000000LL; while(l &lt;= r)&#123; long long mid = (l+r)/2; long long tmp = calc(mid,K); if(tmp == M)ans = mid; if(tmp &gt;= M)r = mid-1; else l = mid+1; &#125; printf("%I64d\n",ans); &#125; return 0;&#125; B： 题意：一个A*B*C的长方体。有一个D*E的口，深度无穷大的洞。 问这个长方体能不能放进洞里面。 其实很容易去发现放的最优方案肯定是直着放下去的。因为倾斜会导致增大。 所以取出最小的两条边。然后转化为二维的判断。就是A*B的矩形能不能放在D*E的矩形里面。 我的做法是让他们中心对齐，然后进行旋转放进去。 简单粗暴做法是枚举转的角度。然后乱搞判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* ***************Author :kuangbinCreated Time :2015/2/27 12:29:16File Name :E:\2015ACM\比赛练习\GYM\NEERC02\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double eps = 1e-8;const double pi = acos(-1.0);inline double sqr(double x)&#123; return x*x;&#125;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;bool check(double a,double b,double d,double e)&#123; if(sgn(a-d) &lt;= 0 &amp;&amp; sgn(b-e) &lt;= 0)return true; double r = sqrt(sqr(a/2)+sqr(b/2)); double tr = sqrt(sqr(d/2)+sqr(e/2)); if(sgn(r-tr) &gt; 0)return false; double st; if(sgn(r-d/2) &lt;= 0)st = 0; else st = acos(d/2/r); double ed; if(sgn(r-e/2) &lt;= 0)ed = pi/2; else ed = pi/2-acos(e/2/r); double jiao = 2*atan(a/b); double s1 = st+jiao; double e1 = ed+jiao; double s2 = pi-ed; double e2 = pi-st; if((sgn(s1-e2) &gt; 0 || sgn(s2-e1) &gt; 0) &amp;&amp; (sgn(s1-ed) &gt; 0 || sgn(st-e1) &gt; 0))return false; else return true;&#125;int main()&#123; freopen("bricks.in","r",stdin); freopen("bricks.out","w",stdout); double a,b,c,d,e; while(scanf("%lf%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e) == 5)&#123; if(a &gt; b)swap(a,b); if(a &gt; c)swap(a,c); if(b &gt; c)swap(b,c); if(d &gt; e)swap(d,e); if(check(a,b,d,e))printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; C： 题意：在W*H的格点中，有一些格点有树。要找一个最大的正方形，不包含树。 点比较少，可以进行离散化，得到一些关键的x坐标和y坐标。 然后枚举每个点作为左下角， 然后枚举每个点就可以了。 水题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/* ***************Author :kuangbinCreated Time :2015/2/26 20:04:17File Name :E:\2015ACM\比赛练习\GYM\NEERC02\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int N,W,H;pair&lt;int,int&gt;p[110];int x[110],y[110];bool check(int x0,int y0,int L)&#123; for(int i = 0;i &lt; N;i++) if(p[i].first &gt; x0 &amp;&amp; p[i].first &lt; x0+L &amp;&amp; p[i].second &gt; y0 &amp;&amp; p[i].second &lt; y0+L) return false; return true;&#125;int main()&#123; freopen("cricket.in","r",stdin); freopen("cricket.out","w",stdout); while(scanf("%d%d%d",&amp;N,&amp;W,&amp;H) == 3)&#123; int cnt1 = 0, cnt2 = 0; for(int i = 0;i &lt; N;i++)&#123; scanf("%d%d",&amp;p[i].first,&amp;p[i].second); x[cnt1++] = p[i].first; y[cnt2++] = p[i].second; &#125; x[cnt1++] = 0; x[cnt1++] = W; y[cnt2++] = 0; y[cnt2++] = H; sort(x,x+cnt1); sort(y,y+cnt2); cnt1 = unique(x,x+cnt1)-x; cnt2 = unique(y,y+cnt2)-y; int ansx,ansy; int L = 0; for(int i = 0;i &lt; cnt1;i++) for(int j = 0;j &lt; cnt2;j++)&#123; int x0 = x[i]; int y0 = y[j]; int l = 0; int r = min(W-x0,H-y0); int ans = 0; while(l &lt;= r)&#123; int mid = (l+r)/2; if(check(x0,y0,mid))&#123; ans = mid; l = mid+1; &#125; else r = mid-1; &#125; if(ans &gt; L)&#123; ansx = x0; ansy = y0; L = ans; &#125; &#125; printf("%d %d %d\n",ansx,ansy,L); &#125; return 0;&#125; D： 题意很长。就是进行了异或编码。然后前面加了一个32，要求密匙。 直接搞就是了。阅读理解题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* ***************Author :kuangbinCreated Time :2015/2/26 19:44:14File Name :E:\2015ACM\比赛练习\GYM\NEERC02\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 20010;char str1[MAXN],str2[MAXN];int a[MAXN];int b[MAXN];int c[MAXN];int get(char ch)&#123; if(ch &gt;= '0' &amp;&amp; ch &lt;= '9')return ch-'0'; else return ch-'A'+10;&#125;int main()&#123; freopen("decode.in","r",stdin); freopen("decode.out","w",stdout); while(scanf("%s%s",str1,str2) == 2)&#123; int n = strlen(str1); n /= 2; for(int i = 0;i &lt; n;i++) a[i] = 16*get(str1[2*i])+get(str1[2*i+1]); for(int i = 0;i &lt;= n;i++) b[i] = 16*get(str2[2*i])+get(str2[2*i+1]); c[0] = 32^b[0]; for(int i = 1;i &lt;= n;i++) c[i] = c[i-1]^a[i-1]^b[i]; for(int i = 0;i &lt;= n;i++)&#123; printf("%X%X",c[i]/16,c[i]%16); &#125; printf("\n"); &#125; return 0;&#125; E： 题意：题意很长。其实就是一个最小费用最大流的模型。 然后给了一组方案，问是不是最优方案，如果不是，给我一组更优的方案就可以了。 这题我是直接粗暴地用最小费用最大流去搞，得到的最小费用和给出方案的最小费用进行比较。 其实可以直接在残留网络里面找一个负环，然后负环上面都+1就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291/* ***************Author :kuangbinCreated Time :2015/2/27 14:46:37File Name :E:\2015ACM\比赛练习\GYM\NEERC02\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 220;const int MAXM = 22000;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow,cost; Edge(int _to = 0,int _next = 0,int _cap = 0,int _flow = 0,int _cost = 0): to(_to),next(_next),cap(_cap),flow(_flow),cost(_cost)&#123;&#125;&#125;edge[MAXM];struct ZKW_MinCostMaxFlow&#123; int head[MAXN],tot; int cur[MAXN]; int dis[MAXN]; bool vis[MAXN]; int ss,tt,N; int min_cost,max_flow; void init()&#123; tot = 0; memset(head,-1,sizeof(head)); &#125; void addedge(int u,int v,int cap,int cost)&#123; edge[tot] = Edge(v,head[u],cap,0,cost); head[u] = tot++; edge[tot] = Edge(u,head[v],0,0,-cost); head[v] = tot++; &#125; int aug(int u,int flow)&#123; if(u == tt)return flow; vis[u] = true; for(int i = cur[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; !vis[v] &amp;&amp; dis[u] == dis[v]+edge[i].cost)&#123; int tmp = aug(v,min(flow,edge[i].cap-edge[i].flow)); edge[i].flow += tmp; edge[i^1].flow -= tmp; cur[u] = i; if(tmp)return tmp; &#125; &#125; return 0; &#125; bool modify_label()&#123; int d = INF; for(int u = 0;u &lt; N;u++) if(vis[u]) for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; !vis[v]) d = min(d,dis[v]+edge[i].cost-dis[u]); &#125; if(d == INF)return false; for(int i = 0;i &lt; N;i++) if(vis[i])&#123; vis[i] = false; dis[i] += d; &#125; return true; &#125; pair&lt;int,int&gt; mincostmaxflow(int start,int end,int n)&#123; ss = start, tt = end, N = n; min_cost = max_flow = 0; for(int i = 0;i &lt; n;i++)dis[i] = 0; while(1)&#123; for(int i = 0;i &lt; n;i++)cur[i] = head[i]; while(1)&#123; for(int i = 0;i &lt; n;i++)vis[i] = false; int tmp = aug(ss,INF); if(tmp == 0)break; max_flow += tmp; min_cost += tmp*dis[ss]; &#125; if(!modify_label())break; &#125; return make_pair(min_cost,max_flow); &#125;&#125;solve;struct Node&#123; int x,y; int num; void input()&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;num); &#125; int distance(Node b)&#123; return abs(x-b.x)+abs(y-b.y)+1; &#125;&#125;node1[MAXN],node2[MAXN];int a[MAXN][MAXN];int id[MAXN][MAXN];int main()&#123; freopen("evacuate.in","r",stdin); freopen("evacuate.out","w",stdout); int n,m; while(scanf("%d%d",&amp;n,&amp;m) == 2)&#123; solve.init(); for(int i = 1;i &lt;= n;i++)&#123; node1[i].input(); solve.addedge(0,i,node1[i].num,0); &#125; for(int i = 1;i &lt;= m;i++)&#123; node2[i].input(); solve.addedge(n+i,n+m+1,node2[i].num,0); &#125; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++)&#123; id[i][j] = solve.tot; solve.addedge(i,n+j,INF,node1[i].distance(node2[j])); &#125; int tmp = 0; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++)&#123; scanf("%d",&amp;a[i][j]); tmp += a[i][j]*node1[i].distance(node2[j]); &#125; pair&lt;int,int&gt;pp = solve.mincostmaxflow(0,n+m+1,n+m+2); if(pp.first == tmp)printf("OPTIMAL\n"); else &#123; printf("SUBOPTIMAL\n"); for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; printf("%d",edge[id[i][j]].flow); if(j &lt; m)printf(" "); else printf("\n"); &#125; &#125; &#125; &#125; return 0;&#125; F： 题意：给了一个字符串。要把字符串进行压缩。 长度不超过100，直接进行区间DP求解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* ***************Author :kuangbinCreated Time :2015/2/26 20:29:05File Name :E:\2015ACM\比赛练习\GYM\NEERC02\F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 110;string ss[MAXN][MAXN];char str[MAXN];void kmp_pre(char x[],int m,int next[])&#123; int i,j; j = next[0] = -1; i = 0; while(i &lt; m)&#123; while(-1 != j &amp;&amp; x[i] != x[j])j = next[j]; next[++i] = ++j; &#125;&#125;int next[MAXN];char str2[MAXN];string num2str(int n)&#123; string ret = ""; while(n)&#123; ret = (char)('0'+n%10)+ret; n /= 10; &#125; return ret;&#125;int main()&#123; freopen("folding.in","r",stdin); freopen("folding.out","w",stdout); while(scanf("%s",str) == 1)&#123; int n = strlen(str); for(int i = 0;i &lt; n;i++)&#123; ss[i][i] = string("") + str[i]; &#125; for(int i = n-1;i &gt;= 0;i--)&#123; for(int j = i+1;j &lt; n;j++)&#123; ss[i][j] = ""; int cnt = 0; for(int k = i;k &lt;= j;k++)&#123; ss[i][j] += str[k]; str2[cnt++] = str[k]; &#125; int len = j-i+1; kmp_pre(str2,len,next); if(next[len] &gt; 0 &amp;&amp; len%(len-next[len]) == 0)&#123; string tmp = ""; tmp += num2str(len/(len-next[len])); tmp += '('; tmp += ss[i][i+len-next[len]-1]; tmp += ')'; if(tmp.length() &lt; ss[i][j].length()) ss[i][j] = tmp; &#125; for(int k = i;k &lt; j;k++)&#123; string tmp = ss[i][k]+ss[k+1][j]; if(tmp.length() &lt; ss[i][j].length()) ss[i][j] = tmp; &#125; &#125; &#125; cout&lt;&lt;ss[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; G： 题意：三维空间里面，有一些球。这些球都在x&gt;= 0,y&gt;=0,z &gt;=0 里面的。要求原点发射一个射线。最最多可以碰到多少个球。接触到一点就算碰到。 很明显，只需要去判断一些关键的射线。一个是射向每个球球心的射线。还有就是射向两个求交点的射线。 求两个交点时候，推了下向量的公式。 比较好的三维计算几何题目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/* ***************Author :kuangbinCreated Time :2015/2/28 0:00:57File Name :E:\2015ACM\比赛练习\GYM\NEERC02\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double eps = 1e-8;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct Point3&#123; double x,y,z; Point3(double _x = 0,double _y = 0,double _z = 0)&#123; x = _x; y = _y; z = _z; &#125; double len()&#123; return sqrt(x*x+y*y+z*z); &#125; Point3 operator -(const Point3 &amp;b)const&#123; return Point3(x-b.x,y-b.y,z-b.z); &#125; Point3 operator +(const Point3 &amp;b)const&#123; return Point3(x+b.x,y+b.y,z+b.z); &#125; Point3 operator *(const double &amp;k)const&#123; return Point3(x*k,y*k,z*k); &#125; double operator *(const Point3 &amp;b)const&#123; return x*b.x+y*b.y+z*b.z; &#125; Point3 operator ^(const Point3 &amp;b)const&#123; return Point3(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x); &#125; Point3 trunc(double r)&#123; double l = len(); if(!sgn(l))return *this; r /= l; return Point3(x*r,y*r,z*r); &#125;&#125;;struct Node&#123; Point3 p; double cosV;&#125;node[110];int n;vector&lt;int&gt;ans;void check(Point3 p0)&#123; vector&lt;int&gt;tmp; tmp.clear(); for(int i = 0;i &lt; n;i++)&#123; double tt = p0*node[i].p; if(sgn(tt-node[i].cosV) &gt;= 0) tmp.push_back(i+1); &#125; if(tmp.size() &gt; ans.size()) ans = tmp;&#125;void check(int i,int j)&#123; double cos1 = node[i].p*node[j].p; if(sgn(cos1-1) == 0)return; double sin1 = sqrt(1-cos1*cos1); double c0 = (node[i].cosV-node[j].cosV*cos1)/sin1/sin1; double c1 = (node[j].cosV-node[i].cosV*cos1)/sin1/sin1; Point3 cen = (node[i].p*c0)+(node[j].p*c1); Point3 vp = node[i].p^node[j].p; double vplen = 1-cen.len()*cen.len(); if(sgn(vplen) &gt;= 0)&#123; if(vplen &lt; 0)vplen = 0; vplen = sqrt(vplen); vp = vp.trunc(vplen); check(cen+vp); check(cen-vp); &#125;&#125;int main()&#123; freopen("ghosts.in","r",stdin); freopen("ghosts.out","w",stdout); while(scanf("%d",&amp;n) == 1)&#123; Point3 p0; double r; for(int i = 0;i &lt; n;i++)&#123; scanf("%lf%lf%lf",&amp;p0.x,&amp;p0.y,&amp;p0.z); scanf("%lf",&amp;r); double d = p0.len(); node[i].cosV = sqrt(d*d-r*r)/d; node[i].p = p0.trunc(1); &#125; ans.clear(); for(int i = 0;i &lt; n;i++) check(node[i].p); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; i;j++) check(i,j); int sz = ans.size(); printf("%d\n",sz); for(int i = 0;i &lt; sz;i++)&#123; printf("%d",ans[i]); if(i &lt; sz-1)printf(" "); else printf("\n"); &#125; &#125; return 0;&#125; H： 直接进行DP。 写了个记忆化。记录路径，很简单。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/* ***************Author :kuangbinCreated Time :2015/2/28 1:11:39File Name :E:\2015ACM\比赛练习\GYM\NEERC02\H.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int n;int HPH,MPH,HPM,NM,V,dH;int L[20];int dp[12][110][55][110];int pre[12][110][55][110];int solve(int now,int hph,int mph,int val)&#123; if(dp[now][hph][mph][val] != -1) return dp[now][hph][mph][val]; if(mph == 0)return dp[now][hph][mph][val] = 0; int _now,_hph,_mph,_val; _now = now; _hph = hph; _mph = mph-1; _val = val-L[now]; if(_val &lt;= 0)&#123; pre[now][hph][mph][val] = -1; return dp[now][hph][mph][val] = 1; &#125; \_now -= min(_now-1,V); if(_now == 1)&#123; \_hph -= (_val+HPM-1)/HPM; &#125; if(_hph &gt; 0 &amp;&amp; solve(_now,_hph,_mph,_val))&#123; pre[now][hph][mph][val] = -1; return dp[now][hph][mph][val] = 1; &#125; for(int i = 1;i &lt;= n;i++)&#123; _now = i; _hph = hph; _mph = mph-1; _val = val; \_now -= min(_now-1,V); if(_now == 1) \_hph -= (_val+HPM-1)/HPM; if(_hph &gt; 0 &amp;&amp; solve(_now,_hph,_mph,_val))&#123; pre[now][hph][mph][val] = i; return dp[now][hph][mph][val] = 1; &#125; &#125; _now = now; _hph = min(HPH,hph+dH); _mph = mph-1; _val = val; \_now -= min(_now-1,V); if(_now == 1) \_hph -= (_val+HPM-1)/HPM; if(_hph &gt; 0 &amp;&amp; solve(_now,_hph,_mph,_val))&#123; pre[now][hph][mph][val] = -2; return dp[now][hph][mph][val] = 1; &#125; return dp[now][hph][mph][val] = 0;&#125;int main()&#123; freopen("heroes.in","r",stdin); freopen("heroes.out","w",stdout); while(scanf("%d%d%d%d%d%d%d",&amp;n,&amp;HPH,&amp;MPH,&amp;HPM,&amp;NM,&amp;V,&amp;dH) == 7)&#123; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;L[i]); memset(dp,-1,sizeof(dp)); int now,hph,mph,val; now = n; hph = HPH; mph = MPH; val = HPM*NM; if(!solve(now,hph,mph,val))printf("DEFEATED\n"); else &#123; printf("VICTORIOUS\n"); while(1)&#123; if(pre[now][hph][mph][val] == -1)&#123; printf("L\n"); mph--; val -= L[now]; if(val &lt;= 0)break; now -= min(now-1,V); if(now == 1) hph -= (val+HPM-1)/HPM; &#125; else if(pre[now][hph][mph][val] &gt; 0)&#123; printf("T %d\n",pre[now][hph][mph][val]); now = pre[now][hph][mph][val]; mph--; now -= min(now-1,V); if(now == 1) hph -= (val+HPM-1)/HPM; &#125; else &#123; printf("H\n"); hph = min(HPH,hph+dH); mph--; now -= min(now-1,V); if(now == 1) hph -= (val+HPM-1)/HPM; &#125; &#125; &#125; &#125; return 0;&#125; I： 题意：就是网格上交了一些垂直或者水平的线，还有一些45度的线。问可以分割出多少个等腰直接三角形。 枚举每个直角，往外扩展去判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253/* ***************Author :kuangbinCreated Time :2015/2/28 10:36:29File Name :E:\2015ACM\比赛练习\GYM\NEERC02\I.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int n,m,k;bool horis[110][110];bool verts[110][110];bool dign1[110][110];bool dign2[110][110];bool hashoris[110];bool hasverts[110];bool hasdign1[220];bool hasdign2[220];bool inside(int x,int y)&#123; return x &gt;= 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= m;&#125;bool hasline(int x1,int y1,int x2,int y2)&#123; if(y1 == y2)return hashoris[y1]; if(x1 == x2)return hasverts[x1]; if(x1-y1 == x2-y2)return hasdign1[x1-y1+110]; if(x1+y1 == x2+y2)return hasdign2[x1+y1];&#125;//除了这个方向不能有其他线bool check(int x,int y,int dx,int dy)&#123; if(dy == 0)&#123; if(verts[x][y] || dign1[x][y] || dign2[x][y])return false; &#125; if(dx == 0)&#123; if(horis[x][y] || dign1[x][y] || dign2[x][y])return false; &#125; if(dx == dy)&#123; if(horis[x][y] || verts[x][y] || dign2[x][y])return false; &#125; if(dx == -dy)&#123; if(horis[x][y] || verts[x][y] || dign1[x][y])return false; &#125; return true;&#125;bool check(int x,int y,int dx1,int dy1,int dx2,int dy2)&#123; int x1 = x+dx1, y1 = y+dy1; int x2 = x+dx2, y2 = y+dy2; while(1)&#123; if(!inside(x1,y1) || !inside(x2,y2))return false; if(hasline(x1,y1,x2,y2))return true; if(!check(x1,y1,dx1,dy1) || !check(x2,y2,dx2,dy2))return false; x1 += dx1; y1 += dy1; x2 += dx2; y2 += dy2; &#125; return false;&#125;int main()&#123; freopen("inlay.in","r",stdin); freopen("inlay.out","w",stdout); while(scanf("%d%d%d",&amp;n,&amp;m,&amp;k) == 3)&#123; n *= 2; m *= 2; memset(hashoris,0,sizeof(hashoris)); memset(hasverts,0,sizeof(hasverts)); memset(hasdign1,0,sizeof(hasdign1)); memset(hasdign2,0,sizeof(hasdign2)); int x1,y1,x2,y2; for(int i = 0;i &lt; k;i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); x1 *= 2; y1 *= 2; x2 *= 2; y2 *= 2; if(y1 == y2)hashoris[y1] = true; if(x1 == x2)hasverts[x1] = true; if(x1-y1 == x2-y2)hasdign1[x1-y1+110] = true; if(x1+y1 == x2+y2)hasdign2[x1+y1] = true; &#125; hashoris[0] = true; hashoris[m] = true; hasverts[0] = true; hasverts[n] = true; for(int i = 0;i &lt;= n;i++) for(int j = 0;j &lt;= m;j++)&#123; horis[i][j] = hashoris[j]; verts[i][j] = hasverts[i]; dign1[i][j] = hasdign1[i-j+110]; dign2[i][j] = hasdign2[i+j]; &#125; int ans = 0; for(int i = 0;i &lt;= n;i++) for(int j = 0;j &lt;= m;j++)&#123; if(horis[i][j] &amp;&amp; verts[i][j])&#123; if(!dign1[i][j])&#123; ans += check(i,j,1,0,0,1); ans += check(i,j,-1,0,0,-1); &#125; if(!dign2[i][j])&#123; ans += check(i,j,-1,0,0,1); ans += check(i,j,1,0,0,-1); &#125; &#125; if(dign1[i][j] &amp;&amp; dign2[i][j])&#123; if(!horis[i][j])&#123; ans += check(i,j,1,1,1,-1); ans += check(i,j,-1,1,-1,-1); &#125; if(!verts[i][j])&#123; ans += check(i,j,1,1,-1,1); ans += check(i,j,1,-1,-1,-1); &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>套题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA 10766 - Organising the Organisation(生成树计数)]]></title>
    <url>%2F2015%2F01%2F27%2Fuva10766%2F</url>
    <content type="text"><![CDATA[UVA10766 生成树计数裸题！ 纯套模板了。 不会生成树计数可以去看看Matrix-Tree定理。 本题要用long double才能AC。 /* ***Author :kuangbinCreated Time :2015/1/27 22:43:02File Name :I.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const double eps = 1e-8;const int MAXN = 110;int sgn(long double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;}long double b[MAXN][MAXN];long double det(long double a[][MAXN],int n){ int i, j, k, sign = 0; long double ret = 1; for(i = 0;i &lt; n;i++) for(j = 0;j &lt; n;j++) b[i][j] = a[i][j]; for(i = 0;i &lt; n;i++){ if(sgn(b[i][i]) == 0){ for(j = i + 1; j &lt; n;j++) if(sgn(b[j][i]) != 0) break; if(j == n)return 0; for(k = i;k &lt; n;k++) swap(b[i][k],b[j][k]); sign++; } ret = b[i][i]; for(k = i + 1;k &lt; n;k++) b[i][k]/=b[i][i]; for(j = i+1;j &lt; n;j++) for(k = i+1;k &lt; n;k++) b[j][k] -= b[j][i]b[i][k]; } if(sign &amp; 1)ret = -ret; return ret;}long double a[MAXN][MAXN];int g[MAXN][MAXN];int main(){ int n,m; int u,v; int k; while(scanf(“%d%d%d”,&amp;n,&amp;m,&amp;k) == 3){ memset(g,0,sizeof(g)); while(m–){ scanf(“%d%d”,&amp;u,&amp;v); u–;v–; g[u][v] = g[v][u] = 1; } memset(a,0,sizeof(a)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(i != j &amp;&amp; g[i][j] == 0){ a[i][i]++; a[i][j] = -1; } double ans = det(a,n-1); printf(“%.0lf\n”,ans); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>UVA</category>
        <category>图论</category>
        <category>生成树计数</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>UVA</tag>
        <tag>生成树计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 191. Exhibition (模拟)]]></title>
    <url>%2F2015%2F01%2F25%2Fsgu191%2F</url>
    <content type="text"><![CDATA[SGU191 这题题意太难懂，读了好久都没有理解。 题意： 有两个公司A、B，他们要展览物品，但是A公司的展柜要放B公司的物品，B公司的展柜要放A公司物品。最开始只有一个空柜台，从指定的一个公司开始，轮流进行操作，可选的操作有两个：①选一个自己公司的空展柜放上对方公司的物品 ②选一个自己公司的空展柜，在这个展柜左边插入一个对方公司的空展柜，再在这个新插入的展柜左边插入一个空展柜并放上自己公司的物品。 题中给出了一个最终物品摆放的序列，问最后物品摆放的序列能否和给定序列相同。 直接模拟，因为一开始只有一个A或B的空柜台， 按照目标序列，如果需要的和现在的空柜台相反就是1操作，相同就是2操作。相应增加和减少空柜台。 用一个栈来保存目前的柜台。 191. Exhibitiontime limit per test: 0.25 sec. memory limit per test: 4096 KB input: standard input output: standard output Two companies “A” and “B” decided to hold a joint exhibition of their production. Antitrust committee decided to take an experiment. To have a possibility to show its own production each company must advertise the production of its competitor. The exhibition is built as a straight row of stands. Some stands can be empty, other contain the production of represented companies (each stand can contain the production of only one company). The empty stands are also signed with the names of the companies. Originally the exhibition consists of just one empty stand, which is signed by the name of one of the companies (by a lot). The company can choose any of its empty stands and either to fill it with the production of the competitor or to place the empty stand to the left, signed by the name of the competitor, and to the left of that place the stand with its own production. If there are any stands to the left, they are moved to the left. By the beginning of the exhibition all stands must be filled. Your task is to write a program in accordance with the filled stands before the exhibition to determine if the requirements of the antitrust committee were satisfied or not. Input The first line contains the name of the company (“A” or “B”), which was chosen to be the first to fill the empty stand. The second line contains a row of the stands presented to the antitrust committee. The stands are listed from left to right. Letter “A” indicates a stand of company “A”, letter “B” - a stand of company “B”. Maximum number of stands at the exhibition is 30000. Output Output “YES” - if the requirements of the antitrust committee were fulfilled, and “NO” - if not. Sample test(s) Input A AAB Output YES [submit] /* ***Author :kuangbinCreated Time :2015/1/25 12:58:24File Name :E:\2014ACM\SGU\SGU191.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 30010;char str[MAXN];int sta[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%s”,str) == 1){ int cnt = 0; sta[0] = 1; sta[1] = 0; cnt = 1; sta[cnt++] = 1-sta[cnt-1]; printf(“%d\n”,sta[1]); cnt = 0; sta[cnt++] = (str[0]==’B’); scanf(“%s”,str); int len = strlen(str); int i = 0; while(i &lt; len &amp;&amp; cnt &gt; 0){ if(sta[cnt-1] == (str[i]==’A’))cnt–; else { sta[cnt++] = (str[i]==’A’); } i++; } if(i == len &amp;&amp; cnt == 0)printf(“YES\n”); else printf(“NO\n”); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>水题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 192. RGB （计算几何）]]></title>
    <url>%2F2015%2F01%2F22%2Fsgu192%2F</url>
    <content type="text"><![CDATA[SGU192 SGU192： 比较简单的计算几何。给了一些R、G、B三种颜色的线段，然后将线段投影到X轴，问对应颜色的长度。离X轴最近的线段是啥颜色就是啥颜色。 直接离散化，加入端点的X值，以及两两之间交点的X值。 然后枚举每一段，找出每一段的颜色。 192. RGBtime limit per test: 0.25 sec. memory limit per test: 4096 KB input: standard input output: standard output There are N segments on a plane (0&lt;N&lt;=300). Each segment is defined by coordinates of the end points (Xi1, Yi1) and (Xi2, Yi2) (i=1,2,…,N). All coordinates are in a range from 0 to 32000. No two segments have more than one common point. Each segment is painted in one of three colors: red (R), green (G), blue (B). All points of all segments are projected to the axis OX (projection is made parallel to the axis OY). Each projected point is painted in color of the point nearest to the axis OX. You have to find the total lengths of the projections painted in red (SR), green (SG) and blue (SB) colors. Input The first line contains natural number N. Each of the following N lines contains coordinates of the ends of the segments (4 integer delimited by a space) and the letter (R, G, B), determining the color of a segment. Output The first line must contain letter R and number SR delimited by a space. The second line must contain letter G and number SG. The third line must contain letter B and number SB. All numbers should be printed with precision 0.01. Sample test(s) Input 4 1 1 3 2 R 2 1 4 2 G 3 1 5 2 B 2 2 3 5 R Output R 1 G 1 B 2 计算几何判断线段相交模板，和求直线交点模板搬过来一用，就差不多了。 /* ***Author :kuangbinCreated Time :2015/1/21 18:18:18File Name :E:\2014ACM\SGU\SGU192.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const double eps = 1e-8;int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;}struct Point{ double x,y; Point(){} Point(double _x,double _y){ x = _x; y = _y; } void input(){ scanf(“%lf%lf”,&amp;x,&amp;y); } Point operator -(const Point &amp;b)const{ return Point(x-b.x,y-b.y); } double operator ^(const Point &amp;b)const{ return x*b.y - y*b.x; } double operator (const Point &amp;b)const{ return x\b.x + y*b.y; }};struct Line{ Point s,e; int type; int get_type(char ch){ if(ch == ‘R’)return 0; else if(ch == ‘G’)return 1; else return 2; } void input(){ s.input(); e.input(); if(s.x &gt; e.x)swap(s,e); char ss[3]; scanf(“%s”,ss); type = get_type(ss[0]); } int segcrossseg(Line v){ int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); int d3 = sgn((v.e-v.s)^(s-v.s)); int d4 = sgn((v.e-v.s)^(e-v.s)); if( (d1^d2) == -2 &amp;&amp; (d3^d4) == -2 )return 2; return (d1 == 0 &amp;&amp; sgn((v.s-s)(v.s-e)) &lt;=0) || (d2 == 0 &amp;&amp; sgn((v.e-s)(v.e-e)) &lt;= 0) || (d3 == 0 &amp;&amp; sgn((s-v.s)(s-v.e)) &lt;= 0) || (d4 == 0 &amp;&amp; sgn((e-v.s)(e-v.e)) &lt;= 0); } Point crosspoint(Line v){ double a1 = (v.e-v.s)^(s-v.s); double a2 = (v.e-v.s)^(e-v.s); return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1)); }};Line line[330];double x[160000]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ int cnt = 0; for(int i = 0;i &lt; n;i++){ line[i].input(); x[cnt++] = line[i].s.x; x[cnt++] = line[i].e.x; } for(int i = 0;i &lt; n;i++) for(int j = i+1;j &lt; n;j++) if(line[i].segcrossseg(line[j]) == 2){ Point tmp = line[i].crosspoint(line[j]); x[cnt++] = tmp.x; } sort(x,x+cnt); cnt = unique(x,x+cnt)-x; double ans[3]; ans[0] = ans[1] = ans[2] = 0; for(int i = 0;i &lt; cnt-1;i++){ if(fabs(x[i+1]-x[i]) &lt; eps)continue; double xx = (x[i]+x[i+1])/2; double now; int tt = -1; for(int j = 0;j &lt; n;j++){ if(line[j].s.x &lt; xx &amp;&amp; xx &lt; line[j].e.x){ double yy = line[j].s.y + (xx-line[j].s.x)*(line[j].e.y-line[j].s.y)/(line[j].e.x-line[j].s.x); if(tt == -1){ tt = line[j].type; now = yy; } else if(now &gt; yy){ tt = line[j].type; now = yy; } } } if(tt != -1){ ans[tt] += x[i+1]-x[i]; } } printf(“R %.2lf\n”,ans[0]); printf(“G %.2lf\n”,ans[1]); printf(“B %.2lf\n”,ans[2]); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>计算几何</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弱校离final有多远？]]></title>
    <url>%2F2015%2F01%2F13%2Facmicpc-wf-shu%2F</url>
    <content type="text"><![CDATA[本文和文题无关，请慎入！ 近日，黄金雄教授在博客上发布了2014年ACM/ICPC亚洲区域赛的晋级名单，也就是晋级2015年在摩洛哥的ACM/ICPC World Final名额。 博文链接 期盼许久，总算得到了确认，上海大学以在鞍山WF出线排名第一拿到了2015 world final的入场券。 近段时间一直在关注着黄金雄教授的博客，一直在等待着他发布Final名额的消息。虽然我校应该是早就没有悬念可以出线的了，但是总是希望看到官方的确认。 今天晚上群里突然发消息说WF名额公布了，然后便是各种祝贺之声。 看到上海大学出线的消息，欣喜之情久久不能平息，或者你们并不能体会我的这种心情，因为我等待这一天等待了好久了。 或许今年比赛前，根本没人看好我们会出线，但是上海大学今年真的出线了，而且是在鞍山以亚军，WF排名第一出线了。 我在最后一场区域赛里面第一次拿到了金牌，第一次进入final！ 同时祝贺出线的学校，为没有出线的学校感到惋惜，你们都还年轻，还有机会，加油！ 此外，我也想到了xiaodao看到这个消息的失望，xiaodao的经历是普通人无法想象的，但是xiaodao明年还有机会，加油！ 进入world final，是多少ACMer一直的追求。进入final的难度，我们都非常之清楚。尤其是对于弱校，大学前毫无基础，想要夺金都是一件非常困难的事情，final更加是难上加难。 转眼间，我已经参加了四年的区域赛了。在我参赛的这几年中，经历了太多的事情。学校里面集训队里的队员换了一批又一批，我仍然还在参赛， 当同一届的参加acm的退役了，我还在不断刷题，甚至当下一届的都退役了，我还在努力着。 上海大学和ACM有很深远的历史，1996年上海大学在中国大陆首次承办了ACM/ICPC，ACM/ICPC首次进入了中国大陆，然后上海大学连续举办了6年区域赛，当时参赛学校比较少，上海大学也作为东道主队连续四年参加了世界总决赛。 此后随着参赛学校的增加，上海大学就再也没能进入world final。 2014年，上海大学首次拿到了区域赛金牌，首次捧杯，进入了2015年的world final！ 2011年5月，那个时候什么都不懂的我，开始接触acm, 在刷着很简单的题目，然后申请加入了ACM集训队。我从一个弱菜，一点点学新的东西，很多东西都在改变，但是我始终在坚持着，遇到过很大的困难，但是我一直相信可以慢慢努力，为学校赢得荣誉，取得更好的成绩。 参加的四年区域赛，我在不断进步着，从铁到金，也算是都拿了一遍了。 2011年区域赛：那个时候我是刚刚接触ACM一个暑假，作为一个菜鸟水了两场区域赛，一铜一铁。 那年我校有ACM大牛李新民（那几年我校一个非常厉害的ACMer，是我下一届的，我刚入门是他带着训练的，后来13年是我队友，目前在上海欢乐互娱高就），我校区域赛成绩是一银二铜。 2012年区域赛：经过一年，我学到很多算法，很多题我都可以迅速秒了，但是思维仍然不足，对算法不能灵活应用，更多只会套模板，然后参加了当年惨烈的长春赛区，只能拿到一铜，另外一场去了泰国的赛区。 那年我校区域赛的成绩一样是一银二铜，银牌仍然是神牛李新民带领下获得。 2013年区域赛：那个时候自以为我的实力已经大增，那年参赛的目标就是想夺金。和李新民、吴旻烨组队，一改前几年每个赛区随意组合阵容的做法，组了相对固定队伍。迫于一些客观原因，第一次机会去参加了日本的区域赛，然后第二次机会去了最后一个赛区——长春，结果拿了银牌第一。 2013年区域赛便这样遗憾结束了。 这一年我校正处新老交替时期，虽然每个赛区都可以轻松通过网络赛拿到名额，但是都打铁了，这年我校区域赛成绩是一银六铁。 2014年区域赛：2014年上海大学成为了主办方，我也再一次参加了2014年的区域赛，剑指final。随着李新民的毕业退役，上年队伍也就没有了，而且突然感觉学校里搞ACM的人和我刚接触ACM几年已经完全换了，我呆的时间是最长的了，成了不能更老的老队员。新的一年和张健豪、梅俊组队了，破坏了他们原有的队伍，始终让我于心不忍。 认真训练以后，感觉自己这一年还是提升很快的，然后去了前两个赛区。第一场牡丹江直接被虐成狗，银牌收场。第二场鞍山在退役赛上几乎毫无退路了，背水一战，最终亚军出线，收获我的唯一一个区域赛金牌，也是上海大学第一个区域赛金牌！ 这一年我校ACM实力也是有了较大的提升，区域赛成绩是一金二银三铜四铁。 在大家的共同努力之下，我校的ACM水平这几年来还是有所提升的。 作为ACM里面的弱校，我们今年出线了！可能很多人看来我们是靠运气出线了，但是其中的艰辛可能只有像我这样一步一步经历过来才能体会吧！ Final并非是几个年轻人一时兴起，高喊努力刷题进final的口号就可以进的。You are too young! 弱校如何才能在强校的层层包围中，突围进Final？ 很多人来问我“大学才开始接触编程，如何才能把ACM搞好？”，说实话我也不知道，或许没有捷径，只有脚踏实地，一步一步努力，坚持不懈才能实现自己的目标。 从开始接触ACM以来的三年半，自己已经不记得是如何坚持下来的了，但是经历的每一件事情仍然历历在目。 2011年5月，知道有ACM这个比赛，那个时候连C++都不会，连A+B都不会水。 然后决心要好好参加这个比赛，之后去申请加入了集训队，开始了漫长的AC之旅。 这个过程自己从本科生变成了研究生，很多一起AC的人纷纷退役，也很多新人过来，认识了很多非常好的朋友，也收获了很多东西。 很多人好奇作为一个非计算机专业的我为何会一年又一年地参赛，其实ACM的获奖对于我这个专业是没啥用处的，甚至当年直研时候，ACM获奖是没起任何作用的。本科时候曾经拿过各类竞赛的证书，ACM是身边最无人知晓的，甚至没人知道这个是什么比赛，也不知道我啥时候参赛的。到了研究生时候，事情更加多了，ACM对于研究生更加没有作用了。 但是我还是一年一年坚持着，因为我一直期盼着可以拿得金牌进final。 当看到学校的ACM连网络赛拿到名额都困难的时候，我在坚持着改变这种现状。。。。。。 当在各类比赛中被虐的时候，我在不断努力着，然后还是被虐，T_T……. 当年做网络赛，同校的ACMer听了我的思路后不屑地说“你就扯吧！”，我然后默默地把那个题AC了！ 当有人取笑我“原来kuangbin也是可以final的”，我后来真的final了，sorry。。 当同学给我建议说不要去参加这个比赛了，其他学校都是高中开始搞的，比不过他们的，建议我把这个时间花在学习英语，做些更加有用的事情， 我没有迟疑过，仍然在敲着代码！ ……. ……. 看到知乎上有人提问“ACM比赛和绩点可以兼得吗？”，我回答可以…… 认识的一大批神牛，他们都好厉害，都从他们那学到了很多东西。 非常厉害的微软爷适牛，当年遗憾未能进入final，但是早就是人生赢家了。 ACMer的人气偶像xiaodao，坎坷的经历以及他对ACM的热爱，激励着无数人。shenshanlaoyao队的队长、一年拿三金的吴鑫wuyiqi，更是让众多学妹崇拜告白。 还有无比牛逼的谷歌微软詹姐，夺得季军，可能仍无缘final。………. ICPC都欠你们一个final！ 他们都是无比厉害的人啊，但是我每天都和他们谈笑风生，多么之荣幸啊！ 离我人生唯一一次的Final只有四个月了，接下来的时候我要好好准备Final了，Final机会难得，必要好好珍惜，况且不能让别人轻视了，不能让大家小看了上海大学。。。 接下来一段时间的计划： 首要任务当然是要好好准备Final了。然后认真总结一份最详细有用的模板，带领着群里的巨巨刷题，制定一份ACM从入门到精通的专题。 写着写着，发现自己不知所言，最后发现和文题无关，请原谅我着急的语文水平， 请慎入。！！ 有人想让我多写点方法论、入门、进阶等，很遗憾，你来错地方了，本文是纯吐槽贴。。。这些等待我Final结束后的退役贴吧～～～]]></content>
      <categories>
        <category>小结</category>
        <category>其他</category>
        <category>杂言</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 193. Chinese Girls' Amusement]]></title>
    <url>%2F2015%2F01%2F11%2Fsgu193%2F</url>
    <content type="text"><![CDATA[SGU193 推公式，然后大数。 水题。 193. Chinese Girls’ Amusementtime limit per test: 0.25 sec. memory limit per test: 65536 KB input: standard output: standard You must have heard that the Chinese culture is quite different from that of Europe or Russia. So some Chinese habits seem quite unusual or even weird to us. So it is known that there is one popular game of Chinese girls. N girls stand forming a circle and throw a ball to each other. First girl holding a ball throws it to the K-th girl on her left (1 ≤ K ≤ N/2). That girl catches the ball and in turn throws it to the K-th girl on her left, and so on. So the ball is passed from one girl to another until it comes back to the first girl. If for example N = 7 and K = 3, the girls receive the ball in the following order: 1, 4, 7, 3, 6, 2, 5, 1. To make the game even more interesting the girls want to choose K as large as possible, but they want one condition to hold: each girl must own the ball during the game. Input Input file contains one integer number N (3 ≤ N ≤ 102000) - the number of Chinese girls taking part in the game. Output Output the only number - K that they should choose. Sample test(s) Input Test #1 7 Test #2 6 Output Test #1 3 Test #2 1 就是找出一个&lt;=N/2的数，使得gcd(k,N) == 1 如果N是奇数，假设N = 2\*p+1, 那么 答案就是p, gcd(p,2\*p+1) = gcd(p,1) = 1; 如果N是偶数，假设N = 2\*p， 如果p是奇数，p和p-1明显都不满足和N的gcd为1，gcd(p-2,2\*p) = gcd(p-2,4) = 1, 因为4和奇数的gcd为1，所以答案是p-2 如果p是偶数，p不满足，gcd(p-1,2*p) = gcd(p-1,2) = 1 所以答案是p-1 import java.util.;import java.math.; public class Solution{ public static void main(String []arg){ Scanner cin = new Scanner(System.in); BigInteger n = cin.nextBigInteger(); if(n.mod(BigInteger.valueOf(2)).equals(BigInteger.ONE)){ System.out.println(n.divide(BigInteger.valueOf(2))); } else { BigInteger n2 = n.divide(BigInteger.valueOf(2)); n2 = n2.subtract(BigInteger.ONE); if(n2.mod(BigInteger.valueOf(2)).equals(BigInteger.ZERO)) n2 = n2.subtract(BigInteger.ONE); System.out.println(n2); } }}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regionals 2011 :: Asia - Dhaka]]></title>
    <url>%2F2015%2F01%2F06%2F2011dhaka%2F</url>
    <content type="text"><![CDATA[题目链接：UVALive 比赛链接：http://vjudge.net/contest/view.action?cid=48016#overview A: Binary Matrix题意就是有一个01矩阵，可以交换相邻的，第一行和最后一行相邻，第一列和最后一列相邻。 如果可以到达每行1个数一样，每列1个数一样，输出最少步数。 如果上面的不行，输出达到每行1个数一样的最少步数。 如果不行，输出达到每一列1个数一样的最少步数。 上面都不行输出impossible. 使用最小费用最大流去求最小步数，很简单的建图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325/* ***************Author :kuangbinCreated Time :2014/6/15 23:06:42File Name :E:\2014ACM\区域赛练习\2011\2011Dhaka\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1010;const int MAXM = 10000;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int N;void init(int n)&#123; N = n; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; N;i++) &#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t)) &#123; int Min = INF; for(int i = pre[t];i != -1;i = pre[edge[i^1].to]) &#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != -1;i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost*Min; &#125; flow += Min; &#125; return flow;&#125;int solve(int a[],int n)&#123; init(n+2); int sum = 0; for(int i = 1;i &lt;= n;i++) sum += a[i]; if(sum % n != 0)return -1; for(int i = 1;i &lt;= n;i++) &#123; addedge(0,i,a[i],0); addedge(i,n+1,sum/n,0); addedge(i,i+1&gt;n?1:i+1,INF,1); addedge(i,i-1&lt;1?n:i-1,INF,1); &#125; int cost; minCostMaxflow(0,n+1,cost); return cost;&#125;char str[MAXN][MAXN];int a[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); int n,m; while(T--) &#123; iCase++; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++) scanf("%s",str[i]); memset(a,0,sizeof(a)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) if(str[i][j] == '1') a[i+1]++; int ans1 = solve(a,n); memset(a,0,sizeof(a)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) if(str[i][j] == '1') a[j+1]++; int ans2 = solve(a,m); if(ans1 != -1 &amp;&amp; ans2 != -1) printf("Case %d: both %d\n",iCase,ans1+ans2); else if(ans1 != -1) printf("Case %d: row %d\n",iCase,ans1); else if(ans2 != -1) printf("Case %d: column %d\n",iCase,ans2); else printf("Case %d: impossible\n",iCase); &#125; return 0;&#125; B: Candles用0~9的数字拼成一个数，可以是直接拼，每个数字最多使用一次。 也可以是两个数相加，数字也最多使用一次。 给了n个数，找一个组合，可以表示出这n个数。 简单预处理下，就可以枚举判断了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/* ***************Author :kuangbinCreated Time :2014/6/18 8:52:31File Name :B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;bool f[110][2000];int cnt[10];void init()&#123; memset(f,false,sizeof(f)); for(int i = 1;i &lt;= 100;i++) &#123; int tmp = i; memset(cnt,0,sizeof(cnt)); while(tmp) &#123; cnt[tmp%10]++; tmp /= 10; &#125; bool flag = true; for(int j = 0;j &lt;= 9;j++) if(cnt[j] &gt; 1) flag = false; if(flag) &#123; tmp = 0; for(int j = 0;j &lt;= 9;j++) if(cnt[j]) tmp |= (1&lt;&lt;j); f[i][tmp] = true; &#125; for(int k = 1;k &lt; i;k++) &#123; memset(cnt,0,sizeof(cnt)); tmp = k; while(tmp) &#123; cnt[tmp%10]++; tmp /= 10; &#125; tmp = i-k; while(tmp) &#123; cnt[tmp%10]++; tmp /= 10; &#125; flag = true; for(int j = 0;j &lt;= 9;j++) if(cnt[j] &gt; 1) flag = false; if(flag) &#123; tmp = 0; for(int j = 0;j &lt;= 9;j++) if(cnt[j]) tmp |= (1&lt;&lt;j); f[i][tmp] = true; &#125; &#125; &#125; for(int k = 1;k &lt;= 100;k++) for(int i = 0;i &lt; (1&lt;&lt;10);i++) for(int j = i;j;j = j&amp;(j-1)) f[k][i] |= f[k][i&amp;(j-1)];&#125;int a[20];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); init(); int n; int iCase = 0; while(scanf("%d",&amp;n)==1 &amp;&amp; n) &#123; iCase++; for(int i = 0;i &lt; n;i++)scanf("%d",&amp;a[i]); int ans = -1; int tot = (1&lt;&lt;10); for(int i = 1;i &lt; tot;i++) &#123; bool flag = true; for(int j = 0;j &lt; n;j++) if(!f[a[j]][i]) flag = false; if(flag) &#123; if(ans == -1)ans = i; else &#123; int cnt1 = 0; int cnt2 = 0; for(int j = 0;j &lt; 10;j++) &#123; if(ans&amp;(1&lt;&lt;j))cnt1++; if(i&amp;(1&lt;&lt;j))cnt2++; &#125; if(cnt1 &gt; cnt2)ans = i; else if(cnt1 == cnt2 &amp;&amp; i &lt; ans)ans = i; &#125; &#125; &#125; printf("Case %d: ",iCase); for(int i = 9;i &gt;= 0;i--) if(ans &amp; (1&lt;&lt;i)) printf("%d",i); printf("\n"); &#125; return 0;&#125; C: Cards普通的概率DP 按照规则进行转移，注意两个王的处理，需要标记。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;const double INF = 1e20;const double eps = 1e-6;double dp[20][20][20][20][5][5];int C,D,H,S;double solve(int c1,int c2,int c3,int c4,int c5,int c6)&#123; if(dp[c1][c2][c3][c4][c5][c6] &lt; INF-1)return dp[c1][c2][c3][c4][c5][c6]; if((c1 + (c5 == 1) + (c6 == 1)) &gt;= C &amp;&amp; c2 + (c5 == 2) + (c6 == 2) &gt;= D &amp;&amp; c3 + (c5 == 3) + (c6 == 3) &gt;= H &amp;&amp; c4 + (c5 == 4) + (c6 == 4) &gt;= S ) return dp[c1][c2][c3][c4][c5][c6] = 0.0; int tot = 0; tot += 13-c1; tot += 13-c2; tot += 13-c3; tot += 13-c4; tot += (c5==0); tot += (c6==0); double ans = 1; if(c1 &lt; 13) ans += (double)(13-c1)/tot * solve(c1+1,c2,c3,c4,c5,c6); if(c2 &lt; 13) ans += (double)(13-c2)/tot * solve(c1,c2+1,c3,c4,c5,c6); if(c3 &lt; 13) ans += (double)(13-c3)/tot * solve(c1,c2,c3+1,c4,c5,c6); if(c4 &lt; 13) ans += (double)(13-c4)/tot * solve(c1,c2,c3,c4+1,c5,c6); if(c5 == 0) &#123; double tmp = min(solve(c1,c2,c3,c4,1,c6),min(solve(c1,c2,c3,c4,2,c6), min(solve(c1,c2,c3,c4,3,c6),solve(c1,c2,c3,c4,4,c6)))); ans += 1.0/tot * tmp; &#125; if(c6 == 0) &#123; double tmp = min(solve(c1,c2,c3,c4,c5,1),min(solve(c1,c2,c3,c4,c5,2), min(solve(c1,c2,c3,c4,c5,3),solve(c1,c2,c3,c4,c5,4)))); ans += 1.0/tot * tmp; &#125; return dp[c1][c2][c3][c4][c5][c6] = ans;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d%d%d%d",&amp;C,&amp;D,&amp;H,&amp;S); int cnt = 0; if(C &gt; 13)cnt += C - 13; if(D &gt; 13)cnt += D - 13; if(H &gt; 13)cnt += H - 13; if(S &gt; 13)cnt += S - 13; if(cnt &gt; 2) &#123; printf("Case %d: -1.000\n",iCase); continue; &#125; for(int i = 0;i &lt; 20;i++) for(int j = 0;j &lt; 20;j++) for(int x = 0;x &lt; 20;x++) for(int y = 0;y &lt; 20;y++) for(int t1 = 0;t1 &lt; 5;t1++) for(int t2 = 0;t2 &lt; 5;t2++) dp[i][j][x][y][t1][t2] = INF; printf("Case %d: %.3lf\n",iCase,solve(0,0,0,0,0,0)); &#125; return 0;&#125; D: Game of Connect题意就是一个n个点，m条边的图。 第一个人首先指定两个不同的顶点A和B。 然后两个人轮流进行操作，第一个人先操作。 第一个人删掉一条没有染色的边，第二个人将一条没有删除的边进行染色。 当A和B两点用染色的边连通时，第二个人获胜。 问的第二个人有没有必胜策略。 其实就是在原图中 找出两个不相交的生成树。 代码参考：here 留个坑，待填！ E: Guards题意：NN的格子上放一些人，每行每列刚好两个，同一行同一列的位于同一连通分量，问恰好k个连通分量的放法。 \[2&lt;=N&lt;= 10^{5}, 1 &lt;= K &lt;= min(N, 50)\] DP 很明显的思路，主要是怎么样转移。 思维方式不唯一。 我是f[i][j] 表示i\i的，j个连通分量的方法。 g[i][j] 表示i*(i-1)的，j个连通分量的放法。 i(i-1)肯定是有两行是只有一个的。 然后分这两个在同一列和不在同一列。 如果在同一列，可以把这个两个去掉，其实就是(i-2)(i-2)里面的了，可以由f[i-2][j-1]转移过来。 如果不在同一列，去掉这两行，发现可以由g[i-1][j]转移过来。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* ***************Author :kuangbinCreated Time :2014/6/28 18:45:35File Name :E:\2014ACM\区域赛练习\2011\2011Dhaka\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;int f[100010][55];int g[100010][55];void Add(int &amp;a,int b)&#123; a += b; if(a &gt;= MOD)a -= MOD;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); f[2][1] = 1; g[2][1] = 1; for(int i = 3;i &lt;= 100000;i++) &#123; for(int j = 1;j &lt;= 50 &amp;&amp; j &lt;= i/2;j++) &#123; Add(g[i][j],(long long)i*(i-1)/2 * (i-1) %MOD * f[i-2][j-1]%MOD); Add(g[i][j],(long long)i*(i-1) %MOD * g[i-1][j]%MOD); f[i][j] = g[i][j]; &#125; &#125; int T; int iCase = 0; int n,k; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d%d",&amp;n,&amp;k); printf("Case %d: %d\n",iCase,f[n][k]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Online Judge</category>
        <category>套题</category>
        <category>UVALive</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regionals 2011 :: Europe - Northeastern]]></title>
    <url>%2F2015%2F01%2F06%2F2011neerc%2F</url>
    <content type="text"><![CDATA[题目链接：UVALive 开的比赛链接：VJ A: ASCII Area水题。 遇到\或者/就加0.5 当时 . 的时候，要判断是里面还是外面，可以用射线法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* ***************Author :kuangbinCreated Time :2014/6/28 22:39:40File Name :E:\2014ACM\区域赛练习\2011\2011NEERC\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;char str[110][110];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m; while(scanf("%d%d",&amp;n,&amp;m) == 2) &#123; for(int i = 0;i &lt; n;i++)scanf("%s",str[i]); int ans = 0; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; if(str[i][j] != '.')ans++; else &#123; int cnt = 0; for(int k = 0;k &lt; j;k++) if(str[i][k] != '.') cnt++; if(cnt&amp;1)ans += 2; &#125; &#125; printf("%d\n",ans/2); &#125; return 0;&#125; B： Binary Encoding很简答的题。 先求出k, 是的 $2^{k}&lt;=m$然后其实用k位表示的有$2*m-2^{k}$个，其余是用k-1位表示的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* ***************Author :kuangbinCreated Time :2014/6/28 22:53:11File Name :E:\2014ACM\区域赛练习\2011\2011NEERC\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;void ouput(int n,int m)&#123; for(int i = m-1;i &gt;= 0;i--) if(n&amp;(1&lt;&lt;i)) printf("1"); else printf("0"); printf("\n");&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int m; while(scanf("%d",&amp;m) == 1) &#123; int k = 0; while((1&lt;&lt;k) &lt; m)k++; int cnt = 2*m - (1&lt;&lt;k); for(int i = 0;i &lt; m-cnt;i++)ouput(i,k-1); for(int i = m-cnt;i &lt; m;i++)ouput((1&lt;&lt;k) - (m-i),k); &#125; return 0;&#125; C: Caption题目比较长，主要是读懂题目，然后去DP。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273/* ***************Author :kuangbinCreated Time :2014/7/3 19:35:47File Name :E:\2014ACM\区域赛练习\2011\2011NEERC\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;char letter[30][33][33];char cur[33][2020];char str1[33][1000];char str[100];int a[100];int f1[2010][2020];//表示i-j变为空需要的变换次数int f2[2010][33];//f2[i][j]表示从第i列开始放第j个字符需要的改变int dp[2010][33];//dp[i][j]表示第j个字符在第i列开始，前j个字符需要的改变int pre[2010][33];//记录路径int num[2010];int ans[33];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int m,n,k,smin,smax; while(scanf("%d%d%d%d%d",&amp;m,&amp;n,&amp;k,&amp;smin,&amp;smax) == 5) &#123; gets(str1[0]); for(int i = 0;i &lt; m;i++) gets(str1[i]); int len = strlen(str1[0]); for(int i = 0;i &lt; (len+1)/(k+3);i++) &#123; for(int x = 0;x &lt; m;x++) for(int y = 0;y &lt; k;y++) letter[str1[0][i(k+3)]-'A'][x][y] = str1[x][i(k+3)+y+2]; &#125; gets(str); int c_cur = strlen(str); for(int i = 0;i &lt; m;i++) for(int j = 0;j &lt; n;j++) cur[i][j] = '.'; for(int i = 0;i &lt; c_cur;i++) scanf("%d",&amp;a[i]); int dd = 0; for(int i = 0;i &lt; c_cur;i++) &#123; if(i == 0)dd += a[i]; else dd += a[i]+k; if(str[i] == ' ')continue; for(int x = 0;x &lt; m;x++) for(int y = 0;y &lt; k;y++) cur[x][dd+y] = letter[str[i]-'A'][x][y]; &#125; memset(f1,0,sizeof(f2)); memset(num,0,sizeof(num)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) if(cur[j][i] == '*') num[i]++; for(int i = 0;i &lt; n;i++) for(int j = i;j &lt; n;j++) &#123; if(j == i)f1[i][j] = num[i]; else f1[i][j] = f1[i][j-1] + num[j]; &#125; gets(str); gets(str); len = strlen(str); for(int i = 0;i &lt;= n-k;i++) for(int j = 0;j &lt; len;j++) &#123; if(str[j] == ' ')f2[i][j] = f1[i][i+k-1]; else &#123; f2[i][j] = 0; for(int x = 0;x &lt; m;x++) for(int y = 0;y &lt; k;y++) if(cur[x][i+y] != letter[str[j]-'A'][x][y]) f2[i][j]++; &#125; &#125; memset(dp,-1,sizeof(dp)); for(int i = 0;i &lt;= n-k;i++) &#123; dp[i][0] = f2[i][0] ; if(i &gt; 0)dp[i][0] += f1[0][i-1]; pre[i][0] = -1; &#125; for(int i = 0;i &lt;= n-k;i++) for(int j = 1;j &lt; len;j++) &#123; for(int x = i - smax - k;x &lt;= i - smin - k;x++) if(x &gt;= 0 &amp;&amp; dp[x][j-1] != -1) &#123; int tmp = dp[x][j-1] + f1[x+k][i-1] + f2[i][j]; if(j == len-1) tmp += f1[i+k][n-1]; if(dp[i][j] == -1 || dp[i][j] &gt; tmp) &#123; dp[i][j] = tmp; pre[i][j] = x; &#125; &#125; &#125; int now = -1; for(int i = 0;i &lt;= n;i++) if(dp[i][len-1] != -1) &#123; if(now == -1 || dp[now][len-1] &gt; dp[i][len-1]) now = i; &#125; //cout&lt;&lt;now&lt;&lt;endl; for(int i = len-1;i &gt; 0;i--) &#123; ans[i] = now - pre[now][i] - k; now = pre[now][i]; &#125; ans[0] = now; for(int i = 0;i &lt; len;i++) &#123; printf("%d",ans[i]); if(i == len-1)printf("\n"); else printf(" "); &#125; &#125; return 0;&#125; D: Dictionary Size一个字符串前缀后缀的题目。 给了n个字符串。 a dictionary word 就是一个原来的字符串，或者是非空前缀+后缀。 比较难想。 首先肯定是前缀和后缀都建一个字典树。 那么总数就是cnt1*cnt2 (cnt1和cnt2都不包含那个空点。) 这个总数其实不包含 原来字符串的情况。 然后需要排除掉一些重复的。 需要使用等价的思想去排除掉重复的。 看到个证明比较好的。here 这个说明一部分问题，但是并没有完全说明。 注意原串是可以的，但是前缀或者后缀是不可以的。 去重的时候，不要算第一个点。 这样做过去其实刚好把原串的个数加上了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/* ***************Author :kuangbinCreated Time :2014/7/3 22:30:10File Name :E:\2014ACM\区域赛练习\2011\2011NEERC\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;struct Trie&#123; int next[400010][26]; int root,L; int num[26]; int newnode() &#123; for(int i = 0;i &lt; 26;i++)next[L][i] = -1; return L++; &#125; void init() &#123; L = 0; root = newnode(); memset(num,0,sizeof(num)); &#125; void insert(char buf[]) &#123; int len = strlen(buf); int now = root; for(int i = 0;i &lt; len;i++) &#123; if(next[now][buf[i]-'a'] == -1) &#123; next[now][buf[i]-'a'] = newnode(); if(i &gt; 0) num[buf[i]-'a']++; &#125; now = next[now][buf[i]-'a']; &#125; &#125;&#125;tree1,tree2;char str[100];int one[100];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1) &#123; tree1.init(); tree2.init(); memset(one,0,sizeof(one)); while(n--) &#123; scanf("%s",str); int len = strlen(str); if(len == 1) &#123; one[str[0]-'a']++; &#125; tree1.insert(str); reverse(str,str+len); tree2.insert(str); &#125; long long ans = (long long)(tree1.L-1)*(tree2.L-1); for(int i = 0;i &lt; 26;i++) &#123; if(one[i])ans++; ans -= (long long)tree1.num[i]*tree2.num[i]; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; E: Eve题目意思很长，主要是读懂题目 题意不赘述了。 并查集胡搞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223/* ***************Author :kuangbinCreated Time :2014/7/3 22:49:15File Name :E:\2014ACM\区域赛练习\2011\2011NEERC\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 500010;int F[MAXN];int find(int x)&#123; if(F[x] == -1)return x; return F[x] = find(F[x]);&#125;bool alive[MAXN];int sex[MAXN];char str[10];void bing(int u,int v)&#123; int t1 = find(u); int t2 = find(v); if(t1 != t2)F[t1] = t2;&#125;pair&lt;int,int&gt;p[200010];int a[200010];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1) &#123; memset(F,-1,sizeof(F)); for(int i = 1;i &lt;= n;i++) &#123; scanf("%s",str); if(str[0] == 'M')sex[i] = 0; else sex[i] = 1; alive[i] = true; &#125; int m; scanf("%d",&amp;m); int id = n; for(int i = n+1;i &lt;= n+m;i++) &#123; int u,v; scanf("%d",&amp;u); if(u &lt; 0) &#123; alive[-u] = false; continue; &#125; scanf("%d%s",&amp;v,str); ++id; if(str[0] == 'M')sex[id] = 0; else sex[id] = 1; alive[id] = true; bing(id,v); &#125; int k; scanf("%d",&amp;k); int cnt = 0; for(int i = 0;i &lt; k;i++) &#123; scanf("%d%d",&amp;p[i].first,&amp;p[i].second); a[cnt++] = p[i].second; &#125; map&lt;int,int&gt;mp; mp.clear(); sort(a,a+cnt); cnt = unique(a,a+cnt) - a; for(int i = 0;i &lt; cnt;i++) mp[a[i]] = i; for(int i = 0;i &lt; k;i++) &#123; bing(p[i].first,mp[p[i].second]+1+n+m); &#125; cnt = 0; int num = 0; for(int i = 1;i &lt;= id;i++) if(alive[i]) &#123; a[cnt++] = find(i); num++; &#125; sort(a,a+cnt); cnt = unique(a,a+cnt) - a; if(cnt == 1) &#123; printf("YES\n"); continue; &#125; int tmp = 0; for(int i = 0;i &lt; cnt;i++) if(a[i] &gt; n+m) tmp++; if(tmp &gt; 1)printf("NO\n"); else printf("POSSIBLY\n"); &#125; return 0;&#125; K: Kingdom Roadmap题意：给了一颗树，让你加最少的边，使得不存在桥。 很明显需要加的边的数量就是 (leaf + 1)/2 然后需要构造解。 解的构造可以使用类似树形DP的思路。 对于每颗子树，如果有奇数个叶子节点，那么提供1个叶子出来，其余叶子两两连边。 如果有偶数个叶子节点，提供2个叶子出来，其余内部解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;const int MAXN = 100010;int ind[MAXN];struct Edge&#123; int to,next;&#125;edge[MAXN*2];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int size[MAXN];int one[MAXN],two[MAXN];int c[MAXN*2];void dfs(int u,int pre)&#123; size[u] = 0; if(ind[u] == 1) &#123; size[u] = 1; one[u] = u; two[u] = -1; return; &#125; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(pre == edge[i].to)continue; dfs(edge[i].to,u); size[u] += size[edge[i].to]; &#125; int cnt = 0; for(int i = head\[u\];i != -1;i = edge\[i\].next) &#123; int v = edge\[i\].to; if(v == pre)continue; if(size\[v\]&amp;1) &#123; c\[cnt++\] = one\[v\]; &#125; &#125; for(int i = head\[u\];i != -1;i = edge\[i\].next) &#123; int v = edge\[i\].to; if(v == pre)continue; if((size\[v\]&amp;1) == 0) &#123; c\[cnt++\] = one\[v\]; c\[cnt++\] = two\[v\]; &#125; &#125; if(size\[u\] &amp; 1) &#123; one\[u\] = c\[cnt-1\]; for(int i = 0;i+1 &lt; cnt-1;i+=2) &#123; printf("%d %d\\n",c\[i\],c\[i+1\]); &#125; &#125; else &#123; one\[u\] = c\[cnt-1\]; two\[u\] = c\[0\]; for(int i = 1;i+1 &lt; cnt-1;i+=2) &#123; printf("%d %d\\n",c\[i\],c\[i+1\]); &#125; &#125; if(pre == -1) &#123; if(size\[u\]&amp;1)printf("%d %d\\n",u,one\[u\]); else printf("%d %d\\n",one\[u\],two\[u\]); &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n, a, b; while(scanf("%d",&amp;n) == 1) &#123; memset(ind, 0, sizeof ind); init(); for(int i=0; i&lt;n-1; i++)&#123; scanf("%d%d",&amp;a,&amp;b); ind\[a\] ++; ind\[b\] ++; addedge(a,b); addedge(b,a); &#125; int ans = 0; vector&lt;int&gt; vs; vs.clear(); for(int i=1; i&lt;=n; i++)&#123; if(ind\[i\] == 1)&#123; ans++; &#125; &#125; printf("%d\\n",(ans+1)/2); if(n == 2) &#123; printf("1 2\\n"); continue; &#125; for(int i = 1;i &lt;= n;i++) if(ind\[i\] &gt; 1) &#123; dfs(i,-1); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Online Judge</category>
        <category>套题</category>
        <category>UVALive</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 194. Reactor Cooling （无源汇有上下界最大流）]]></title>
    <url>%2F2014%2F12%2F28%2Fsgu194%2F</url>
    <content type="text"><![CDATA[模板题了！ SGU194 194. Reactor Coolingtime limit per test: 0.5 sec. memory limit per test: 65536 KB input: standard output: standard The terrorist group leaded by a well known international terrorist Ben Bladen is buliding a nuclear reactor to produce plutonium for the nuclear bomb they are planning to create. Being the wicked computer genius of this group, you are responsible for developing the cooling system for the reactor. The cooling system of the reactor consists of the number of pipes that special cooling liquid flows by. Pipes are connected at special points, called nodes, each pipe has the starting node and the end point. The liquid must flow by the pipe from its start point to its end point and not in the opposite direction. Let the nodes be numbered from 1 to N. The cooling system must be designed so that the liquid is circulating by the pipes and the amount of the liquid coming to each node (in the unit of time) is equal to the amount of liquid leaving the node. That is, if we designate the amount of liquid going by the pipe from i-th node to j-th as fij, (put fij = 0 if there is no pipe from node i to node j), for each i the following condition must hold: sum(j=1..N, fij) = sum(j=1..N, fji) Each pipe has some finite capacity, therefore for each i and j connected by the pipe must be fij ≤ cij where cij is the capacity of the pipe. To provide sufficient cooling, the amount of the liquid flowing by the pipe going from i-th to j-th nodes must be at least lij, thus it must be fij ≥ lij. Given cij and lij for all pipes, find the amount fij, satisfying the conditions specified above. Input The first line of the input file contains the number N (1 ≤ N ≤ 200) - the number of nodes and and M — the number of pipes. The following M lines contain four integer number each - i, j, lij and cij each. There is at most one pipe connecting any two nodes and 0 ≤ lij ≤ cij ≤ 105 for all pipes. No pipe connects a node to itself. If there is a pipe from i-th node to j-th, there is no pipe from j-th node to i-th. Output On the first line of the output file print YES if there is the way to carry out reactor cooling and NO if there is none. In the first case M integers must follow, k-th number being the amount of liquid flowing by the k-th pipe. Pipes are numbered as they are given in the input file. Sample test(s) Input Test #1 4 6 1 2 1 2 2 3 1 2 3 4 1 2 4 1 1 2 1 3 1 2 4 2 1 2 Test #2 4 6 1 2 1 3 2 3 1 3 3 4 1 3 4 1 1 3 1 3 1 3 4 2 1 3 Output Test #1 NO Test #2 YES 1 2 3 2 1 1 题目大意：给n个点，及m根pipe，每根pipe用来流躺液体的，单向的，每时每刻每根pipe流进来的物质要等于流出去的物质，要使得m条pipe组成一个循环体，里面流躺物质。并且满足每根pipe一定的流量限制，范围为\[Li,Ri\].即要满足每时刻流进来的不能超过Ri(最大流问题)，同时最小不能低于Li。 建图模型： 对于每根管子有一个上界容量up和一个下界容量low，我们让这根管子的容量下界变为0，上界为up-low。可是这样做了的话流量就不守恒了，为了再次满足流量守恒，即每个节点&quot;入流=出流”，我们增设一个超级源点st和一个超级终点sd。我们开设一个数组du\[\]来记录每个节点的流量情况。 du\[i\]=in\[i\]（i节点所有入流下界之和）-out\[i\]（i节点所有出流下界之和）。 当du\[i\]大于0的时候，st到i连一条流量为du\[i\]的边。 当du\[i\]小于0的时候，i到sd连一条流量为-du\[i\]的边。 最后对（st，sd）求一次最大流即可，当所有附加边全部满流时（即maxflow==所有du\[\]&gt;0之和），有可行解。 经典的建图了，直接上最大流模板即可。 然后题目要输出一个解。 /* ***Author :kuangbinCreated Time :2014/12/28 17:20:14File Name :E:\2014ACM\SGU\SGU194.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 210;//点数的最大值const int MAXM = 40010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge{ int to,next,cap,flow;}edge[MAXM];//注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init(){ tol = 0; memset(head,-1,sizeof(head));}int id[MAXM];//加边，单向图三个参数，双向图四个参数void addedge(int u,int v,int w,int rw=0){ edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u]; edge[tol].flow = 0;head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v]; edge[tol].flow = 0;head[v]=tol++;}//输入参数：起点、终点、点的总数//点的编号没有影响，只要输入点的总数int sap(int start,int end,int N){ memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N){ if(u == end){ int Min = INF; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]){ edge[i].flow += Min; edge[i^1].flow -= Min; } u = start; ans += Min; continue; } bool flag = false; int v; for(int i = cur[u]; i != -1;i = edge[i].next){ v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]){ flag = true; cur[u] = pre[v] = i; break; } } if(flag){ u = v; continue; } int Min = N; for(int i = head[u]; i != -1;i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min){ Min = dep[edge[i].to]; cur[u] = i; } gap[dep[u]]–; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; } return ans;}int up[MAXM],down[MAXN];int a[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2){ init(); memset(a,0,sizeof(a)); int u,v; for(int i = 0;i &lt; m;i++){ scanf(“%d%d%d%d”,&amp;u,&amp;v,&amp;down[i],&amp;up[i]); a[u] -= down[i]; a[v] += down[i]; id[i] = tol; addedge(u,v,up[i]-down[i]); } int sum = 0; for(int i = 1;i &lt;= n;i++){ if(a[i] &gt; 0){ addedge(0,i,a[i]); sum += a[i]; } else if(a[i] &lt; 0){ addedge(i,n+1,-a[i]); } } if(sap(0,n+1,n+2) &lt; sum)printf(“NO\n”); else { printf(“YES\n”); for(int i = 0;i &lt; m;i++){ printf(“%d\n”,down[i]+edge[id[i]].flow); } } } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>最大流</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【坑】Palindrome]]></title>
    <url>%2F2014%2F12%2F20%2Fpalindrome%2F</url>
    <content type="text"><![CDATA[西安现场赛出了个回文的模板题，感觉是陈题了。 留个坑，把回文相关的几个题都补一下。 HDU3948 回文个数。 xiaodao总结： http://www.shuizilong.com/house/archives/hdu-3948-the-number-of-palindromes/ 戴神出的bupt校赛题： here 和14年西安G题已经是非常相似了。 12年长春G题： HDU4426 14年西安G题：here]]></content>
      <categories>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SGU 195. New Year Bonus Grant （贪心）]]></title>
    <url>%2F2014%2F11%2F28%2Fsgu195%2F</url>
    <content type="text"><![CDATA[SGU195 题意比较难懂。 大致意思就是在一颗树形的关系里面。 •Mocrosoft software这个公司有N个员工。除了老板（BillHates）以外，其他每个人都有一个自己的上司。现在过年了，老板打算给员工们发奖金。为了让支出最少，现在有三个规则： ·Eachprogrammer may either assign a grant to one of his subordinates or have a grantassigned to him by his chief or none of the above. 一、**每个员工可以安排自己的下属拿奖金，可以等待拿自己上司给自己的奖金。也可以什么都不做。（就是说 他给下属安排奖金后，他就不能有奖金了） ·Noprogrammer can simultaneously receive a grant and assign a grant to one of hissubordinates. 二、没有哪一个程序猿可以同时接收上司给的奖金，还给自己下属安排奖金。 （就是说他给下属安排奖金后，他就不能由奖金了！） ·Noprogrammer can assign a grant to more than one of his subordinates 三、每个程序猿最多只能给自己的一个下属（要是他有下属的话）安排奖金。** 注意1是不能选的。 贪心从底下一层开始选择。 195. New Year Bonus Granttime limit per test: 0.75 sec. memory limit per test: 65536 KB input: standard output: standard All programmers of Mocrosoft software company are organized in a strict subordination hierarchy. Every programmer has exactly one chief, except Bill Hates who is also the head of the company and has no chief. Due to the celebration of the new 2003 year, chief accountant of Mocrosoft decided to pay a New Year Bonus Grant of 1000 dollars to some programmers. However being extremely concerned of the company wealth she would like to designate the least possible amount of money for these grants. On the other hand she didn’t want to be accused of being too greedy or of giving preferences to some programmers. To do this, she developed the following scheme of grants appointment: Each programmer may either assign a grant to one of his subordinates or have a grant assigned to him by his chief or none of the above. No programmer can simultaneously receive a grant and assign a grant to one of his subordinates. No programmer can assign a grant to more than one of his subordinates The scheme seemed to be designed perfectly — nobody would like to assign a grant to anybody since in this case he himself would not receive money. But programmers somehow discovered the plan of chief accountant and decided to make a trick to get the most money possible and share them fairly afterwards. The idea was to make such grant assignments that the total amount of grant money received is maximum possible. You were selected to write the program which will find the optimal grants appointment. Input The first line of the input file contains integer N — the number of programmers in Mocrosoft company (2 ≤ N ≤ 500 000). Each programmer is assigned his unique identifier — integer number ranging from 1 to N. Bill Hates has number 1 and each programmer has the number greater then the number of his chief. The second line of the input file contains N-1 integers, i-th of which being the number of the chief of the worker whose number is (i + 1). Output On the first line of the output file print the maximum possible amount of money workers can get. On the second line output the numbers of programmers that will receive grant in ascending order. Sample test(s) Input 4 1 1 2 Output 2000 3 4 /* ***Author :kuangbinCreated Time :2014/11/28 18:42:49File Name :E:\2014ACM\SGU\SGU195.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 500010;int fa[MAXN];bool vis[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ fa[1] = 1; for(int i = 2;i &lt;= n;i++){ scanf(“%d”,&amp;fa[i]); } vectorans; memset(vis,false,sizeof(vis)); for(int i = n;i &gt; 1;i–){ int u = i; if(vis[u] || vis[fa[u]])continue; ans.push_back(u); vis[u] = true; vis[fa[u]] = true; } sort(ans.begin(),ans.end()); int sz = ans.size(); printf(“%d\n”,sz*1000); for(int i = 0;i &lt; sz;i++){ printf(“%d”,ans[i]); if(i &lt; sz-1)printf(“ “); else printf(“\n”); } } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim在ACM/ICPC中的使用]]></title>
    <url>%2F2014%2F11%2F22%2Fvim-acmicpc%2F</url>
    <content type="text"><![CDATA[Vim大法好！ 应大家的要求，写一篇博客来介绍下vim在ACM中的简单使用。 写本文的目的，只是为了给广大acmer一个入门vim的指导。不喜勿喷！ 不想看到的请远离！ vim大法好，远离sublime、cb保平安！ 从13年开始，平时写程序和比赛都是用的vim，也一直在推荐大家使用vim，至于为何要用vim，原因很多。 为何要使用vim？1) 可以装逼，vim显得高端大气上档次，现场赛你打开的是丑陋的CB，别人打开的是VIM，高下立判。 2) 用vim可以明显提高写代码的感觉，加快代码速度。3) vim大法好。 当然，前面纯粹个人胡扯，要用啥都是个人偏好而已。 下面简单介绍VIM的使用。 比赛篇首先介绍vim在比赛使用的使用。 先大致介绍现场赛vim的配置方法。 现场赛比赛系统是ubuntu， 都是安装好了vim的。 ubuntu系统下打开终端（终端一般在左侧有了，没有就按Ctrl+Alt+T启动，然后可以锁定在左侧），打开终端输入vim就进入vim了。 配置方法是输入 vim ~/.vimrc (这样是用vim编辑配置文件，或者用 gedit ~/.vimrc 就是用gedit编辑了) 配置的话，按照自己习惯加几句配置文件就可以使用了。 我一般配置下面几个： syntax onset nuset tabstop=4set shiftwidth=4colo eveningset mouse=aset cin 上面这几个配置的具体含义可以去百度下，有的也是可以不要的。 然后配置以后保存。VIM的配置就结束了。 然后在终端里面 输入 vim A.cpp 然后就开始写代码了。 编译运行的话，可以另外打开一个终端（就是左侧右击，然后new一个出来），就可以一边编辑，一遍保存了。 但是注意在代码编译以后，一定要 :w 来保存下，然后进行编译运行。 编译可以输入 g++ A.cpp -o A 如果没有错就可以了。 然后输入 ./A 来运行，然后输入数据啥的，退出的话是 按 Ctrl+C VIM入门篇 简明Vim练级攻略 把这上面教的VIM命令都熟悉下，差不多就可以了。 VIM命令很多，但是一开始常用的就那么几个吧，需要的指令慢慢积累就会了。 如果你的系统是WINDOWS，那可以安装一个GVIM，进行学习，用来平时写代码。 下载链接：here 进去后点击左侧的Download, 然后选择 PC: MS-DOS and MS-Windows 这个进行下载。 下载以后进行安装。 安装后桌面出现好几个快捷方式，有用的就gVim 7.4， 其余可以删除。 GVIM就直接点开就可以写了。一般是新建一个文本，改名为A.cpp, 然后打开Gvim, 把A.cpp拖入Gvim ,然后就可以进行编辑了。 Gvim的配置，就是在安装目录那有一个 _vimrc文件，编辑这个文件，在后面添加一些你自己需要的配置。 我的配置如下: (加到_vimrc后面) set nuset history=1000000set tabstop=4set shiftwidth=4 set smarttab set cindent colo evening set showcmd set nobackupset noswapfile set mouse=a map :call CR()func! CR()exec “w”exec “!g++ -O2 -g % -o %&lt;”exec “! %&lt;”endfunc imap &lt;c-]&gt; {}O map ggVG”+y “inoremap ( ()“inoremap [ []“inoremap { {}“inoremap “ “”“inoremap ‘ ‘’ map :call SetTitle()func SetTitle()let l = 0let l = l + 1 | call setline(l,’/ **‘)let l = l + 1 | call setline(l,’Author :kuangbin’)let l = l + 1 | call setline(l,’Created Time :’.strftime(‘%c’))let l = l + 1 | call setline(l,’File Name :’.expand(‘%’))let l = l + 1 | call setline(l,’** */‘)let l = l + 1 | call setline(l,’’) let l = l + 1 | call setline(l,’#include &lt;stdio.h&gt;’)let l = l + 1 | call setline(l,’#include &lt;string.h&gt;’)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include &lt;math.h&gt;’)let l = l + 1 | call setline(l,’#include &lt;stdlib.h&gt;’)let l = l + 1 | call setline(l,’#include &lt;time.h&gt;’)let l = l + 1 | call setline(l,’using namespace std;’)let l = l + 1 | call setline(l,’’)let l = l + 1 | call setline(l,’int main()’)let l = l + 1 | call setline(l,’{‘)let l = l + 1 | call setline(l,’ //freopen(“in.txt”,”r”,stdin);’)let l = l + 1 | call setline(l,’ //freopen(“out.txt”,”w”,stdout);’)let l = l + 1 | call setline(l,’ ‘)let l = l + 1 | call setline(l,’ return 0;’)let l = l + 1 | call setline(l,’}’)endfunc 里面的配置可以自己修改，可以加一些快捷键之类的。 我的配置文件是 按F2，自动写好头文件之类的信息，然后按F6进行编译运行。 平时用起来都很方便。 欢迎进行交流讨论！ (**加群请写点验证信息**) 此外最近新建了一个QQ群。 如果是自以为很牛逼的人，请别加！ 181826055 （ACM交流群， 我新建的QQ群，目的是进行交流ACM相关算法，共同提高，不喜勿加！ 太NB的不要加！禁止D人。） 旨在构建一个最和谐的ACM交流群~~~ 维护一个和谐的群环境，交流讨论算法相关。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 196. Matrix Multiplication]]></title>
    <url>%2F2014%2F11%2F21%2Fsgu196%2F</url>
    <content type="text"><![CDATA[SGU196 水题。答案直接就是每个点的度数平方和。 196. Matrix Multiplicationtime limit per test: 0.25 sec. memory limit per test: 65536 KB input: standard output: standard Let us consider an undirected graph G = &lt;V, E&gt; which has N vertices and M edges. Incidence matrix of this graph is an N × M matrix A = {aij}, such that aij is 1 if i-th vertex is one of the ends of j-th edge and 0 in the other case. Your task is to find the sum of all elements of the matrix ATA where AT is A transposed, i.e. an M × N matrix obtained from A by turning its columns to rows and vice versa. Input The first line of the input file contains two integer numbers — N and M (2 le N le 10,000, 1 le M le 100,000). 2M integer numbers follow, forming M pairs, each pair describes one edge of the graph. All edges are different and there are no loops (i.e. edge ends are distinct). Output Output the only number — the sum requested. Sample test(s) Input 4 4 1 2 1 3 2 3 2 4 Output 18 /* ***Author :kuangbinCreated Time :2014/11/21 22:57:16File Name :E:\2014ACM\SGU\SGU196.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int du[10010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2){ memset(du,0,sizeof(du)); int u,v; while(m–){ scanf(“%d%d”,&amp;u,&amp;v); du[u]++; du[v]++; } int ans = 0; for(int i = 1;i &lt;= n;i++) ans += du[i]*du[i]; printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>水题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 197. Nice Patterns Strike Back （矩阵乘法）]]></title>
    <url>%2F2014%2F11%2F21%2Fsgu197%2F</url>
    <content type="text"><![CDATA[SGU197 给N*M的格子涂黑白两种颜色，要求没有2*2的小矩形是同色的。 N很大，M很小。 答案对P取模。 明显的状态压缩出转移，然后矩阵优化下就可以了。 197. Nice Patterns Strike Backtime limit per test: 0.5 sec. memory limit per test: 65536 KB input: standard output: standard You might have noticed that there is the new fashion among rich people to have their yards tiled with black and white tiles, forming a pattern. The company Broken Tiles is well known as the best tiling company in our region. It provides the widest choices of nice patterns to tile your yard with. The pattern is nice if there is no square of size 2 × 2, such that all tiles in it have the same color. So patterns on the figure 1 are nice, while patterns on the figure 2 are not. The president of the company wonders whether the variety of nice patterns he can provide to the clients is large enough. Thus he asks you to find out the number of nice patterns that can be used to tile the yard of size N × M. Now he is interested in the long term estimation, so he suggests N ≤ 10100. However, he does not like big numbers, so he asks you to find the answer modulo P. Input The input file contains three integer numbers: N (1 ≤ N ≤ 10100), M (1 ≤ M ≤ 5) and P (1 ≤ P ≤ 10000). Output Write the number of nice patterns of size N × M modulo P to the output file. Sample test(s) Input Test #1 2 2 5 Test #2 3 3 23 Output Test #1 4 Test #2 0 import java.util.;import java.math.; public class Solution{ static int P; static Matrix pow_M(Matrix a,BigInteger n){ Matrix ret = new Matrix(); Matrix tmp = a; ret.init(a.n,P); for(int i = 0;i &lt; a.n;i++) ret.mat[i][i] = 1; while(!n.equals(BigInteger.ZERO)){ if(n.mod(BigInteger.valueOf(2)).equals(BigInteger.ONE)) ret = ret.mul(tmp); tmp = tmp.mul(tmp); n = n.divide(BigInteger.valueOf(2)); } return ret; } static boolean check(int s1,int s2,int n){ for(int i = 0;i &lt; n-1;i++){ if( (s1&amp;(1&lt;&lt;i)) == 0 &amp;&amp; (s1&amp;(1&lt;&lt;(i+1))) == 0 &amp;&amp; (s2&amp;(1&lt;&lt;i)) == 0 &amp;&amp; (s2&amp;(1&lt;&lt;(i+1))) == 0) return false; if( (s1&amp;(1&lt;&lt;i)) &gt; 0 &amp;&amp; (s1&amp;(1&lt;&lt;(i+1))) &gt; 0 &amp;&amp; (s2&amp;(1&lt;&lt;i)) &gt; 0 &amp;&amp; (s2&amp;(1&lt;&lt;(i+1))) &gt; 0) return false; } return true; } public static void main(String[] args) { // TODO Auto-generated method stub Scanner cin = new Scanner(System.in); BigInteger n; int m; while(cin.hasNext()){ n = cin.nextBigInteger(); m = cin.nextInt(); P = cin.nextInt(); Matrix a = new Matrix(); a.init(1&lt;&lt;m,P); for(int i = 0;i &lt; (1&lt;&lt;m);i++) for(int j = 0;j &lt; (1&lt;&lt;m);j++) if(check(i,j,m)) a.mat[i][j] = 1; a = pow_M(a,n.subtract(BigInteger.ONE)); int ans = 0; for(int i = 0;i &lt; (1&lt;&lt;m);i++) for(int j = 0;j &lt; (1&lt;&lt;m);j++){ ans = ans + a.mat[i][j]; ans = ans%P; } System.out.println(ans); } cin.close(); }}class Matrix{ static int P; int [][]mat = new int[100][100]; int n; void init(int _n,int _p){ n = _n; P = _p; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) mat[i][j] = 0; } Matrix mul(Matrix b){ Matrix ret = new Matrix(); ret.init(n,P); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++){ for(int k = 0;k &lt; n;k++){ ret.mat[i][j] = ret.mat[i][j] + mat[i][k]*b.mat[k][j]%P; ret.mat[i][j] %= P; } } return ret; }}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>矩阵乘法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>矩阵</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5077 NAND （2014鞍山现场赛H题，搜索打表）]]></title>
    <url>%2F2014%2F11%2F20%2Fhdu5077%2F</url>
    <content type="text"><![CDATA[胡搞，搜索+打表。 NANDTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 195 Accepted Submission(s): 61 Problem Description Xiaoqiang entered the “shortest code” challenge organized by some self-claimed astrologists. He was given a boolean function taking n inputs (in C++): bool f(bool x1, bool x2, bool x3){ //your code goes here //return something } All possible inputs and expected outputs of this function have been revealed: Xiaoqiang’s code must be like: bool a = NAND(b, c); where “a” is a newly defined variable,“b” and “c” can be a constant (0/1) or a function parameter (x1/x2/x3) or a previously defined variable. NAND is the “not-and” function: NAND(b, c)=!(b&amp;&amp;c) Because NAND is universal, Xiaoqiang knew that he could implement any boolean function he liked. Also, at the end of the code there should be a return statement: return y; where y can be a constant or a function parameter or a previously defined variable. After staring at the function for a while, Xiaoqiang came up with the answer: bool a = NAND(x1, x2); bool b = NAND(x2, x3); bool y = NAND(a, b); return y; Xiaoqiang wants to make sure that his solution is the shortest possible. Can you help him? Input The first line contains an integer T (T ≤ 20) denoting the number of the test cases. For each test case, there is one line containing 8 characters encoding the truth table of the function. Output For each test case, output a single line containing the minimum number of lines Xiaoqiang has to write. Sample Input 1 00010011 Sample Output 4 Hint Due to the small input domain, you can solve all the cases on your computer and submit a program with a table of all the answers. Source 2014 Asia AnShan Regional Contest 可以直接进行dfs. 把大部分答案打出来。 搜索策略就是纯粹的爆搜， 我是把深度现在在10以下，这样可以把答案 &lt;= 9 的数据都打出来了。 打表程序： /* ***Author :kuangbinCreated Time :2014/11/20 22:57:22File Name :E:\2014ACM\2014现场赛\鞍山\H.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int dp[1&lt;&lt;8];bool used[1&lt;&lt;8];unsigned char a[1&lt;&lt;8];int cnt;void dfs(int dep){ if(dep &gt;= 10)return; for(int i = 0;i &lt; cnt;i++) for(int j = i;j &lt; cnt;j++){ unsigned char tmp = ~(a[i]&amp;a[j]); if(used[tmp])continue; used[tmp] = true; a[cnt++] = tmp; if(dp[tmp] == -1 || dp[tmp] &gt; dep)dp[tmp] = dep; dfs(dep+1); used[tmp] = false; cnt–; }} int main(){ //freopen(“in.txt”,”r”,stdin); freopen(“out.txt”,”w”,stdout); memset(dp,-1,sizeof(dp)); cnt = 0; dp[0] = 1; dp[255] = 1; unsigned char x1 = 0x0f; unsigned char x2 = 0x33; unsigned char x3 = 0x55; dp[x1] = 1; dp[x2] = 1; dp[x3] = 1; memset(used,false,sizeof(used)); used[0] = true; used[255] = true; used[x1] = true; used[x2] = true; used[x3] = true; a[cnt++] = 0; a[cnt++] = 255; a[cnt++] = x1; a[cnt++] = x2; a[cnt++] = x3; dfs(2); for(int i = 0;i &lt; 256;i++) printf(“%d,\n”,dp[i]); return 0;} 这个程序大概几分钟就跑出来了。 然后有几个是-1，说明没有打出来，他们的答案肯定是 &gt;=10的。 然后其余几个随机吧！ 随机一发在HDU竟然一直都是AC的~~~~ /* ***Author :kuangbinCreated Time :2014/11/20 23:29:04File Name :E:\2014ACM\2014现场赛\鞍山\H2.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int dp[] = {1,5,6,3,6,3,7,4,7,8,4,5,4,5,4,1,6,3,7,4,7,4,9,7,8,8,7,5,7,5,7,4,7,8,4,5,8,8,7,5,8,9,5,6,8,8,5,5,4,5,4,1,7,5,7,4,8,8,5,5,5,7,6,4,7,8,8,8,4,5,7,5,8,9,8,8,5,6,5,5,4,5,7,5,4,1,7,4,8,8,5,7,5,5,6,4,8,9,8,8,8,8,5,7,-1,9,8,9,8,9,8,8,5,6,5,5,5,5,6,4,8,9,8,8,8,8,8,7,8,9,9,9,9,9,-1,9,5,7,6,6,6,6,7,6,9,9,-1,9,-1,9,-1,-1,7,6,7,7,7,7,9,7,5,7,6,6,7,6,7,7,5,6,2,3,6,6,4,3,6,6,7,6,7,7,9,7,6,6,4,3,7,7,7,6,5,7,7,6,6,6,7,7,5,6,6,6,2,3,4,3,6,6,7,7,7,6,9,7,6,6,7,7,4,3,7,6,5,6,6,6,6,6,7,7,8,9,5,6,5,6,2,5,2,3,4,3,4,3,7,6,5,6,2,5,2,5,4,1 }; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; char str[20]; scanf(“%d”,&amp;T); srand(time(NULL)); while(T–){ scanf(“%s”,str); int n = 0; for(int i = 0;i &lt; 8;i++){ n *= 2; n += str[i]-‘0’; } if(dp[n] != -1)printf(“%d\n”,dp[n]); else printf(“%d\n”,10+rand()%3); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>搜索</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 198. Get Out! （计算几何+SPFA）]]></title>
    <url>%2F2014%2F11%2F11%2Fsgu198%2F</url>
    <content type="text"><![CDATA[SGU198 题意就是一个圆形的船，然后有一些圆形的岛阻碍着船，问船能不能顺利出来。 做法就是把船的半径累加到岛中，这样只要判断 船的圆心，是否被一些圆包围。 可以使用SPFA去判断，有没有负环。 198. Get Out!time limit per test: 0.25 sec. memory limit per test: 65536 KB input: standard output: standard Captain Faraway on his famous circular ship Kolobok is lost among the islands of the archipelago that he has just discovered. Now he wonders whether he can get out of there. Help him! All islands in the archipelago can be composed of pieces that have circular form. You are given the map of archipelago and the position of captain. Find out whether captain can get out of there, i.e. can get as far from the point he is in the beginning as he likes. Input The first line contains N — the number of circular island parts (1 ≤ N ≤ 300). N lines follow, each containing xi, yi, ri — coordinates of center and radius of the i-th circle. All coordinates and radii are real. Objects may overlap with each other in arbitrary way. All objects are considered solid. The last line of the input file contains three real numbers — coordinates of the center of Kolobok and its radius. You may consider Kolobok to be the perfect circle and that it is in the free area in the beginning. Kolobok can move along any trajectory and is so strong that he can even touch islands, but no nonzero part of island must intersect Kolobok during his motion. You may assume that making calculations with the precision of 10-6 is satisfactory. Output Output YES if Kolobok can leave archipelago and NO if it cannot. Sample test(s) Input Test #1 7 2 2 1.1 -2 2 1.1 2 -2 1.0 -2 -2 1.0 2 -5 1.0 0 -8 1.0 -2 -6 1.0 0 0 1 Test #2 5 2 2 1.1 -2 2 1.1 2 -2 1.0 -2 -2 1.0 0 -3 0.01 0 0 1 Output Test #1 YES Test #2 NO /* ***Author :kuangbinCreated Time :2014/11/10 20:16:21File Name :D:\github\ACM-ICPC\SGU\SGU198.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const double eps = 1e-8;const int MAXN = 310;struct Circle{ double x,y,r; Circle(double _x = 0,double _y = 0,double _r = 0){ x = _x; y = _y; r = _r; } void input(){ scanf(“%lf%lf%lf”,&amp;x,&amp;y,&amp;r); } bool check(Circle b){ double d = hypot(x-b.x,y-b.y); return d &lt; r + b.r - eps; } Circle operator -(const Circle &amp;b)const{ return Circle(x-b.x,y-b.y,0); } double operator (const Circle &amp;b)const{ return x\b.x + y*b.y; } double operator ^(const Circle &amp;b)const{ return x*b.y - y*b.x; }}circle[MAXN];Circle p0;double rad(Circle a,Circle b){ return atan2((a-p0)^(b-p0),(a-p0)*(b-p0));} struct Edge{ int to,next; double w;}edge[MAXN*MAXN];int head[MAXN],tot;void init(){ tot = 0; memset(head,-1,sizeof(head));}inline void addedge(int u,int v,double w){ edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;}double dist[MAXN];bool vis[MAXN];int cnt[MAXN];bool SPFA(int n){ for(int i = 0;i &lt; n;i++){ dist[i] = 0.0; vis[i] = false; cnt[i] = 0; } queueq; for(int i = 0;i &lt; n;i++){ vis[i] = true; q.push(i); cnt[i]++; } while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; double w = edge[i].w; if(dist[u] + w &lt; dist[v] - eps){ dist[v] = dist[u] + w; if(!vis[v]){ vis[v] = true; cnt[v]++; q.push(v); if(cnt[v] &gt; n)return false; } } } } return true;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ for(int i = 0;i &lt; n;i++) circle[i].input(); p0.input(); for(int i = 0;i &lt; n;i++) circle[i].r += p0.r; init(); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(i != j){ if(circle[i].check(circle[j])) addedge(i,j,rad(circle[i],circle[j])); } if(SPFA(n))printf(“YES\n”); else printf(“NO\n”); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>SPFA</category>
        <category>图论</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>计算几何</tag>
        <tag>SGU</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 199. Beautiful People （树状数组，二维LIS）]]></title>
    <url>%2F2014%2F11%2F09%2Fsgu199%2F</url>
    <content type="text"><![CDATA[SGU199 就是二维的LIS，要输出路径。 所以第一维进行排序，第二维用树状数组去找最大值。 199. Beautiful Peopletime limit per test: 0.25 sec. memory limit per test: 65536 KB input: standard output: standard The most prestigious sports club in one city has exactly N members. Each of its members is strong and beautiful. More precisely, i-th member of this club (members being numbered by the time they entered the club) has strength Si and beauty Bi . Since this is a very prestigious club, its members are very rich and therefore extraordinary people, so they often extremely hate each other. Strictly speaking, i-th member of the club Mr X hates j-th member of the club Mr Y if Si ≤ Sj and Bi ≥ Bj or if Si ≥ Sj and Bi ≤ Bj (if both properties of Mr X are greater then corresponding properties of Mr Y, he doesn’t even notice him, on the other hand, if both of his properties are less, he respects Mr Y very much). To celebrate a new 2003 year, the administration of the club is planning to organize a party. However they are afraid that if two people who hate each other would simultaneouly attend the party, after a drink or two they would start a fight. So no two people who hate each other should be invited. On the other hand, to keep the club presti≥ at the apropriate level, administration wants to invite as many people as possible. Being the only one among administration who is not afraid of touching a computer, you are to write a program which would find out whom to invite to the party. Input The first line of the input file contains integer N — the number of members of the club. ( 2 ≤ N ≤ 100,000 ). Next N lines contain two numbers each — Si and Bi respectively ( 1 ≤ Si, Bi ≤ 109 ). Output On the first line of the output file print the maximum number of the people that can be invited to the party. On the second line output N integers — numbers of members to be invited in arbitrary order. If several solutions exist, output any one. Sample test(s) Input 4 1 1 1 2 2 1 2 2 Output 2 1 4 [submit] /* ***Author :kuangbinCreated Time :2014/11/4 11:37:23File Name :E:\2014ACM\SGU\SGU199.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;int dp[MAXN];int c[MAXN];int cnt;int lowbit(int x){ return x&amp;(-x);}void add(int x,int id){ int i = x; while(i &lt;= cnt){ if(dp[id] &gt; dp[c[i]]) c[i] = id; i += lowbit(i); }}int query(int i){ int ret = 0; while(i &gt; 0){ if(dp[c[i]] &gt; dp[ret])ret = c[i]; i -=lowbit(i); } return ret;}struct Node{ int x,y; int index; bool operator &lt;(const Node &amp;b)const{ return x &lt; b.x || (x == b.x &amp;&amp; y &lt; b.y); }}node[MAXN];int yy[MAXN];int pre[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ cnt = 0; for(int i = 1;i &lt;= n;i++){ scanf(“%d%d”,&amp;node[i].x,&amp;node[i].y); node[i].index = i; yy[++cnt] = node[i].y; } sort(node+1,node+n+1); sort(yy+1,yy+cnt+1); cnt = unique(yy+1,yy+cnt+1) - yy - 1; map&lt;int,int&gt;mp; for(int i = 1;i &lt;= cnt;i++)mp[yy[i]] = i; for(int i = 1;i &lt;= n;i++) node[i].y = mp[node[i].y]; memset(c,0,sizeof(c)); memset(dp,0,sizeof(dp)); int id = 1; for(int i = 1;i &lt;= n;i++){ while(node[id].x != node[i].x){ add(node[id].y,id); id++; } int tmp = query(node[i].y-1); dp[i] = dp[tmp] + 1; pre[i] = tmp; } int now = 0; for(int i = 1;i &lt;= n;i++) if(dp[i] &gt; dp[now]) now = i; vectorans; while(now){ ans.push_back(node[now].index); now = pre[now]; } reverse(ans.begin(),ans.end()); int sz = ans.size(); printf(“%d\n”,sz); for(int i = 0;i &lt; sz;i++){ printf(“%d”,ans[i]); if(i &lt; sz-1)printf(“ “); else printf(“\n”); } } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>树状数组</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5071 Chat （2014鞍山赛区B题，简单模拟）]]></title>
    <url>%2F2014%2F10%2F31%2Fhdu5071%2F</url>
    <content type="text"><![CDATA[HDU5071 简单模拟。 读懂题还是比较好写的，很简单。 注意一些坑点，最后一段话要理解，先bye 在顶上的。 用long long 安全点。 ChatTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 1142 Accepted Submission(s): 260 Problem Description As everyone knows, DRD has no girlfriends. But as everyone also knows, DRD’s friend ATM’s friend CLJ has many potential girlfriends. One evidence is CLJ’s chatting record. CLJ chats with many girls all the time. Sometimes he begins a new conversation and sometimes he ends a conversation. Sometimes he chats with the girl whose window is on the top. You can imagine CLJ’s windows as a queue. The first girl in the queue is the top girl if no one is “always on top ”. Since CLJ is so popular, he begins to assign a unique positive integer as priority for every girl. The higher priority a girl has, the more CLJ likes her. For example, GYZ has priority 109, and JZP has priority 108 while Sister Soup has priority 1, and Face Face has priority 2. As a famous programmer, CLJ leads a group to implement his own WM(window manager). The WM will log CLJ’s operations. Now you are supposed to implement the log system. The general logging format is “Operation #X: LOGMSG.”, where X is the number of the operation and LOGMSG is the logging message. There are several kinds of operations CLJ may use: 1.Add u: CLJ opens a new window whose priority is u, and the new window will be the last window in the window queue. This operation will always be successful except the only case in which there is already a window with priority u. If it is successful, LOGMSG will be “success”. Otherwise LOGMSG will be “same priority”. 2.Close u: CLJ closes a window whose priority is u. If there exists such a window, the operation will be successful and LOGMSG will be “close u with c”, where u is the priority and c is the number of words CLJ has spoken to this window. Otherwise, LOGMSG will be “invalid priority”. Note that ANY window can be closed. 3.Chat w: CLJ chats with the top window, and he speaks w words. The top window is the first window in the queue, or the “always on top” window (as described below) instead if there exists. If no window is in the queue, LOGMSG will be “empty”, otherwise the operation can be successful and LOGMSG will be “success”. 4.Rotate x: CLJ performs one or more Alt-Tabs to move the x-th window to the first one in the queue. For example, if there are 4 windows in the queue, whose priorities are 1, 3, 5, 7 respectively and CLJ performs “Rotate 3”, then the window’s priorities in the queue will become 5, 1, 3, 7. Note that if CLJ wants to move the first window to the head, this operation is still considered “successful”. If x is out of range (smaller than 1 or larger than the size of the queue), LOGMSG will be “out of range”. Otherwise LOGMSG should be “success”. 5.Prior: CLJ finds out the girl with the maximum priority and then moves the window to the head of the queue. Note that if the girl with the maximum priority is already the first window, this operation is considered successful as well. If the window queue is empty, this operation will fail and LOGMSG must be “empty”. If it is successful, LOGMSG must be “success”. 6.Choose u: CLJ chooses the girl with priority u and moves the window to the head of the queue.This operation is considered successful if and only if the window with priority u exists. LOGMSG for the successful cases should be “success” and for the other cases should be “invalid priority”. 7.Top u: CLJ makes the window of the girl with priority u always on top. Always on top is a special state, which means whoever the first girl in the queue is, the top one must be u if u is always on top. As you can see, two girls cannot be always on top at the same time, so if one girl is always on top while CLJ wants another always on top, the first will be not always on top any more, except the two girls are the same one. Anyone can be always on top. LOGMSG is the same as that of the Choose operation. 8.Untop: CLJ cancels the “always on top” state of the girl who is always on top. That is, the girl who is always on top now is not in this special state any more. This operation will fail unless there is one girl always on top. If it fails, LOGMSG should be “no such person”, otherwise should be “success”. As a gentleman, CLJ will say goodbye to every active window he has ever spoken to at last, “active” here means the window has not been closed so far. The logging format is “Bye u: c” where u is the priority and c is the number of words he has ever spoken to this window. He will always say good bye to the current top girl if he has spoken to her before he closes it. Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases. For each test case, the first line contains an integer n(0 &lt; n ≤ 5000), representing the number of operations. Then follow n operations, one in a line. All the parameters are positive integers below 109. Output Output all the logging contents. Sample Input 1 18 Prior Add 1 Chat 1 Add 2 Chat 2 Top 2 Chat 3 Untop Chat 4 Choose 2 Chat 5 Rotate 2 Chat 4 Close 2 Add 3 Prior Chat 2 Close 1 Sample Output Operation #1: empty. Operation #2: success. Operation #3: success. Operation #4: success. Operation #5: success. Operation #6: success. Operation #7: success. Operation #8: success. Operation #9: success. Operation #10: success. Operation #11: success. Operation #12: success. Operation #13: success. Operation #14: close 2 with 8. Operation #15: success. Operation #16: success. Operation #17: success. Operation #18: close 1 with 11. Bye 3: 2 Hint This problem description does not relate to any real person in THU. Source 2014 Asia AnShan Regional Contest /* ***Author :kuangbinCreated Time :2014/10/31 22:46:39File Name :E:\2014ACM\2014现场赛\鞍山\B.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int sta[5010];int cnt;int top;int index;map&lt;int,long long&gt;mp;void gao1(int u){ for(int i = 1;i &lt;= cnt;i++) if(sta[i] == u){ printf(“Operation #%d: same priority.\n”,index); return; } printf(“Operation #%d: success.\n”,index); sta[++cnt] = u; mp[u] = 0;}void gao2(int u){ for(int i = 1;i &lt;= cnt;i++) if(sta[i] == u){ if(top != -1){ if(top == u){ top = -1; } } for(int j = i;j &lt; cnt;j++)sta[j] = sta[j+1]; cnt–; printf(“Operation #%d: close %d with %I64d.\n”,index,u,mp[u]); return; } printf(“Operation #%d: invalid priority.\n”,index);}void gao3(int w){ if(cnt == 0){ printf(“Operation #%d: empty.\n”,index); return; } if(top != -1)mp[top] += w; else mp[sta[1]] += w; printf(“Operation #%d: success.\n”,index);}void gao4(int x){ if(x &lt; 1 || x &gt; cnt){ printf(“Operation #%d: out of range.\n”,index); return; } int tmp = sta[x]; for(int i = x;i &gt; 1;i–)sta[i] = sta[i-1]; sta[1] = tmp; printf(“Operation #%d: success.\n”,index);}void gao5(){ if(cnt == 0){ printf(“Operation #%d: empty.\n”,index); return; } int id = 1; for(int i = 1;i &lt;= cnt;i++) if(sta[i] &gt; sta[id]) id = i; gao4(id);}void gao6(int u){ for(int i = 1;i &lt;= cnt;i++) if(sta[i] == u){ gao4(i); return; } printf(“Operation #%d: invalid priority.\n”,index);}void gao7(int u){ for(int i = 1;i &lt;= cnt;i++) if(sta[i] == u){ top = u; printf(“Operation #%d: success.\n”,index); return; } printf(“Operation #%d: invalid priority.\n”,index);}void gao8(){ if(top != -1){ top = -1; printf(“Operation #%d: success.\n”,index); } else printf(“Operation #%d: no such person.\n”,index);} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); while(T–){ scanf(“%d”,&amp;n); cnt = 0; top = -1; mp.clear(); char op[20]; int u; for(index = 1;index &lt;= n;index++){ scanf(“%s”,op); if(strcmp(op,”Add”) == 0){ scanf(“%d”,&amp;u); gao1(u); } else if(strcmp(op,”Close”) == 0){ scanf(“%d”,&amp;u); gao2(u); } else if(strcmp(op,”Chat”) == 0){ scanf(“%d”,&amp;u); gao3(u); } else if(strcmp(op,”Rotate”) == 0){ scanf(“%d”,&amp;u); gao4(u); } else if(strcmp(op,”Prior”) == 0){ gao5(); } else if(strcmp(op,”Choose”) == 0){ scanf(“%d”,&amp;u); gao6(u); } else if(strcmp(op,”Top”) == 0){ scanf(“%d”,&amp;u); gao7(u); } else gao8(); } if(top != -1 &amp;&amp; mp[top]) printf(“Bye %d: %I64d\n”,top,mp[top]); for(int i = 1;i &lt;= cnt;i++) if(sta[i] != top &amp;&amp; mp[sta[i]]) printf(“Bye %d: %I64d\n”,sta[i],mp[sta[i]]); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>水题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5072 Coprime （2014鞍山赛区C题，容斥）]]></title>
    <url>%2F2014%2F10%2F31%2Fhdu5072%2F</url>
    <content type="text"><![CDATA[HDU5072 给了n个不同的数，要求有多少个三元组，两两互质 或者 两两不互质。 模型请参考 《算法竞赛入门经典 训练指南》 p105 问题6 （训练指南真的是神书啊，多次区域赛都有类似题了，卧槽） 现场的时候明显想复杂了，用了复杂方法搞。 其实从方面考虑。 直接对每个数，求有多少个和它互质的，多少个和它不互质的， 相乘累加。。 就是反面的2倍了。 至于如何求有多少个互质的，直接质因数分解，然后容斥就可以了。 HDU 时限有点紧， 现场可以随便搞！ CoprimeTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 556 Accepted Submission(s): 254 Problem Description There are n people standing in a line. Each of them has a unique id number. Now the Ragnarok is coming. We should choose 3 people to defend the evil. As a group, the 3 people should be able to communicate. They are able to communicate if and only if their id numbers are pairwise coprime or pairwise not coprime. In other words, if their id numbers are a, b, c, then they can communicate if and only if [(a, b) = (b, c) = (a, c) = 1] or [(a, b) ≠ 1 and (a, c) ≠ 1 and (b, c) ≠ 1], where (x, y) denotes the greatest common divisor of x and y. We want to know how many 3-people-groups can be chosen from the n people. Input The first line contains an integer T (T ≤ 5), denoting the number of the test cases. For each test case, the first line contains an integer n(3 ≤ n ≤ 105), denoting the number of people. The next line contains n distinct integers a1, a2, . . . , an(1 ≤ ai ≤ 105) separated by a single space, where ai stands for the id number of the i-th person. Output For each test case, output the answer in a line. Sample Input 1 5 1 3 9 10 2 Sample Output 4 Source 2014 Asia AnShan Regional Contest /* ***Author :kuangbinCreated Time :2014/10/30 12:20:43File Name :E:\2014ACM\2014现场赛\鞍山\C.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100000;int prime[MAXN+1];void getPrime(){ memset(prime,0,sizeof(prime)); for(int i = 2;i &lt;= MAXN;i++){ if(!prime[i])prime[++prime[0]] = i; for(int j = 1;j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN/i;j++){ prime[prime[j]*i] = 1; if(i%prime[j] == 0)break; } }}int factor[100][2];int fatCnt;inline int getFactor(int x){ fatCnt = 0; for(int i = 1;prime[i] &lt;= x/prime[i];i++) if(x%prime[i] == 0){ factor[fatCnt][0] = prime[i]; factor[fatCnt][1] = 0; while(x%prime[i] == 0){ factor[fatCnt][1]++; x /= prime[i]; } fatCnt++; } if(x != 1){ factor[fatCnt][0] = x; factor[fatCnt++][1] = 1; } return fatCnt;}int a[100010];int num[100010];int two[20]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); two[0] = 1; for(int i = 1;i &lt; 20;i++) two[i] = two[i-1]&lt;&lt;1; getPrime(); while(T–){ scanf(“%d”,&amp;n); memset(num,0,sizeof(num)); for(int i = 0;i &lt; n;i++){ scanf(“%d”,&amp;a[i]); getFactor(a[i]); for(int j = 0;j &lt; two[fatCnt];j++){ int tmp = 1; for(int k = 0;k &lt; fatCnt;k++) if(j&amp;two[k]){ tmp = factor[k][0]; } num[tmp]++; } } long long ret = 0; for(int i = 0;i &lt; n;i++){ getFactor(a[i]); int cc = 0; for(int j = 0;j &lt; two[fatCnt];j++){ int tmp = 1; int cnt = 0; for(int k = 0;k &lt; fatCnt;k++) if(j&amp;two[k]){ cnt++; tmp = factor[k][0]; } if(cnt&amp;1)cc -= num[tmp]; else cc += num[tmp]; } if(a[i] == 1)cc–; ret += (long long)cc(n-1-cc); } long long tot = (long long)n(n-1)*(n-2)/6; printf(“%I64d\n”,tot-ret/2); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>数学题</category>
        <category>数论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5073 Galaxy （2014鞍山赛区D题，暴力）]]></title>
    <url>%2F2014%2F10%2F22%2Fhdu5073%2F</url>
    <content type="text"><![CDATA[HDU5073 水题。维护和以及平方和就可以了。 GalaxyTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 505 Accepted Submission(s): 109 Special Judge Problem Description Good news for us: to release the financial pressure, the government started selling galaxies and we can buy them from now on! The first one who bought a galaxy was Tianming Yun and he gave it to Xin Cheng as a present. To be fashionable, DRD also bought himself a galaxy. He named it Rho Galaxy. There are n stars in Rho Galaxy, and they have the same weight, namely one unit weight, and a negligible volume. They initially lie in a line rotating around their center of mass. Everything runs well except one thing. DRD thinks that the galaxy rotates too slow. As we know, to increase the angular speed with the same angular momentum, we have to decrease the moment of inertia. The moment of inertia I of a set of n stars can be calculated with the formula where wi is the weight of star i, di is the distance form star i to the mass of center. As DRD’s friend, ATM, who bought M78 Galaxy, wants to help him. ATM creates some black holes and white holes so that he can transport stars in a negligible time. After transportation, the n stars will also rotate around their new center of mass. Due to financial pressure, ATM can only transport at most k stars. Since volumes of the stars are negligible, two or more stars can be transported to the same position. Now, you are supposed to calculate the minimum moment of inertia after transportation. Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases. For each test case, the first line contains two integers, n(1 ≤ n ≤ 50000) and k(0 ≤ k ≤ n), as mentioned above. The next line contains n integers representing the positions of the stars. The absolute values of positions will be no more than 50000. Output For each test case, output one real number in one line representing the minimum moment of inertia. Your answer will be considered correct if and only if its absolute or relative error is less than 1e-9. Sample Input 2 3 2 -1 0 1 4 2 -2 -1 1 2 Sample Output 0 0.5 Source 2014 Asia AnShan Regional Contest /* ***Author :kuangbinCreated Time :2014/10/22 23:20:07File Name :E:\2014ACM\2014现场赛\鞍山\D.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;double x[50010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,k; scanf(“%d”,&amp;T); while(T–){ scanf(“%d%d”,&amp;n,&amp;k); for(int i = 0;i &lt; n;i++) scanf(“%lf”,&amp;x[i]); sort(x,x+n); if(n == k){ printf(“0\n”); continue; } int cnt = n-k; double sum = 0; double sum2 = 0; for(int i = 0;i &lt; cnt;i++){ sum += x[i]; sum2 += x[i]x[i]; } double ans = sum2 - 2\sum*(sum/cnt) + cnt(sum/cnt)(sum/cnt); for(int i = cnt;i &lt; n;i++){ sum += x[i]; sum2 += x[i]x[i]; sum -= x[i-cnt]; sum2 -= x[i-cnt]x[i-cnt]; ans = min(ans,sum2-2*sum*(sum/cnt)+cnt(sum/cnt)(sum/cnt)); } printf(“%.10lf\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>水题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5074 Hatsune Miku （2014鞍山赛区E题，DP）]]></title>
    <url>%2F2014%2F10%2F22%2Fhdu5074%2F</url>
    <content type="text"><![CDATA[HDU5074 直接暴力DP。 Hatsune MikuTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 91 Accepted Submission(s): 69 Problem Description Hatsune Miku is a popular virtual singer. It is very popular in both Japan and China. Basically it is a computer software that allows you to compose a song on your own using the vocal package. Today you want to compose a song, which is just a sequence of notes. There are only m different notes provided in the package. And you want to make a song with n notes. Also, you know that there is a system to evaluate the beautifulness of a song. For each two consecutive notes a and b, if b comes after a, then the beautifulness for these two notes is evaluated as score(a, b). So the total beautifulness for a song consisting of notes a1, a2, . . . , an, is simply the sum of score(ai, ai+1) for 1 ≤ i ≤ n - 1. Now, you find that at some positions, the notes have to be some specific ones, but at other positions you can decide what notes to use. You want to maximize your song’s beautifulness. What is the maximum beautifulness you can achieve? Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases. For each test case, the first line contains two integers n(1 ≤ n ≤ 100) and m(1 ≤ m ≤ 50) as mentioned above. Then m lines follow, each of them consisting of m space-separated integers, the j-th integer in the i-th line for score(i, j)( 0 ≤ score(i, j) ≤ 100). The next line contains n integers, a1, a2, . . . , an (-1 ≤ ai ≤ m, ai ≠ 0), where positive integers stand for the notes you cannot change, while negative integers are what you can replace with arbitrary notes. The notes are named from 1 to m. Output For each test case, output the answer in one line. Sample Input 2 5 3 83 86 77 15 93 35 86 92 49 3 3 3 1 2 10 5 36 11 68 67 29 82 30 62 23 67 35 29 2 22 58 69 67 93 56 11 42 29 73 21 19 -1 -1 5 -1 4 -1 -1 -1 4 -1 Sample Output 270 625 Source 2014 Asia AnShan Regional Contest /* ***Author :kuangbinCreated Time :2014/10/22 23:08:11File Name :E:\2014ACM\2014现场赛\鞍山\E.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int a[100][100];int dp[110][55];int b[110]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,m; scanf(“%d”,&amp;T); while(T–){ scanf(“%d%d”,&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++) for(int j = 1;j &lt;= m;j++) scanf(“%d”,&amp;a[i][j]); memset(dp,-1,sizeof(dp)); for(int i = 1;i &lt;= n;i++)scanf(“%d”,&amp;b[i]); for(int i = 1;i &lt;= m;i++) dp[1][i] = 0; int ans = -1; for(int i = 1;i &lt;= n;i++){ for(int j = 1;j &lt;= m;j++){ if(b[i] &gt; 0 &amp;&amp; j != b[i]) dp[i][j] = -1; if(dp[i][j] == -1)continue; if(i == n){ ans = max(ans,dp[i][j]); continue; } for(int k = 1;k &lt;= m;k++) dp[i+1][k] = max(dp[i+1][k],dp[i][j]+a[j][k]); } } printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5078 Osu! （2014鞍山赛区I题，水题）]]></title>
    <url>%2F2014%2F10%2F22%2Fhdu5078%2F</url>
    <content type="text"><![CDATA[HDU5078 纯粹贴个水题！ Osu!Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 103 Accepted Submission(s): 69 Special Judge Problem Description Osu! is a very popular music game. Basically, it is a game about clicking. Some points will appear on the screen at some time, and you have to click them at a correct time. Now, you want to write an algorithm to estimate how diffecult a game is. To simplify the things, in a game consisting of N points, point i will occur at time ti at place (xi, yi), and you should click it exactly at ti at (xi, yi). That means you should move your cursor from point i to point i+1. This movement is called a jump, and the difficulty of a jump is just the distance between point i and point i+1 divided by the time between ti and ti+1. And the difficulty of a game is simply the difficulty of the most difficult jump in the game. Now, given a description of a game, please calculate its difficulty. Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases.For each test case, the first line contains an integer N (2 ≤ N ≤ 1000) denoting the number of the points in the game. Then N lines follow, the i-th line consisting of 3 space-separated integers, ti(0 ≤ ti &lt; ti+1 ≤ 106), xi, and yi (0 ≤ xi, yi ≤ 106) as mentioned above. Output For each test case, output the answer in one line.Your answer will be considered correct if and only if its absolute or relative error is less than 1e-9. Sample Input 2 5 2 1 9 3 7 2 5 9 0 6 6 3 7 6 0 10 11 35 67 23 2 29 29 58 22 30 67 69 36 56 93 62 42 11 67 73 29 68 19 21 72 37 84 82 24 98 Sample Output 9.2195444573 54.5893762558 Hint In memory of the best osu! player ever Cookiezi. Source 2014 Asia AnShan Regional Contest 手速还是不够快！ /* ***Author :kuangbinCreated Time :2014/10/22 22:59:21File Name :E:\2014ACM\2014现场赛\鞍山\I.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;struct Node{ double t,x,y; void input(){ scanf(“%lf%lf%lf”,&amp;t,&amp;x,&amp;y); } double calc(Node b){ return hypot(x-b.x,y-b.y)/(b.t-t); }}node[1010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); while(T–){ scanf(“%d”,&amp;n); for(int i = 0;i &lt; n;i++)node[i].input(); double ans = -1.0; for(int i = 0;i &lt; n-1;i++) ans = max(ans,node[i].calc(node[i+1])); printf(“%.10lf\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>水题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5080 Colorful Toy （2014鞍山赛区K题，简单几何+polya）]]></title>
    <url>%2F2014%2F10%2F22%2Fhdu5080%2F</url>
    <content type="text"><![CDATA[HDU5080 简单题，主要是暴力搞出置换群有哪几个，然后polya计数。 Colorful ToyTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 30 Accepted Submission(s): 11 Problem Description A toy is made up of N vertices and M undirected edges in the 2D plane. As usual, you want to know how many ways there are to color the vertices of the toy. You have totally C colors. And of course, to make things fun, you think that if one color configuration can be rotated to get another, these two configurations should be considered the same. Rotation means 2D in-plane rotation and reflection is not considered as rotation. For instance, consider coloring the following toy with 2 colors. The coordinates of the vertices are: 1. (0,0) 2. (1,0) 3. (0,1) 4. (-1,0) 5. (0,-1) The toy has 6 edges: (1,2), (1,3), (2,3), (3,4), (4,5), (5,2). As a 2D being, this toy has no symmetry. So there are 32 ways to color it. Had the first two edges been removed, there would be only 12 different ways. You should output the answer modulo 109 + 7. Input The first line contains an integer T (T ≤ 20) denoting the number of the test cases. Each test case begins with three positive integers N (1 ≤ N ≤ 50), M (0 ≤ M ≤ N (N - 1)/2) and C(1 ≤ C ≤ 100). Then follow N lines. Each line contains 2 integers in range [-10000,10000] describing a vertex. Then follow M lines. Each line contains 2 integers in range [1,N] representing an edge. There are neither duplicate edges nor self-loops. Output For each test case, output one line containing the answer. Sample Input 2 5 6 2 0 0 1 0 0 1 -1 0 0 -1 1 2 1 3 2 3 3 4 4 5 5 2 5 4 2 0 0 1 0 0 1 -1 0 0 -1 2 3 3 4 4 5 5 2 Sample Output 32 12 Source 2014 Asia AnShan Regional Contest 虽然说旋转的角度是90度的倍数，但是我没有管这个。 我就是粗暴的计算几何的方法进行搞！ 先求平均值，确定中心。 如果和中心重合的点，另外搞出来，其余的点按照极角排序，然后角度相同，按照距离排序。 然后变换的时候肯定是递推过去的。 然后进行判断，一个是判断点可以重合，一个是判断边。 然后就搞定了。 /* ***Author :kuangbinCreated Time :2014/10/22 21:46:23File Name :E:\2014ACM\2014现场赛\鞍山\K.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const double eps = 1e-8;int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;}struct Point{ double x,y; double alph; Point(double _x = 0,double _y = 0){ x = _x; y = _y; } void input(){ scanf(“%lf%lf”,&amp;x,&amp;y); } bool operator ==(Point b)const{ return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0; } Point operator -(const Point &amp;b)const{ return Point(x-b.x,y-b.y); } double distance(Point p){ return hypot(x-p.x,y-p.y); } Point rotate(Point p,double angle){ Point v = (this) - p; double c = cos(angle), s = sin(angle); return Point(p.x+v.x\c-v.y*s,p.y+v.x*s+v.y*c); }};long long inv(long long a,long long m){ if(a == 1)return 1; return inv(m%a,m)(m-m/a)%m;}const int MOD = 1e9+7;long long pow_m(long long a,long long n){ long long ret = 1; long long tmp = a%MOD; while(n){ if(n&amp;1)ret = rettmp%MOD; tmp = tmp*tmp%MOD; n &gt;&gt;= 1; } return ret;}Point p[100];Point center;int n;int g[55][55];vectorV;bool cmp(int i,int j){ if(sgn(p[i].alph - p[j].alph) != 0) return p[i].alph &lt; p[j].alph; else return center.distance(p[i]) &lt; center.distance(p[j]);}int link[55];bool check1(){ double jiao = p[link[V[0]]].alph - p[V[0]].alph; int sz = V.size(); for(int i = 0;i &lt; sz;i++){ Point tmp = p[V[i]].rotate(center,jiao); if(tmp == p[link[V[i]]])continue; return false; } return true;}bool check2(){ for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(g[i][j] != g[link[i]][link[j]]) return false; return true;}bool used[100];int calc(){ int cnt = 0; memset(used,false,sizeof(used)); for(int i = 0;i &lt; n;i++) if(!used[i]){ cnt++; int tmp = i; while(!used[tmp]){ used[tmp] = true; tmp = link[tmp]; } } return cnt;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int m,C; scanf(“%d”,&amp;T); while(T–){ scanf(“%d%d%d”,&amp;n,&amp;m,&amp;C); for(int i = 0;i &lt; n;i++) p[i].input(); int u,v; memset(g,0,sizeof(g)); while(m–){ scanf(“%d%d”,&amp;u,&amp;v); u–; v–; g[u][v] = g[v][u] = 1; } if(n == 1){ printf(“%d\n”,C); continue; } center.x = 0; center.y = 0; for(int i = 0;i &lt; n;i++){ center.x += p[i].x; center.y += p[i].y; } center.x /= n; center.y /= n; V.clear(); for(int i = 0;i &lt; n;i++){ if(p[i] == center){ link[i] = i; continue; } V.push_back(i); p[i].alph = atan2(p[i].y-center.y,p[i].x-center.x); } sort(V.begin(),V.end(),cmp); long long ans = 0; int cnt = 0; int sz = V.size(); for(int i = 0;i &lt; sz;i++){ for(int j = 0;j &lt; sz;j++) link[V[j]] = V[(j+i)%sz]; if(!check1())continue; if(!check2())continue; ans += pow_m(C,calc()); ans %= MOD; cnt++; } ans = ans*inv(cnt,MOD)%MOD; printf(“%d\n”,(int)ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>数学题</category>
        <category>数论</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>计算几何</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014区域赛小结（牡丹江&&鞍山）]]></title>
    <url>%2F2014%2F10%2F20%2F2014regional%2F</url>
    <content type="text"><![CDATA[最后的两场区域赛结束了！ ICPC生涯的最后两场区域赛，选择了前两个赛区——牡丹江和鞍山，主要是时间比较靠前，而且我向来对东北赛区有特殊的偏好，我打过的区域赛几乎都是在东北（除了第一年打酱油的时候）。 而且特别想回到牡丹江去，在那个曾经打过比赛的地方再打一次比赛，拿回自己想要的。 而且今年岐哥也要打前两场，所以就选择了前两个赛区和岐哥一起打退役赛！ 两场比赛采用队名——Final_Battle (最后一战)，决心背水一战，认真打完两场退役赛！ 牡丹江时候状态低迷，卡个水题结束了第一战！发现了最大的问题就是卡题，一卡题全场奔溃！ 牡丹江回来后，痛定思痛，恢复了一周，然后最后一场鞍山站，决心背水一战，然后勉强还算比较顺利，没怎么卡题，紧紧跟着榜！封榜后成功A了两题，华丽翻盘，收获第一金，斩获一个亚军，圆满退役！ 先记录下两个赛站的流水账： 牡丹江： 周五从上海飞到了哈尔滨，然后机场直接坐大巴去了牡丹江。 到牡丹江就已经是晚上了，去牡丹江师范学院吃了一顿自助餐，感觉很棒！然后去酒店休息了。 周六上午随便逛了下，中午又是自助餐，然后下午是开幕式+热身赛。 热身赛随便水了一发，乱测一番。晚上又是吃自助餐，然后就滚回来休息了，可能是前面几天都起得太早了，然后在牡丹江也起得好早，睡不着~ 周日正式比赛。 开场后，哥的vim环境都没配好，对面的一个妹纸开始敲A了，卧槽，仰慕！ 弄好队友开始写A了， 然后读题的时候有队伍过I，我去看了下，求信息熵的水题，然后去交换着写I， A过了不久我也过了I。 然后搞D题，一个概率题， 然后乱想一番，终于搞定做法，DP一下，在一个小时的时候写过了D吧。 然后就开始陷入窘境。 连看好几题，毫无思路。 然后电脑给队友写H的模拟。 之后B，K过了一大片，然后一直想K，K感觉就是各种乱搞，但是智商明显感觉不够了。 然后想K的过程，明显感觉自己今天完全不在状态，各种讨论K之后，想了一个错误的贪心，然后写K，然后就是一直WA了~~~~ 然后这个状态持续了2个多小时，我们一直是3题。 那个时候很慌张，感觉再这样下去银牌都不保，何谈夺金！ 幸好过了段时间队友把H写过了，然后K还是继续WA，完全想错了。 快封榜的时候看了下形势，6题的已经好几个了，过B和K的很多，其余题几乎没有队过。 然后突然想到一个B的做法，把K丢给了队友去写了，我改写B去了，写到一半给队友写K，然后终于过了K， 然后继续写B， 然后有几个地方没写好，各种调试。 最后提交，WA好几次，RE好几次，卧槽！爆栈了，没时间改了，然后就是结束了。 然后牡丹江赛区一个银牌惨淡收场！ 感觉牡丹江场的题完全不适合我，智商碾压，不得不服。同时祝贺xiaodao和wuyiqi均在牡丹江夺金！ 然后周一便坐火车去哈尔滨，然后滚回上海了。 回到上海，调整了正常的作息时间，要避免在赛前休息不好！ 然后一方面忙好其他事情的同时，练了一些题目，来找回自己的状态！ 找 数学lover 巨巨单挑了几场训练赛，来找感觉，特别感觉数一巨巨陪本弱比赛！ 以及岛娘给我的几个神题。 鞍山： 周五出发去的鞍山，去鞍山是飞机直接从上海到达的了，相对而言时间不会很紧。到了鞍山，住进了坑爹的沈铁千山疗养院，竟然有虫子，还各种不干净，被子有怪味道。 疗养院附近找了一家饭店吃个饭，感觉不错。 然后晚上就回来玩了，本来要去那里所谓的温泉的，去看了发现又被坑了，根本没温泉。 不知道是去那吹到风了，还是因为吃了那边的食物，或者住的地方影响，那天开始就一直嗓子疼，感觉马上就要感冒了。 周六在疗养院吃早餐，报道。早餐也真是够坑的，啥都没有。 然后中午在那吃了个自助餐，感觉不错。 然后就开始退掉了疗养院，搬到辽宁科技大学附近去住了。 然后是热身赛，好像是原题，但是我也只会做一题，C题虽然大致知道怎么搞，但是有个容斥的地方搞错，直接导致复杂度超大，啪啪啪写了一大堆代码。 热身赛就攒一些RP吧，照常进行了一些测试，感觉电脑速度一般，没有牡丹江的快，但也不慢。 然后热身赛就结束了，吃个晚饭，晚上回到住的地方，打了一发BC，水水群就睡觉了。 周日是最后一场正式赛的时候了，早上起来喝了几瓶红牛，吃完早餐就去赛场比赛了。 比赛前，再次想了下不能卡题了，而且按照岛娘的教导“紧紧跟榜，不抢FB”。 开场前看了下气球颜色，上来我配好电脑，就首先看的I，果然是水题，确认下题意开始写，刚开始写果然有些紧张，然后5min 1Y。 然后E题很快有人过了，过的速度很快应该是水题，就交给队友去看了，自己开始看其他题，然后E 26min 1Y了。 紧接着D的FB被抢了，回去又看了一眼D，终于看懂，发现是水题。 然后我就去写D了，48min 1Y了D。 然后看到C有人做出来，继续想C。 期间很长时间没有新的题目被做出了。 发现旁边的电子科技大学的好像在写B吧，然后让队友去看B，好像是模拟，队友就开始写B的模拟了，反正我是一般情况下都不会去写模拟题的。 期间C做出的越来越多，我还一直没想到比较好的做法。 这个状态持续了比较长的时间。 又想起了牡丹江在第四题卡死，历史总是惊人的相似，感觉好可怕！ 为了避免再卡C，我想了种 比较麻烦的方法，各种容斥结合一起放大招解决胡搞一下C。然后我先来写C了， 拿出模板，把需要的模板都敲上去，然后各种容斥联合求解，写了好长一段代码。 调试了一段时间把一些错误都纠正过来，勉强可以过样例， 暴力对拍了一组数据，感觉问题不大，然后提交了， 161 min 1Y了C，感觉C做得太艰难了。 这段时间排名回到了第十左右。 然后看了下形势，B和K有过的，其余题都还没人过，还有2个多小时，决定让队友都去先搞B了，我去看K去了。 发现K其实不难，而且是我很喜欢的类型，算法很明确，只要我啪啪啪把模板敲上去就差不多了。 然后队友交B WA了，我开始写K了，把简单的几何模板敲上去，期间换队友改了几发B，队友在217min把B题AC了。 然后我继续写K，队友好像在看H，感觉此时写代码状态还是比较好的，各种细节都考虑到了，封榜前把样例调出来了，出了数据也是正确的，为了保险期间稍微检查了下，然后封榜后提交了K，然后246 min 1Y了K题。 此时6题应该是比较靠前的了，金是没有问题了，而且也应该可以学校前10顺利出线了。 最后的时间给队友们搞H。 我这个时候就稍微看看别的题目的题意，只是感觉此时我的体力几乎耗完了，写C确实耗费了我太大的元气。 然后看队友写H， 我也没怎么想H，好像就是在打表随机搞吧。 围观周围队伍的过题情况，没发现有新的题。 然后时间慢慢过去，临近结束前队友把H过掉了，真是太棒了。 然后7题结束，结束前为了纪念最后一场regional,把每个题都提交了一遍。 结束后据说7题的队伍只有两个，然后我们就意外的捧杯了。 然后去参加颁奖，领到了亚军奖杯。上海大学第一块金牌，首次捧杯！ 同时祝贺wuyiqi再次在鞍山斩获金牌。 之后收到了各方的祝贺，非常感谢大家在赛前的鼓励，你们的支持是我最大的动力。岛娘一直在带领我刷神题，教我神奇的技能，一直鼓励着我。 今年的两场区域赛算是结束了。总算是可以退役了。一银一金，也算是圆满结束了。 感觉acm这一路走来，真是太不容易了。这其中的辛酸只有自己才知道。 如果最后一场比赛再没有拿金，真的会面临巨大的压力，将会遗憾退役，各种被D。 从上年长春站银牌第一，再到牡丹江时候惨败拿银，鞍山真是背水一战，再不拿金，就再也没有机会了。 对于弱校，金牌是一件想都不敢想的事情，拿块银就已经是不错的成绩了。 当年我开始搞acm的时候，只会C的一点基本语法，A+B都不会，那个时候就被下一届的虐了，大家都已经很厉害了，那个时候各种被D。转眼三年半过去了，这过程中同一届的以及下一届的早就退役了，而我却还在，我感觉自己总是比别人慢了一大拍。 对于一个非计算机专业的来说，一直在参赛也确实让很多人不解。对于外界的各种质疑，以及各种实际情况，我一直在思考弱者为何而战！ 每一天，白天要去忙碌各种其他的事情，然后中午回寝室休息的时候会写写代码，晚上回来也是默默地写代码刷题。以至于放寝室的笔记本电脑成了刷题写代码专用，离开寝室就做别的事情，回到寝室就可以刷刷题了。 生活于一个写代码被认为是一个稀罕的事情的世界里，写代码的动物成了一个稀有动物。对于各种异样的目光，我或许早就习惯了，我被视为一个不务正业的人。 反正白天只能去忙碌别的事情，写代码刷题只能回到寝室默默地做着。 到后来自己默默地出来比赛，也没啥人知道我是出来比赛了。 真的一直好想把上大带入世界级舞台，来实现自己当初的愿望。 或许这只是一个小小的心愿，也是一种责任。 本来上一年就应该夺金，凭借优惠名额进军World Final的，但是我没能做到，只能遗憾拿到银牌第一，机会擦肩而过。 今年迫不得已再战一年，去北京邀请赛没拿到金，然后牡丹江也没拿到金，鞍山总算夺金了，总算不会遗憾退役了。 我搞了这么久才拿到第一个金牌，也真是够弱的了。 很多事情说多了都是泪，回去有空的时候再补一个退役帖吧！（这次是真的退役了，鉴于很多人吐槽我上年写了退役帖然后诈尸回来了。） 愿后面的赛区各位一切顺利！]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4656 Evaluation （快速数论变换NTT）]]></title>
    <url>%2F2014%2F10%2F07%2Fhdu4656%2F</url>
    <content type="text"><![CDATA[HDU4656 关于快速数论变换资料，参考ACDdreamer大神博客：here 本题需要公式推导，然后使用NTT来求卷积运算。 $$F_{x_k} = \sum_{i=0}^{n-1} a_i (bc^{2k}+d)^i$$ $$=\sum_{i=0}^{n-1} a_i \sum_{j=0}^{i}C_i^j (bc^{2k})^j d ^ {i-j} $$ $$=\sum_{j=0}^{n-1}(bc^{2k})^j j!^{-1} \sum_{i=j}^{n-1}a_i d^{i-j} i! (i-j)!^{-1} $$ $$=\sum_{j=0}^{n-1}(bc^{2k})^j j!^{-1} \sum_{i=0}^{n-1-j}a_{n-1-i}(n-1-i)! d^{n-1-i-j} (n-1-i-j)!^{-1} $$ $$=\sum_{j=0}^{n-1} (bc^{2k})^j j!^{-1} p_j $$ $$=\sum_{j=0}^{n-1} b^j j!^{-1} p_j c^{2jk} $$ $$=c^{k^2} \sum_{j=0}^{n-1} b^j j!^{-1} p_j c^{j^2} c^{-(k-j)^2} $$ $$=c^{k^2} q_k$$ EvaluationTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 131072/65536 K (Java/Others) Total Submission(s): 78 Accepted Submission(s): 15 Problem Description xk=b*c(2k)+d F(x)=a0 x0+a1 x1+a2 x2+…+an-1 xn-1 Given n, b, c, d, a0, …, an-1, calculate F(x0), …, F(xn-1). Input There is only one test case. First line, four integers, n, b, c, d. Second line, n integers, a0, …, an-1.1&lt;=n&lt;=105 1&lt;= b, c, d &lt;=106 0&lt;=ai&lt;=106 Output n lines. i-th line contains one integer, F(xi-1). Since the answers may be very large, you should output them modulo 106+3. Sample Input 2 1 2 3 0 1 Sample Output 4 7 Source 2013 Multi-University Training Contest 6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271/* ***************Author :kuangbinCreated Time :2014/10/7 21:21:32File Name :E:\2014ACM\专题学习\数学\快速数论变换\HDU4656.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;//*************//快速数论变换(NTT)//求A和B的卷积，结果对P取模//做长度为N1的变换，选取两个质数P1和P2//P1-1和P2-1必须是N1的倍数//E1和E2分别是P1,P2的原根//F1是E1模P1的逆元,F2是E2模P2的逆元//I1是N1对模P1的逆元,I2是N1对模P2的逆元////然后使用中国剩余定理，保证了结果是小于MM=P1*P2的//M1 = (P2对P1的逆元)*P2//M2 = (P1对P2的逆元)*P1const int P = 1000003;//结果对P取模const int N1 = 262144;// 2^&#123;18&#125;const int N2 = N1+1;//数组大小const int P1 = 998244353;//P1 = 2^&#123;23&#125;*7*17 + 1const int P2 = 995622913;//P2 = 2^&#123;19&#125;*3*3*211 + 1const int E1 = 996173970;const int E2 = 88560779;const int F1 = 121392023;//E1*F1 = 1(mod P1)const int F2 = 840835547;//E2*F2 = 1(mod P2)const int I1 = 998240545;//I1*N1 = 1(mod P1)const int I2 = 995619115;//I2*N1 = 1(mod P2)const long long M1 = 397550359381069386LL;const long long M2 = 596324591238590904LL;const long long MM = 993874950619660289LL;//MM = P1*P2//计算x*y对z取模long long mul(long long x,long long y,long long z)&#123; return (x*y - (long long)(x/(long double)z*y+1e-3)*z+z)%z;&#125;int trf(int x1,int x2)&#123; return (mul(M1,x1,MM)+mul(M2,x2,MM))%MM%P;&#125;int A[N2],B[N2],C[N2];int A1[N2],B1[N2],C1[N2];void fft(int *A,int PM,int PW)&#123; for(int m = N1,h;h = m/2, m &gt;= 2;PW = (long long)PW*PW%PM,m=h) for(int i = 0,w=1;i &lt; h;i++, w = (long long)w*PW%PM) for(int j = i;j &lt; N1;j += m)&#123; int k = j+h, x = (A[j]-A[k]+PM)%PM; (A[j]+=A[k])%=PM; A[k] = (long long)w*x%PM; &#125; for(int i = 0,j = 1;j &lt; N1-1;j++)&#123; for(int k = N1/2; k &gt; (i^=k);k /= 2); if(j &lt; i)swap(A[i],A[j]); &#125;&#125;//计算A和B的卷积，结果保存在C中，结果对P取模void mul()&#123; memset(C,0,sizeof(C)); memcpy(A1,A,sizeof(A)); memcpy(B1,B,sizeof(B)); fft(A1,P1,E1); fft(B1,P1,E1); for(int i = 0;i &lt; N1;i++)C1[i] = (long long)A1[i]*B1[i]%P1; fft(C1,P1,F1); for(int i = 0;i &lt; N1;i++)C1[i] = (long long)C1[i]*I1%P1; fft(A,P2,E2); fft(B,P2,E2); for(int i = 0;i &lt; N1;i++)C[i] = (long long)A[i]*B[i]%P2; fft(C,P2,F2); for(int i = 0;i &lt; N1;i++)C[i] = (long long)C[i]*I2%P2; for(int i = 0;i &lt; N1;i++)C[i] = trf(C1[i],C[i]);&#125;int INV[P];//逆元const int MAXN = 100010;int F[MAXN];//阶乘int a[MAXN];int pd[MAXN];int pb[MAXN];int pc2[MAXN];int p[MAXN];int main()&#123; //预处理逆元 INV[1] = 1; for(int i = 2;i &lt; P;i++) INV[i] = (long long)P/i*(P-INV[P%i])%P; F[0] = 1; for(int i = 1;i &lt; MAXN;i++) F[i] = (long long)F[i-1]*i%P; int n,b,c,d; while(scanf("%d%d%d%d",&amp;n,&amp;b,&amp;c,&amp;d) == 4)&#123; for(int i = 0;i &lt; n;i++)scanf("%d",&amp;a[i]); pd[0] = 1; for(int i = 1;i &lt; n;i++) pd[i] = (long long)pd[i-1]*d%P; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); for(int i = 0;i &lt; n;i++) A[i] = (long long)a[n-1-i]*F[n-1-i]%P; for(int i = 0;i &lt; n;i++) B[i] = (long long)pd[i]*INV[F[i]]%P; mul(); for(int i = 0;i &lt; n;i++)p[i] = C[i]; reverse(p,p+n); memset(A,0,sizeof(A)); pb[0] = 1; for(int i = 1;i &lt; n;i++) pb[i] = (long long)pb[i-1]*b%P; pc2[0] = 1; int c2 = (long long)c*c%P; for(int i = 1, s = c;i &lt; n;i++)&#123; pc2[i] = (long long)pc2[i-1]*s%P; s = (long long)s*c2%P; &#125; for(int i = 0;i &lt; n;i++) A[i] = (long long)pb[i]*INV[F[i]]%P*p[i]%P*pc2[i]%P; memset(B,0,sizeof(B)); B[0] = 1; for(int i = 1;i &lt; n;i++) B[i] = B[N1-i] = INV[pc2[i]]; mul(); for(int i = 0;i &lt; n;i++)C[i] = (long long)C[i]*pc2[i]%P; for(int i = 0;i &lt; n;i++) printf("%d\n",C[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>数学题</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>HDU</tag>
        <tag>快速数论变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3528 Ultimate Weapon （三维凸包，求凸包表面积）]]></title>
    <url>%2F2014%2F10%2F07%2Fpoj3528%2F</url>
    <content type="text"><![CDATA[POJ3528 求三维凸包的表面积。 直接上模板。 Ultimate Weapon Time Limit: 2000MS Memory Limit: 131072K Total Submissions: 2072 Accepted: 987 Description In year 2008 of the Cosmic Calendar, the Aliens send a huge armada towards the Earth seeking after conquest. The humans now depend on their ultimate weapon to retain their last hope of survival. The weapon, while capable of creating a continuous, closed and convex lethal region in the space and annihilating everything enclosed within, unfortunately exhausts upon each launch a tremendous amount of energy which is proportional to the surface area of the lethal region. Given the positions of all battleships in the Aliens’ armada, your task is to calculate the minimum amount of energy required to destroy the armada with a single launch of the ultimate weapon. You need to report the surface area of the lethal region only. Input The first line contains one number _N_ -- the number of battleships.(1 ≤ _N_ ≤ 500) Following _N_ lines each contains three integers presenting the position of one battleship. Output The minimal area rounded to three decimal places. Sample Input 40 0 04 0 02 3 01 1 2 Sample Output 19.137 Hint There are no four coplaner battleships. Source POJ Founder Monthly Contest – 2008.03.16, Jiang Liyang /* ***Author :kuangbinCreated Time :2014/10/7 12:21:36File Name :E:\2014ACM\专题学习\计算几何\三维几何\POJ3528.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const double eps = 1e-8;const int MAXN = 550;int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;}struct Point3{ double x,y,z; Point3(double _x = 0, double _y = 0, double _z = 0){ x = _x; y = _y; z = _z; } void input(){ scanf(“%lf%lf%lf”,&amp;x,&amp;y,&amp;z); } bool operator ==(const Point3 &amp;b)const{ return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0 &amp;&amp; sgn(z-b.z) == 0; } double len(){ return sqrt(x*x+y*y+zz); } double len2(){ return x\x+y*y+zz; } double distance(const Point3 &amp;b)const{ return sqrt((x-b.x)(x-b.x)+(y-b.y)(y-b.y)+(z-b.z)(z-b.z)); } Point3 operator -(const Point3 &amp;b)const{ return Point3(x-b.x,y-b.y,z-b.z); } Point3 operator +(const Point3 &amp;b)const{ return Point3(x+b.x,y+b.y,z+b.z); } Point3 operator (const double &amp;k)const{ return Point3(x\k,y*k,zk); } Point3 operator /(const double &amp;k)const{ return Point3(x/k,y/k,z/k); } //点乘 double operator (const Point3 &amp;b)const{ return x*b.x + y*b.y + zb.z; } //叉乘 Point3 operator ^(const Point3 &amp;b)const{ return Point3(y\b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x); }};struct CH3D{ struct face{ //表示凸包一个面上的三个点的编号 int a,b,c; //表示该面是否属于最终的凸包上的面 bool ok; }; //初始顶点数 int n; Point3 P[MAXN]; //凸包表面的三角形数 int num; //凸包表面的三角形 face F[8MAXN]; int g[MAXN][MAXN]; //叉乘 Point3 cross(const Point3 &amp;a,const Point3 &amp;b,const Point3 &amp;c){ return (b-a)^(c-a); } //三角形面积2 double area(Point3 a,Point3 b,Point3 c){ return ((b-a)^(c-a)).len(); } //四面体有向面积6 double volume(Point3 a,Point3 b,Point3 c,Point3 d){ return ((b-a)^(c-a))(d-a); } //正：点在面同向 double dblcmp(Point3 &amp;p,face &amp;f){ Point3 p1 = P[f.b] - P[f.a]; Point3 p2 = P[f.c] - P[f.a]; Point3 p3 = p - P[f.a]; return (p1^p2)*p3; } void deal(int p,int a,int b){ int f = g[a][b]; face add; if(F[f].ok){ if(dblcmp(P[p],F[f]) &gt; eps) dfs(p,f); else { add.a = b; add.b = a; add.c = p; add.ok = true; g[p][b] = g[a][p] = g[b][a] = num; F[num++] = add; } } } //递归搜索所有应该从凸包内删除的面 void dfs(int p,int now){ F[now].ok = false; deal(p,F[now].b,F[now].a); deal(p,F[now].c,F[now].b); deal(p,F[now].a,F[now].c); } bool same(int s,int t){ Point3 &amp;a = P[F[s].a]; Point3 &amp;b = P[F[s].b]; Point3 &amp;c = P[F[s].c]; return fabs(volume(a,b,c,P[F[t].a])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].b])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].c])) &lt; eps; } //构建三维凸包 void create(){ num = 0; face add; //*********************************** //此段是为了保证前四个点不共面 bool flag = true; for(int i = 1;i &lt; n;i++){ if(!(P\[0\] == P\[i\])){ swap(P\[1\],P\[i\]); flag = false; break; } } if(flag)return; flag = true; for(int i = 2;i &lt; n;i++){ if( ((P\[1\]-P\[0\])^(P\[i\]-P\[0\])).len() &gt; eps ){ swap(P\[2\],P\[i\]); flag = false; break; } } if(flag)return; flag = true; for(int i = 3;i &lt; n;i++){ if(fabs( ((P\[1\]-P\[0\])^(P\[2\]-P\[0\]))*(P\[i\]-P\[0\]) ) &gt; eps){ swap(P\[3\],P\[i\]); flag = false; break; } } if(flag)return; //********************************** for(int i = 0;i &lt; 4;i++){ add.a = (i+1)%4; add.b = (i+2)%4; add.c = (i+3)%4; add.ok = true; if(dblcmp(P\[i\],add) &gt; 0)swap(add.b,add.c); g\[add.a\]\[add.b\] = g\[add.b\]\[add.c\] = g\[add.c\]\[add.a\] = num; F\[num++\] = add; } for(int i = 4;i &lt; n;i++) for(int j = 0;j &lt; num;j++) if(F\[j\].ok &amp;&amp; dblcmp(P\[i\],F\[j\]) &gt; eps){ dfs(i,j); break; } int tmp = num; num = 0; for(int i = 0;i &lt; tmp;i++) if(F\[i\].ok) F\[num++\] = F\[i\]; } //表面积 double area(){ double res = 0; if(n == 3){ Point3 p = cross(P\[0\],P\[1\],P\[2\]); return p.len()/2; } for(int i = 0;i &lt; num;i++) res += area(P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); return res/2.0; } double volume(){ double res = 0; Point3 tmp = Point3(0,0,0); for(int i = 0;i &lt; num;i++) res += volume(tmp,P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); return fabs(res/6); } //表面三角形个数 int triangle(){ return num; } //表面多边形个数 //测试：HDU3662 int polygon(){ int res = 0; for(int i = 0;i &lt; num;i++){ bool flag = true; for(int j = 0;j &lt; i;j++) if(same(i,j)){ flag = 0; break; } res += flag; } return res; } //重心 //测试：HDU4273 Point3 barycenter(){ Point3 ans = Point3(0,0,0); Point3 o = Point3(0,0,0); double all = 0; for(int i = 0;i &lt; num;i++){ double vol = volume(o,P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); ans = ans + (((o+P\[F\[i\].a\]+P\[F\[i\].b\]+P\[F\[i\].c\])/4.0)*vol); all += vol; } ans = ans/all; return ans; } //点到面的距离 //测试：HDU4273 double ptoface(Point3 p,int i){ double tmp1 = fabs(volume(P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\],p)); double tmp2 = ((P\[F\[i\].b\]-P\[F\[i\].a\])^(P\[F\[i\].c\]-P\[F\[i\].a\])).len(); return tmp1/tmp2; } };CH3D hull;int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%d”,&amp;hull.n) == 1){ for(int i = 0;i &lt; hull.n;i++)hull.P[i].input(); hull.create(); printf(“%.3f\n”,hull.area()); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>POJ</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>三维凸包</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4273 Rescue （三维凸包，求重心到表面的最小距离）]]></title>
    <url>%2F2014%2F10%2F07%2Fhdu4273%2F</url>
    <content type="text"><![CDATA[HDU4273 测试模板！ 求三维凸包，然后找重点，然后求重点到每个表面的距离。 RescueTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 326 Accepted Submission(s): 234 Problem Description I work at NASA outer space rescue team which needs much courage and patient. In daily life, I always receive a lot of mission, and I must complete it right now. Today, team leader announced me that there is a huge spaceship dropping anchor in the out space, and we should reach there for rescue. As a working principle, at first, we should check whether there are persons living in the spaceship. So we carry a kind of machine called life sensor which can sense the life phenomenon when the distance between the machine and the living is not farther than the sense radius. I have read the designing paper of the spaceship in advance. It has a form of a convex polyhedron, and we can assume it is isodense. For best control, control center of the whole ship is located at the center of the mass. It is sure that if someone is still alive, he will stay at the control center. It’s unfortunately that I find the door is stocked when I try to enter into the spaceship, so I can only sense the living out of the space ship. Now I have opened the machine and it’s time to set the sense radius of it. I wonder the minimal radius of the machine which can allowe me to check whether there are persons living in the spaceship. Input There are multiple test cases. The first line contains an integer n indicating the number of vertices of the polyhedron. (4 &lt;= n &lt;= 100) Each of the next n lines contains three integers xi, yi, zi, the coordinates of the polyhedron vertices (-10,000 &lt;= xi, yi, zi &lt;= 10,000). It guaranteed that the given points are vertices of the convex polyhedron, and the polyhedron is non-degenerate. Output For each test case, output a float number indicating the minimal radius of the machine. Your answer should accurate up to 0.001. Sample Input 4 0 0 0 1 0 0 0 1 0 0 0 1 8 0 0 0 0 0 2 0 2 0 0 2 2 2 0 0 2 0 2 2 2 0 2 2 2 Sample Output 0.144 1.000 Source 2012 ACM/ICPC Asia Regional Changchun Online 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419/* ***************Author :kuangbinCreated Time :2014/10/7 8:36:38File Name :E:\2014ACM\专题学习\计算几何\三维几何\HDU4273.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double eps = 1e-8;const int MAXN = 550;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct Point3&#123; double x,y,z; Point3(double _x = 0, double _y = 0, double _z = 0)&#123; x = _x; y = _y; z = _z; &#125; void input()&#123; scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;z); &#125; bool operator ==(const Point3 &amp;b)const&#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0 &amp;&amp; sgn(z-b.z) == 0; &#125; double len()&#123; return sqrt(x*x+y*y+z*z); &#125; double len2()&#123; return x*x+y*y+z*z; &#125; double distance(const Point3 &amp;b)const&#123; return sqrt((x-b.x)(x-b.x)+(y-b.y)(y-b.y)+(z-b.z)*(z-b.z)); &#125; Point3 operator -(const Point3 &amp;b)const&#123; return Point3(x-b.x,y-b.y,z-b.z); &#125; Point3 operator +(const Point3 &amp;b)const&#123; return Point3(x+b.x,y+b.y,z+b.z); &#125; Point3 operator *(const double &amp;k)const&#123; return Point3(x*k,y*k,z*k); &#125; Point3 operator /(const double &amp;k)const&#123; return Point3(x/k,y/k,z/k); &#125; //点乘 double operator *(const Point3 &amp;b)const&#123; return x*b.x + y*b.y + z*b.z; &#125; //叉乘 Point3 operator ^(const Point3 &amp;b)const&#123; return Point3(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x); &#125;&#125;;struct CH3D&#123; struct face&#123; //表示凸包一个面上的三个点的编号 int a,b,c; //表示该面是否属于最终的凸包上的面 bool ok; &#125;; //初始顶点数 int n; Point3 P[MAXN]; //凸包表面的三角形数 int num; //凸包表面的三角形 face F[8*MAXN]; int g[MAXN][MAXN]; //叉乘 Point3 cross(const Point3 &amp;a,const Point3 &amp;b,const Point3 &amp;c)&#123; return (b-a)^(c-a); &#125; //三角形面积*2 double area(Point3 a,Point3 b,Point3 c)&#123; return ((b-a)^(c-a)).len(); &#125; //四面体有向面积*6 double volume(Point3 a,Point3 b,Point3 c,Point3 d)&#123; return ((b-a)^(c-a))*(d-a); &#125; //正：点在面同向 double dblcmp(Point3 &amp;p,face &amp;f)&#123; Point3 p1 = P[f.b] - P[f.a]; Point3 p2 = P[f.c] - P[f.a]; Point3 p3 = p - P[f.a]; return (p1^p2)*p3; &#125; void deal(int p,int a,int b)&#123; int f = g[a][b]; face add; if(F[f].ok)&#123; if(dblcmp(P[p],F[f]) &gt; eps) dfs(p,f); else &#123; add.a = b; add.b = a; add.c = p; add.ok = true; g[p][b] = g[a][p] = g[b][a] = num; F[num++] = add; &#125; &#125; &#125; //递归搜索所有应该从凸包内删除的面 void dfs(int p,int now)&#123; F[now].ok = false; deal(p,F[now].b,F[now].a); deal(p,F[now].c,F[now].b); deal(p,F[now].a,F[now].c); &#125; bool same(int s,int t)&#123; Point3 &amp;a = P[F[s].a]; Point3 &amp;b = P[F[s].b]; Point3 &amp;c = P[F[s].c]; return fabs(volume(a,b,c,P[F[t].a])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].b])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].c])) &lt; eps; &#125; //构建三维凸包 void create()&#123; num = 0; face add; //*********************************** //此段是为了保证前四个点不共面 bool flag = true; for(int i = 1;i &lt; n;i++)&#123; if(!(P\[0\] == P\[i\]))&#123; swap(P\[1\],P\[i\]); flag = false; break; &#125; &#125; if(flag)return; flag = true; for(int i = 2;i &lt; n;i++)&#123; if( ((P\[1\]-P\[0\])^(P\[i\]-P\[0\])).len() &gt; eps )&#123; swap(P\[2\],P\[i\]); flag = false; break; &#125; &#125; if(flag)return; flag = true; for(int i = 3;i &lt; n;i++)&#123; if(fabs( ((P\[1\]-P\[0\])^(P\[2\]-P\[0\]))*(P\[i\]-P\[0\]) ) &gt; eps)&#123; swap(P\[3\],P\[i\]); flag = false; break; &#125; &#125; if(flag)return; //********************************** for(int i = 0;i &lt; 4;i++)&#123; add.a = (i+1)%4; add.b = (i+2)%4; add.c = (i+3)%4; add.ok = true; if(dblcmp(P\[i\],add) &gt; 0)swap(add.b,add.c); g\[add.a\]\[add.b\] = g\[add.b\]\[add.c\] = g\[add.c\]\[add.a\] = num; F\[num++\] = add; &#125; for(int i = 4;i &lt; n;i++) for(int j = 0;j &lt; num;j++) if(F\[j\].ok &amp;&amp; dblcmp(P\[i\],F\[j\]) &gt; eps)&#123; dfs(i,j); break; &#125; int tmp = num; num = 0; for(int i = 0;i &lt; tmp;i++) if(F\[i\].ok) F\[num++\] = F\[i\]; &#125; //表面积 //测试：HDU3528 double area()&#123; double res = 0; if(n == 3)&#123; Point3 p = cross(P\[0\],P\[1\],P\[2\]); return p.len()/2; &#125; for(int i = 0;i &lt; num;i++) res += area(P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); return res/2.0; &#125; double volume()&#123; double res = 0; Point3 tmp = Point3(0,0,0); for(int i = 0;i &lt; num;i++) res += volume(tmp,P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); return fabs(res/6); &#125; //表面三角形个数 int triangle()&#123; return num; &#125; //表面多边形个数 //测试：HDU3662 int polygon()&#123; int res = 0; for(int i = 0;i &lt; num;i++)&#123; bool flag = true; for(int j = 0;j &lt; i;j++) if(same(i,j))&#123; flag = 0; break; &#125; res += flag; &#125; return res; &#125; //重心 //测试：HDU4273 Point3 barycenter()&#123; Point3 ans = Point3(0,0,0); Point3 o = Point3(0,0,0); double all = 0; for(int i = 0;i &lt; num;i++)&#123; double vol = volume(o,P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); ans = ans + (((o+P\[F\[i\].a\]+P\[F\[i\].b\]+P\[F\[i\].c\])/4.0)*vol); all += vol; &#125; ans = ans/all; return ans; &#125; //点到面的距离 //测试：HDU4273 double ptoface(Point3 p,int i)&#123; double tmp1 = fabs(volume(P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\],p)); double tmp2 = ((P\[F\[i\].b\]-P\[F\[i\].a\])^(P\[F\[i\].c\]-P\[F\[i\].a\])).len(); return tmp1/tmp2; &#125;&#125;;CH3D hull;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d",&amp;hull.n) == 1)&#123; for(int i = 0;i &lt; hull.n;i++)hull.P[i].input(); hull.create(); Point3 p = hull.barycenter(); double ans = 1e20; for(int i = 0;i &lt; hull.num;i++) ans = min(ans,hull.ptoface(p,i)); printf("%.3lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>HDU</tag>
        <tag>计算几何</tag>
        <tag>三维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3662 3D Convex Hull （三维凸包，求凸包多边形个数）]]></title>
    <url>%2F2014%2F10%2F07%2Fhdu3662%2F</url>
    <content type="text"><![CDATA[HDU3662 用来测试模板的，直接三维凸包，求凸包上的多边形个数。 3D Convex HullTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1259 Accepted Submission(s): 652 Problem Description There are N points in 3D-space which make up a 3D-Convex hull*. How many faces does the 3D-convexhull have? It is guaranteed that all the points are not in the same plane. In case you don’t know the definition of convex hull, here we give you a clarification from Wikipedia: *Convex hull: In mathematics, the convex hull, for a set of points X in a real vector space V, is the minimal convex set containing X. Input There are several test cases. In each case the first line contains an integer N indicates the number of 3D-points (3&lt; N &lt;= 300), and then N lines follow, each line contains three numbers x, y, z (between -10000 and 10000) indicate the 3d-position of a point. Output Output the number of faces of the 3D-Convex hull. Sample Input 7 1 1 0 1 -1 0 -1 1 0 -1 -1 0 0 0 1 0 0 0 0 0 -0.1 7 1 1 0 1 -1 0 -1 1 0 -1 -1 0 0 0 1 0 0 0 0 0 0.1 Sample Output 8 5 Source 2010 Asia Regional Harbin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407/* ***************Author :kuangbinCreated Time :2014/10/7 12:16:51File Name :E:\2014ACM\专题学习\计算几何\三维几何\HDU3662.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double eps = 1e-8;const int MAXN = 550;int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct Point3&#123; double x,y,z; Point3(double _x = 0, double _y = 0, double _z = 0)&#123; x = _x; y = _y; z = _z; &#125; void input()&#123; scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;z); &#125; bool operator ==(const Point3 &amp;b)const&#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0 &amp;&amp; sgn(z-b.z) == 0; &#125; double len()&#123; return sqrt(x*x+y*y+z*z); &#125; double len2()&#123; return x*x+y*y+z*z; &#125; double distance(const Point3 &amp;b)const&#123; return sqrt((x-b.x)(x-b.x)+(y-b.y)(y-b.y)+(z-b.z)*(z-b.z)); &#125; Point3 operator -(const Point3 &amp;b)const&#123; return Point3(x-b.x,y-b.y,z-b.z); &#125; Point3 operator +(const Point3 &amp;b)const&#123; return Point3(x+b.x,y+b.y,z+b.z); &#125; Point3 operator *(const double &amp;k)const&#123; return Point3(x*k,y*k,z*k); &#125; Point3 operator /(const double &amp;k)const&#123; return Point3(x/k,y/k,z/k); &#125; //点乘 double operator *(const Point3 &amp;b)const&#123; return x*b.x + y*b.y + z*b.z; &#125; //叉乘 Point3 operator ^(const Point3 &amp;b)const&#123; return Point3(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x); &#125;&#125;;struct CH3D&#123; struct face&#123; //表示凸包一个面上的三个点的编号 int a,b,c; //表示该面是否属于最终的凸包上的面 bool ok; &#125;; //初始顶点数 int n; Point3 P[MAXN]; //凸包表面的三角形数 int num; //凸包表面的三角形 face F[8*MAXN]; int g[MAXN][MAXN]; //叉乘 Point3 cross(const Point3 &amp;a,const Point3 &amp;b,const Point3 &amp;c)&#123; return (b-a)^(c-a); &#125; //三角形面积*2 double area(Point3 a,Point3 b,Point3 c)&#123; return ((b-a)^(c-a)).len(); &#125; //四面体有向面积*6 double volume(Point3 a,Point3 b,Point3 c,Point3 d)&#123; return ((b-a)^(c-a))*(d-a); &#125; //正：点在面同向 double dblcmp(Point3 &amp;p,face &amp;f)&#123; Point3 p1 = P[f.b] - P[f.a]; Point3 p2 = P[f.c] - P[f.a]; Point3 p3 = p - P[f.a]; return (p1^p2)*p3; &#125; void deal(int p,int a,int b)&#123; int f = g[a][b]; face add; if(F[f].ok)&#123; if(dblcmp(P[p],F[f]) &gt; eps) dfs(p,f); else &#123; add.a = b; add.b = a; add.c = p; add.ok = true; g[p][b] = g[a][p] = g[b][a] = num; F[num++] = add; &#125; &#125; &#125; //递归搜索所有应该从凸包内删除的面 void dfs(int p,int now)&#123; F[now].ok = false; deal(p,F[now].b,F[now].a); deal(p,F[now].c,F[now].b); deal(p,F[now].a,F[now].c); &#125; bool same(int s,int t)&#123; Point3 &amp;a = P[F[s].a]; Point3 &amp;b = P[F[s].b]; Point3 &amp;c = P[F[s].c]; return fabs(volume(a,b,c,P[F[t].a])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].b])) &lt; eps &amp;&amp; fabs(volume(a,b,c,P[F[t].c])) &lt; eps; &#125; //构建三维凸包 void create()&#123; num = 0; face add; //*********************************** //此段是为了保证前四个点不共面 bool flag = true; for(int i = 1;i &lt; n;i++)&#123; if(!(P\[0\] == P\[i\]))&#123; swap(P\[1\],P\[i\]); flag = false; break; &#125; &#125; if(flag)return; flag = true; for(int i = 2;i &lt; n;i++)&#123; if( ((P\[1\]-P\[0\])^(P\[i\]-P\[0\])).len() &gt; eps )&#123; swap(P\[2\],P\[i\]); flag = false; break; &#125; &#125; if(flag)return; flag = true; for(int i = 3;i &lt; n;i++)&#123; if(fabs( ((P\[1\]-P\[0\])^(P\[2\]-P\[0\]))*(P\[i\]-P\[0\]) ) &gt; eps)&#123; swap(P\[3\],P\[i\]); flag = false; break; &#125; &#125; if(flag)return; //********************************** for(int i = 0;i &lt; 4;i++)&#123; add.a = (i+1)%4; add.b = (i+2)%4; add.c = (i+3)%4; add.ok = true; if(dblcmp(P\[i\],add) &gt; 0)swap(add.b,add.c); g\[add.a\]\[add.b\] = g\[add.b\]\[add.c\] = g\[add.c\]\[add.a\] = num; F\[num++\] = add; &#125; for(int i = 4;i &lt; n;i++) for(int j = 0;j &lt; num;j++) if(F\[j\].ok &amp;&amp; dblcmp(P\[i\],F\[j\]) &gt; eps)&#123; dfs(i,j); break; &#125; int tmp = num; num = 0; for(int i = 0;i &lt; tmp;i++) if(F\[i\].ok) F\[num++\] = F\[i\]; &#125; //表面积 double area()&#123; double res = 0; if(n == 3)&#123; Point3 p = cross(P\[0\],P\[1\],P\[2\]); return p.len()/2; &#125; for(int i = 0;i &lt; num;i++) res += area(P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); return res/2.0; &#125; double volume()&#123; double res = 0; Point3 tmp = Point3(0,0,0); for(int i = 0;i &lt; num;i++) res += volume(tmp,P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); return fabs(res/6); &#125; //表面三角形个数 int triangle()&#123; return num; &#125; //表面多边形个数 int polygon()&#123; int res = 0; for(int i = 0;i &lt; num;i++)&#123; bool flag = true; for(int j = 0;j &lt; i;j++) if(same(i,j))&#123; flag = 0; break; &#125; res += flag; &#125; return res; &#125; //重心 Point3 barycenter()&#123; Point3 ans = Point3(0,0,0); Point3 o = Point3(0,0,0); double all = 0; for(int i = 0;i &lt; num;i++)&#123; double vol = volume(o,P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\]); ans = ans + (((o+P\[F\[i\].a\]+P\[F\[i\].b\]+P\[F\[i\].c\])/4.0)*vol); all += vol; &#125; ans = ans/all; return ans; &#125; //点到面的距离 double ptoface(Point3 p,int i)&#123; double tmp1 = fabs(volume(P\[F\[i\].a\],P\[F\[i\].b\],P\[F\[i\].c\],p)); double tmp2 = ((P\[F\[i\].b\]-P\[F\[i\].a\])^(P\[F\[i\].c\]-P\[F\[i\].a\])).len(); return tmp1/tmp2; &#125;&#125;;CH3D hull;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d",&amp;hull.n) == 1)&#123; for(int i = 0;i &lt; hull.n;i++)hull.P[i].input(); hull.create(); printf("%d\n",hull.polygon()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>HDU</tag>
        <tag>计算几何</tag>
        <tag>三维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2865 A very easy task （自然数幂和）]]></title>
    <url>%2F2014%2F10%2F07%2Fzoj2865%2F</url>
    <content type="text"><![CDATA[使用递推公式求解。 详见ACdreamer神牛博客：ACdreamer 直接公式法去递推，用大数写了发JAVA A very easy task Time Limit: 10 Seconds Memory Limit: 32768 KB This task is very simple. You are to calculate ��ik (1 &lt;= i &lt;= n). Input: There are multiple cases in the input. Each case begins with two integer n and k (0 &lt;= n &lt;= 1050, 1 &lt;= k &lt;= 100). Output: For each test, print the answer in a single line. Sample Input: 2 33 2 Sample Output: 914 Author: SHANG, Zechao Source: ZOJ Monthly, June 2007 import java.io.;import java.util.;import java.math.*; public class Main{ static BigInteger C[][] = new BigInteger[110][110]; public static void main(String\[\] args) throws IOException { C\[0\]\[0\] = BigInteger.ONE; for(int i = 1;i &lt; 110;i++){ C\[i\]\[0\] = C\[i\]\[i\] = BigInteger.ONE; for(int j = 1;j &lt; i;j++) C\[i\]\[j\] = C\[i-1\]\[j-1\].add(C\[i-1\]\[j\]); } Scanner cin = new Scanner(System.in); BigInteger n; int k; BigInteger A\[\] = new BigInteger\[110\]; while(cin.hasNext()){ n = cin.nextBigInteger(); k = cin.nextInt(); A\[0\] = n; for(int i = 1;i &lt;= k;i++){ A\[i\] = n.add(BigInteger.ONE).pow(i+1); A\[i\] = A\[i\].subtract(BigInteger.ONE); for(int j = 2;j &lt;= i+1;j++){ A\[i\] = A\[i\].subtract(C\[i+1\]\[j\].multiply(A\[i+1-j\])); } A\[i\] = A\[i\].divide(BigInteger.valueOf(i+1)); } System.out.println(A\[k\]); } } }]]></content>
      <categories>
        <category>Online Judge</category>
        <category>ZJU</category>
        <category>数学题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Final Battle]]></title>
    <url>%2F2014%2F10%2F06%2Ffinal-battle%2F</url>
    <content type="text"><![CDATA[今年将去1,2赛区。 最后的两场比赛将在牡丹江和鞍山结束。 选择前两个赛区主要是从时间上考虑， 这两个赛区都比较靠前， 我真的已经没有时间了，不能再往后拖了，积压了一大堆的事情要去做！ 而且前两年都是去的东北赛区，那今年也照样不例外吧！ 本来想留点时间去好好准备的，因为毕竟还准备的不充分，但是后来实际情况发现远远没有必要……. 无论如何，ICPC生涯的最后两场比赛我会认真做好自己该做的，争取一切顺利吧！ 国庆放假的7天，和以前一样，放假的话比不放假会更忙。 前面5天，早上起来看书写代码，然后下午组队训练，晚上回来看看文献，总结。 训练了5天感觉好累了，加上魔都天气变化太快，有点感冒的感觉，然后休息了一整天。 之后把模板整理了一下，弄成了一份将近300页的模板，感觉我会的也就这么些了。 其实模板都是浮云，几乎也用不上，只是偶尔可能用上，心理上踏实点。 慢慢地把很多群都退掉了，自己也不再去水群了，很快我将淡出这个圈子，这个圈子已经不属于我。 这期间认识的很多人，将会是最有价值的财富。 感觉很多的人给我的鼓励和帮助！ 最后一战！ 必将全力以赴。 正如岐哥说的要不留遗憾。但愿一个队可以全心协力，努力做到最好！]]></content>
      <categories>
        <category>小结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3816 Generalized Palindromic Number （数位DP+二分）]]></title>
    <url>%2F2014%2F10%2F05%2Fzoj3816%2F</url>
    <content type="text"><![CDATA[ZOJ3816 这题方法很多，暴力的做法我还没看懂， 只会用数位DP搞。 二分区间，然后数位DP求个数就可以了。 Generalized Palindromic Number Time Limit: 2 Seconds Memory Limit: 65536 KB A number that will be the same when it is written forwards or backwards is known as a palindromic number. For example, 1234321 is a palindromic number. We call a number generalized palindromic number, if after merging all the consecutive same digits, the resulting number is a palindromic number. For example, 122111 is a generalized palindromic number. Because after merging, 122111 turns into 121 which is a palindromic number. Now you are given a positive integer N, please find the largest generalized palindromic number less than N. InputThere are multiple test cases. The first line of input contains an integer T (about 5000) indicating the number of test cases. For each test case: There is only one integer N (1 &lt;= N &lt;= 1018). OutputFor each test case, output the largest generalized palindromic number less than N. Sample Input41212312241122 Sample Output1112112211121 Author: LIN, Xi Source: The 2014 ACM-ICPC Asia Mudanjiang Regional First Round #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;long long dp[20][20][20];int bit[30];int num[30];long long dfs(int pos,int now,int aim,bool limit){ if(pos &lt; 0)return now == aim; if(!limit &amp;&amp; dp[pos][now][aim] != -1) return dp[pos][now][aim]; int end = limit ? bit[pos] : 9; long long ans = 0; for(int i = 0;i &lt;= end;i++){ if(now == 0){ if(i == 0){ ans += dfs(pos-1,now,aim,limit &amp;&amp; (i == end)); } else { num[now] = i; if(now &lt; aim)ans += dfs(pos-1,now+1,aim,limit &amp;&amp; (i == end)); } } else { if(i == num[now-1])ans += dfs(pos-1,now,aim,limit &amp;&amp; (i == end)); else { num[now] = i; if(now &lt; (aim+1)/2){ if(now &lt; aim)ans += dfs(pos-1,now+1,aim,limit &amp;&amp; (i == end)); } else { if(i != num[aim-1-now])continue; if(now &lt; aim)ans += dfs(pos-1,now+1,aim,limit &amp;&amp; (i == end)); } } } } if(!limit)dp[pos][now][aim] = ans; return ans;}long long calc(long long n){ int pos = 0; do{ bit[pos++] = n%10; n /= 10; }while(n); long long ans = 0; for(int i = 1;i &lt;= pos;i++) ans += dfs(pos-1,0,i,1); return ans;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); long long n; memset(dp,-1,sizeof(dp)); while(T–){ scanf(“%lld”,&amp;n); n–; long long tmp = calc(n); long long l = 0, r = n; long long ans = 0; while(l &lt;= r){ long long mid = (l+r)/2; if(calc(mid) &gt;= tmp){ ans = mid; r = mid-1; } else l = mid+1; } printf(“%lld\n”,ans); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>ZJU</category>
        <category>数位DP</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3818 Pretty Poem （水题）]]></title>
    <url>%2F2014%2F10%2F05%2Fzoj3818%2F</url>
    <content type="text"><![CDATA[ZOJ3818 水题一个。 直接暴力搞。 就是需要注意A,B,C要是不同的。 Pretty Poem Time Limit: 2 Seconds Memory Limit: 65536 KB Poetry is a form of literature that uses aesthetic and rhythmic qualities of language. There are many famous poets in the contemporary era. It is said that a few ACM-ICPC contestants can even write poetic code. Some poems has a strict rhyme scheme like “ABABA” or “ABABCAB”. For example, “niconiconi” is composed of a rhyme scheme “ABABA” with A = “ni” and B = “co”. More technically, we call a poem pretty if it can be decomposed into one of the following rhyme scheme: “ABABA” or “ABABCAB”. The symbol A, B and C are different continuous non-empty substrings of the poem. By the way, punctuation characters should be ignored when considering the rhyme scheme. You are given a line of poem, please determine whether it is pretty or not. InputThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case: There is a line of poem S (1 &lt;= length(S) &lt;= 50). S will only contains alphabet characters or punctuation characters. OutputFor each test case, output “Yes” if the poem is pretty, or “No” if not. Sample Input3niconiconi~pettan,pettan,tsurupettanwafuwafu Sample OutputYesYesNo Author: JIANG, Kai Source: The 2014 ACM-ICPC Asia Mudanjiang Regional First Round /* ***Author :kuangbinCreated Time :2014/10/5 9:10:11File Name :ZOJ3818.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;bool check1(string str,string A,string B){ if(A == B)return false; string tmp = A + B + A + B + A; return str == tmp;}bool check2(string str,string A,string B){ if(A == B)return false; int len = str.length(); int al = A.length(); int bl = B.length(); if(len &lt;= 3*(al+bl))return false; string tmp = string(str.begin(),str.begin()+al+bl); if(tmp != (A+B))return false; tmp = string(str.begin()+al+bl,str.begin()+al+bl+al+bl); if(tmp != (A+B))return false; tmp = string(str.begin()+al+bl+al+bl,str.end()-al-bl); if(tmp == A || tmp == B)return false; tmp = string(str.end()-al-bl,str.end()); if(tmp != (A+B))return false; return true;}bool check(string str){ int len = str.length(); for(int i = 1;i &lt;= len;i++) for(int j = 1;j+i &lt;= len;j++) if(check1(str,string(str.begin(),str.begin()+i),string(str.begin()+i,str.begin()+i+j)) || check2(str,string(str.begin(),str.begin()+i),string(str.begin()+i,str.begin()+i+j)) ) return true; return false;}char ss[100];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); string str; int T; scanf(“%d”,&amp;T); while(T–){ scanf(“%s”,ss); int len = strlen(ss); str = “”; for(int i = 0;i &lt; len;i++) if( (ss[i] &gt;= ‘a’ &amp;&amp; ss[i] &lt;= ‘z’) || (ss[i] &gt;= ‘A’ &amp;&amp; ss[i] &lt;= ‘Z’)) str += ss[i]; if(check(str))printf(“Yes\n”); else printf(“No\n”); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>ZJU</category>
        <category>水题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3932 Groundhog Build Home （随机算法）]]></title>
    <url>%2F2014%2F10%2F04%2Fhdu3932%2F</url>
    <content type="text"><![CDATA[HDU3932 随机大法乱搞！ Groundhog Build HomeTime Limit: 15000/5000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1579 Accepted Submission(s): 686 Problem Description Groundhogs are good at digging holes, their home is a hole, usually a group of groundhogs will find a more suitable area for their activities and build their home at this area .xiaomi has grown up, can no longer live with its parents.so it needs to build its own home.xiaomi like to visit other family so much, at each visit it always start from the point of his own home.Xiaomi will visit all of the groundhogs’ home in this area(it will chose the linear distance between two homes).To save energy,xiaomi would like you to help it find where its home built,so that the longest distance between xiaomi’s home and the other groundhog’s home is minimum. Input The input consists of many test cases，ending of eof.Each test case begins with a line containing three integers X, Y, N separated by space.The numbers satisfy conditions: 1 &lt;= X,Y &lt;=10000, 1 &lt;= N&lt;= 1000. Groundhogs acivity at a rectangular area ,and X, Y is the two side of this rectangle, The number N stands for the number of holes.Then exactly N lines follow, each containing two integer numbers xi and yi (0 &lt;= xi &lt;= X, 0 &lt;= yi &lt;= Y) indicating the coordinates of one home. Output Print exactly two lines for each test case.The first line is the coordinate of xiaomi’s home which we help to find. The second line is he longest distance between xiaomi’s home and the other groundhog’s home.The output round to the nearest number with exactly one digit after the decimal point (0.05 rounds up to 0.1). Sample Input 1000 50 1 10 10 1000 50 4 0 0 1 0 0 1 1 1 Sample Output (10.0,10.0). 0.0 (0.5,0.5). 0.7 Source 2011 Multi-University Training Contest 10 - Host by HRBEU 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10100;const double PI = acos(-1.0);struct Point&#123; double x,y; void input()&#123; scanf("%lf%lf",&amp;x,&amp;y); &#125; double distance(Point b)&#123; return sqrt((x-b.x)(x-b.x)+(y-b.y)(y-b.y)); &#125;&#125;p[MAXN],tp[50];double dist[50];int n;double calc(Point p0)&#123; double ret = 0; for(int i = 0;i &lt; n;i++) ret = max(ret,p[i].distance(p0)); return ret;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); double X,Y; srand(time(NULL)); int P = 15, L = 30; while(scanf("%lf%lf%d",&amp;X,&amp;Y,&amp;n) == 3)&#123; for(int i = 0;i &lt; n;i++)p[i].input(); for(int i = 0;i &lt; P;i++)&#123; tp[i].x = (rand()%1000+1)/1000.0*X; tp[i].y = (rand()%1000+1)/1000.0*Y; dist[i] = calc(tp[i]); &#125; double step = sqrt(X*X + Y*Y)/2; while(step &gt; 1e-5)&#123; for(int i = 0;i &lt; P;i++)&#123; Point cur, pre = tp[i]; for(int j = 0;j &lt; L;j++)&#123; double angle = (rand()%1000+1)/1000.0*2*PI; cur.x = pre.x + cos(angle)*step; cur.y = pre.y + sin(angle)*step; if(cur.x &lt; 0 || cur.x &gt; X || cur.y &lt; 0 || cur.y &gt; Y)continue; double tmp = calc(cur); if(tmp &lt; dist[i])&#123; tp[i] = cur; dist[i] = tmp; &#125; &#125; &#125; step *= 0.85; &#125; int id; double ans = 1e20; for(int i = 0;i &lt; P;i++) if(dist[i] &lt; ans)&#123; ans = dist[i]; id = i; &#125; printf("(%.1lf,%.1lf).\n",tp[id].x,tp[id].y); printf("%.1lf\n",dist[id]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>HDU</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1379 Run Away （随机算法）]]></title>
    <url>%2F2014%2F10%2F04%2Fpoj1379%2F</url>
    <content type="text"><![CDATA[POJ1379 地图中有N个陷阱，给出他们的坐标，求一个点，使得这个点到所有陷阱的最小距离最大。 随机搞，选几个候选集，然后类似模拟退火的步骤，缩小步长。 Run Away Time Limit: 3000MS Memory Limit: 65536K Total Submissions: 6348 Accepted: 1951 Description One of the traps we will encounter in the Pyramid is located in the Large Room. A lot of small holes are drilled into the floor. They look completely harmless at the first sight. But when activated, they start to throw out very hot java, uh … pardon, lava. Unfortunately, all known paths to the Center Room (where the Sarcophagus is) contain a trigger that activates the trap. The ACM were not able to avoid that. But they have carefully monitored the positions of all the holes. So it is important to find the place in the Large Room that has the maximal distance from all the holes. This place is the safest in the entire room and the archaeologist has to hide there. Input The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing three integers X, Y, M separated by space. The numbers satisfy conditions: 1 &lt;= X,Y &lt;=10000, 1 &lt;= M &lt;= 1000. The numbers X and Yindicate the dimensions of the Large Room which has a rectangular shape. The number M stands for the number of holes. Then exactly M lines follow, each containing two integer numbers Ui and Vi (0 &lt;= Ui &lt;= X, 0 &lt;= Vi &lt;= Y) indicating the coordinates of one hole. There may be several holes at the same position. Output Print exactly one line for each test case. The line should contain the sentence “The safest point is (P, Q).” where P and Qare the coordinates of the point in the room that has the maximum distance from the nearest hole, rounded to the nearest number with exactly one digit after the decimal point (0.05 rounds up to 0.1). Sample Input 31000 50 110 10100 100 410 1010 9090 1090 903000 3000 41200 8563 25002700 26502990 100 Sample Output The safest point is (1000.0, 50.0).The safest point is (50.0, 50.0).The safest point is (1433.0, 1669.8). Source Central Europe 1999 POJ上用C++交可过， 用G++的话，要把输出改为 %f 如果WA，多交几次可破。 /* ***Author :kuangbinCreated Time :2014/10/4 21:49:13File Name :E:\2014ACM\专题学习\计算几何\模拟退火\POJ1379.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 10100;const double PI = acos(-1.0);struct Point{ double x,y; void input(){ scanf(“%lf%lf”,&amp;x,&amp;y); } double distance(Point b){ return sqrt((x-b.x)(x-b.x)+(y-b.y)(y-b.y)); }}p[MAXN],tp[50];double dist[50];int n;double calc(Point p0){ double ret = 1e20; for(int i = 0;i &lt; n;i++) ret = min(ret,p[i].distance(p0)); return ret;}int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; double X,Y; scanf(“%d”,&amp;T); srand(time(NULL)); int P = 15, L = 30; while(T–){ scanf(“%lf%lf%d”,&amp;X,&amp;Y,&amp;n); for(int i = 0;i &lt; n;i++)p[i].input(); for(int i = 0;i &lt; P;i++){ tp[i].x = (rand()%1000+1)/1000.0X; tp[i].y = (rand()%1000+1)/1000.0Y; dist[i] = calc(tp[i]); } double step = sqrt(X*X + Y*Y)/2; while(step &gt; 1e-5){ for(int i = 0;i &lt; P;i++){ Point cur, pre = tp[i]; for(int j = 0;j &lt; L;j++){ double angle = (rand()%1000+1)/1000.0*2*PI; cur.x = pre.x + cos(angle)step; cur.y = pre.y + sin(angle)step; if(cur.x &lt; 0 || cur.x &gt; X || cur.y &lt; 0 || cur.y &gt; Y)continue; double tmp = calc(cur); if(tmp &gt; dist[i]){ tp[i] = cur; dist[i] = tmp; } } } step *= 0.8; } int id; double ans = 0; for(int i = 0;i &lt; P;i++) if(dist[i] &gt; ans){ ans = dist[i]; id = i; } printf(“The safest point is (%.1lf, %.1lf).\n”,tp[id].x,tp[id].y); } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>POJ</category>
        <category>模拟退火</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟退火</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3817 Chinese Knot （DP）]]></title>
    <url>%2F2014%2F10%2F03%2Fzoj3817%2F</url>
    <content type="text"><![CDATA[ZOJ3817 非常好的一个题。 想出来了就比较简单了。 题意比较清楚。 大致意思就是有4条链。 四条链的端点之间是可以跳过去的。 然后给了一个目标字符串，要输出得到目标字符串的一个路径。 因为链可以反向走，那么4条链可以变为8条链。 这样其实问题转化成8条链可以跳来跳去得到目标串。 如果只走一条链，那么直接hash进行判断输出。 如果转移了多条链，那么只需要记录现在在哪条链的终点。 然后进行转移。 需要输出路径，要记录一下。 Chinese Knot Time Limit: 2 Seconds Memory Limit: 65536 KB Special Judge Chinese knot is a decorative handicraft that began as a form of Chinese folk artifact in the Tang and Song Dynasty in China. It was later popularized in the Ming. Alice is learning Chinese knotting. To take the first step, she went to the store and bought a string. To her surprise, she found the string was composed of characters! Anyway, she made a simple Chinese knot. It consists of one knot with 4 loops: Look at the picture above. There are four loops connected at the center black knot. To make the image clear and neat, the characters on the string are shown as red and yellow points. As a Mid-Autumn Festival gift, Alice give this handcrafted Chinese knot to you. Then she asked you a question: You are given a target character sequence. Can you get the sequence by walking on the knot? “Walking on the knot” means: You can start at any point you want. You can not start at or move to the black knot in the center. Each step, you can only move to an adjacent point, except for the point you came from immediately. The 8 points closely around the black knot are adjacent to each other. For example, in the picture above, they are the 8 yellow points adjacent to the black knot. Your path should not contain three continuous points which are both one of the 8 points mentioned above. InputThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case: The first line contains two integers N and M (3 &lt;= N, M &lt;= 100000). The total length of string that Alice bought from store is 4 N. Then followed by 4 lines, each line contains N lower case letters as a loop of the Chinese knot. These characters are indexed from 1 to 4 N corresponding to the input order. The next line contains M lower case letters indicating the target character sequence. OutputFor each test case, output the M indexes of characters you visited. If there are multiple solutions, output any one. If there is no solution, output “No solution!” instead. Sample Input23 3abcabcabcabcbaa3 3abcabcabcabcbab Sample Output2 1 4No solution! HintIn the first case, we start at the second character of the first loop and stop at the first character of the second loop. Author: CHEN, Weijie Source: The 2014 ACM-ICPC Asia Mudanjiang Regional First Round 代码君： /* ***Author :kuangbinCreated Time :2014/10/3 8:16:55File Name :E:\2014ACM\2014网络赛\2014牡丹江\I.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int SEED = 133331;int n,m;char str[MAXN];char ss[8][MAXN];unsigned long long P[MAXN];unsigned long long hs[MAXN];unsigned long long hss[8][MAXN];//检查ss[id]的[l1,r1] 和 str的[l2,r2]是不是一样bool check(int id,int l1,int r1,int l2,int r2){ unsigned long long tmp1 = hss[id][r1] - hss[id][l1-1]P[(r1-l1+1)]; unsigned long long tmp2 = hs[r2] - hs[l2-1]P[(r2-l2+1)]; return tmp1 == tmp2;}bool first;void output(int id,int x){ if(first)first = false; else printf(“ “); if(id &lt; 4){ printf(“%d”,idn+x); } else printf(“%d”,(id-4)n+(n+1-x));}int pre[MAXN][8];void print(int i,int id){ if(i &lt;= n){ for(int j = n-i+1;j &lt;= n;j++) output(id,j); return; } print(i-n,pre[i][id]); for(int j = 1;j &lt;= n;j++) output(id,j);}void gao(){ for(int i = 0;i &lt; 8;i++){ hss[i][0] = 0; for(int j = 1;j &lt;= n;j++) hss[i][j] = hss[i][j-1]SEED + ss[i][j-1]; } hs[0] = 0; for(int i = 1;i &lt;= m;i++) hs[i] = hs[i-1]SEED + str[i-1]; first = true; if(m &lt;= n){ for(int i = 0;i &lt; 8;i++) for(int j = 1;j+m-1 &lt;= n;j++) if(check(i,j,j+m-1,1,m)){ for(int k = j;k &lt;= j+m-1;k++) output(i,k); printf(“\n”); return; } } memset(pre,-1,sizeof(pre)); for(int i = 1;i &lt;= m;i++) for(int j = 0;j &lt; 8;j++){ if(i &lt;= n){ if(check(j,n-i+1,n,1,i)) pre[i][j] = 0; } //printf(“i %d j %d %d\n”,i,j,pre[i][j]); if(pre[i][j] == -1)continue; for(int k = 0;k &lt; 8;k++){ if(k == j+4 || k == j-4)continue; if(i+n &gt;= m){ if(check(k,1,m-i,i+1,m)){ print(i,j); for(int x = 1;x &lt;= m-i;x++) output(k,x); printf(“\n”); return; } continue; } if(check(k,1,n,i+1,i+n)){ pre[i+n][k] = j; } } } printf(“No solution!\n”);}int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); P[0] = 1; for(int i = 1;i &lt; MAXN;i++) P[i] = P[i-1]*SEED; int T; scanf(“%d”,&amp;T); while(T–){ scanf(“%d%d”,&amp;n,&amp;m); for(int i = 0;i &lt; 4;i++){ scanf(“%s”,ss[i]); strcpy(ss[i+4],ss[i]); reverse(ss[i+4],ss[i+4]+n); } scanf(“%s”,str); gao(); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>Online Judge</category>
        <category>ZJU</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 5879 - Boring Card Game （解模线性方程，暴力枚举）]]></title>
    <url>%2F2014%2F10%2F02%2Fuvalive5879%2F</url>
    <content type="text"><![CDATA[UVALive5879 题意： 就是规定了一个发牌和收牌的规则。 总共N个人玩游戏，有5*N张牌（分别是1,2,….5N）, 按照规则发牌，如果有一个人拿到了1,2,3,4,5的牌，这个人就赢了，否则进行收牌，然后再来。 要预测是第几个人赢，，以及第几次赢。 就是发牌规则和收牌规则得到一个映射关系，这其实是一个置换群。 然后就可以暴力枚举5张牌的位置，以及哪个人赢。 之后就解一个模线性方程组了。 卧槽！ 竟然没看出来这其实是置换群，这样就是一个一个环组成。 我还n^2去找然后TLE。 弱！ #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;namespace ME{ long long extend_gcd(long long a,long long b,long long &amp;x,long long &amp;y){ if(a == 0 &amp;&amp; b == 0)return -1; if(b == 0){x = 1; y = 0; return a;} long long d = extend_gcd(b,a%b,y,x); y -= a/bx; return d; } long long m[10],a[10]; bool solve(long long &amp;m0,long long &amp;a0,int m,int a){ long long y,x; long long g = extend_gcd(m0,m,x,y); if(abs(a-a0)%g)return false; x = (a-a0)/g; x %= m/g; a0 = (xm0 + a0); m0 = m/g; a0 %= m0; if(a0 &lt; 0)a0 += m0; return true; } bool MLES(long long &amp;m0,long long &amp;a0,int n){ bool flag = true; m0 = 1; a0 = 0; for(int i = 0;i &lt; n;i++){ if(!solve(m0,a0,m[i],a[i])){ flag = false; break; } } return flag; }}; const int MAXN = 5010;int link[MAXN];int a[MAXN];int b[MAXN];int belong[MAXN];int pe[MAXN];int id[MAXN];long long ans[MAXN];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1 &amp;&amp; n){ for(int i = 1;i &lt;= 5n;i++)scanf(“%d”,&amp;a[i]); for(int i = 1;i &lt;= 5n;i++)b[a[i]] = i; for(int i = 1;i &lt;= n;i++){ link[2(i-1)+1] = 5(i-1)+1; link[2(i-1)+2] = 5(i-1)+2; link[2*n + 2*(i-1)+1] = 5(i-1)+3; link[2\n + 2*(i-1)+2] = 5(i-1)+4; link[4\n + (i-1) + 1] = 5*(i-1)+5; } memset(belong,-1,sizeof(belong)); for(int i = 1;i &lt;= 5n;i++){ if(belong[i] != -1)continue; int u = i; int cnt = 0; while(belong[u] == -1){ belong[u] = i; id[u] = cnt; cnt++; u = link[u]; } pe[i] = cnt; for(int j = link[i];j != i;j = link[j]) pe[j] = cnt; } memset(ans,-1,sizeof(ans)); for(int i = 1;i &lt;= n;i++){ int c[10]; c[1] = 2(i-1)+1; c[2] = 2(i-1)+2; c[3] = 2\n + 2*(i-1)+1; c[4] = 2*n + 2*(i-1)+2; c[5] = 4*n + i; do{ bool flag = true; for(int j = 1;j &lt;= 5;j++){ if(belong[b[j]] != belong[c[j]]){ flag = false; break; } } if(!flag)continue; for(int j = 1;j &lt;= 5;j++){ ME::m[j-1] = pe[b[j]]; ME::a[j-1] = (id[c[j]] - id[b[j]] + pe[b[j]])%pe[b[j]]; } long long m0,a0; if(!ME::MLES(m0,a0,5))continue; if(ans[i] == -1)ans[i] = a0; else if(ans[i] &gt; a0)ans[i] = a0; } while(next_permutation(c+1,c+6)); } long long Min = -1; int id = -1; for(int i = 1;i &lt;= n;i++){ if(ans\[i\] == -1)continue; if(Min == -1 || Min &gt; ans\[i\]){ Min = ans\[i\]; id = i; } } if(id == -1)printf(&quot;Neverending game.\\n&quot;); else printf(&quot;Player %d wins game number %lld.\\n&quot;,id,ans\[id\]+1); } return 0; }]]></content>
      <categories>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>模线性方程组</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2112 Dynamic Rankings （动态区间第k大， 替罪羊树套splay）]]></title>
    <url>%2F2014%2F10%2F02%2Fzoj2112%2F</url>
    <content type="text"><![CDATA[ZOJ2112 有点大材小用了。 替罪羊树套splay的话，可以在线搞，而且支持插入删除等操作。 本题只有查询和修改操作。 完全可以把替罪羊树换成树状数组或者线段树了。 其实这里用替罪羊树，也没啥作用，重构操作都没有。就是当成线段树用的。 比较容易MLE。 Dynamic Rankings Time Limit: 10 Seconds Memory Limit: 32768 KB The Company Dynamic Rankings has developed a new kind of computer that is no longer satisfied with the query like to simply find the k-th smallest number of the given N numbers. They have developed a more powerful system such that for N numbers a[1], a[2], …, a[N], you can ask it like: what is the k-th smallest number of a[i], a[i+1], …, a[j]? (For some i&lt;=j, 0&lt;k&lt;=j+1-i that you have given to it). More powerful, you can even change the value of some a[i], and continue to query, all the same. Your task is to write a program for this computer, which - Reads N numbers from the input (1 &lt;= N &lt;= 50,000) - Processes M instructions of the input (1 &lt;= M &lt;= 10,000). These instructions include querying the k-th smallest number of a[i], a[i+1], …, a[j] and change some a[i] to t. Input The first line of the input is a single number X (0 &lt; X &lt;= 4), the number of the test cases of the input. Then X blocks each represent a single test case. The first line of each block contains two integers N and M, representing N numbers and M instruction. It is followed by N lines. The (i+1)-th line represents the number a[i]. Then M lines that is in the following format Q i j k or C i t It represents to query the k-th number of a[i], a[i+1], …, a[j] and change some a[i] to t, respectively. It is guaranteed that at any time of the operation. Any number a[i] is a non-negative integer that is less than 1,000,000,000. There’re NO breakline between two continuous test cases. Output For each querying operation, output one integer to represent the result. (i.e. the k-th smallest number of a[i], a[i+1],…, a[j]) There’re NO breakline between two continuous test cases. Sample Input 2 5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3 5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3 Sample Output 3 6 3 6 /* ***Author :kuangbinCreated Time :2014/10/2 8:59:47File Name :ZOJ2112.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;using namespace std;const int MAXN = 50010;namespace Splay{ struct Node null; struct Node{ Node \ch[2],*fa; int size,key,cnt; inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline void push_up(){ size = ch[0]-&gt;size + ch[1]-&gt;size + cnt; } void clear(int _key){ size = cnt = 1; key = _key; ch[0] = ch[1] = fa = null; } inline bool isroot(){ return fa == null || this != fa-&gt;ch[0] &amp;&amp; this != fa-&gt;ch[1]; } }; Node pool[MAXN\15],*tail; Node bc[MAXN]; int bc_top;//内存回收 void init(){ tail = pool; bc_top = 0; null = tail++; null-&gt;size = null-&gt;cnt = 0; null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;fa = null; } inline void rotate(Node x){ Node *f = x-&gt;fa, *ff = x-&gt;fa-&gt;fa; int c = x-&gt;d(), cc = f-&gt;d(); f-&gt;setc(x-&gt;ch[!c],c); x-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(x,cc); else x-&gt;fa = ff; f-&gt;push_up(); } inline void splay(Node &amp;root,Node x,Node goal){ while(x-&gt;fa != goal){ if(x-&gt;fa-&gt;fa == goal)rotate(x); else { bool f = x-&gt;fa-&gt;d(); x-&gt;d() == f ? rotate(x-&gt;fa) : rotate(x); rotate(x); } } x-&gt;push_up(); if(goal == null)root = x; } //找到r子树里面的最左边那个 Node get_left(Node r){ Node x = r; while(x-&gt;ch[0] != null)x = x-&gt;ch[0]; return x; } //在root的树中删掉x void erase(Node &amp;root,Node x){ splay(root,x,null); Node t = root; if(t-&gt;ch[1] != null){ root = t-&gt;ch[1]; splay(root,get_left(t-&gt;ch[1]),null); root-&gt;setc(t-&gt;ch[0],0); } else root = root-&gt;ch[0]; bc[bc_top++] = x; root-&gt;fa = null; if(root != null)root-&gt;push_up(); } Node newNode(int key){ Node p; if(bc_top)p = bc[–bc_top]; else p = tail++; p-&gt;clear(key); return p; } //插入一个值key void insert(Node &amp;root,int key){ if(root == null){ root = newNode(key); return; } Node now = root; Node pre = root-&gt;fa; while(now != null){ if(now-&gt;key == key){ now-&gt;cnt++; splay(root,now,null); return; } pre = now; now = now-&gt;ch[key &gt;= now-&gt;key]; } Node x = newNode(key); pre-&gt;setc(x,key &gt;= pre-&gt;key); splay(root,x,null); } //删除一个值key void erase(Node &amp;root,int key){ Node now = root; while(now-&gt;key != key){ now = now-&gt;ch[key &gt;= now-&gt;key]; } now-&gt;cnt–; if(now-&gt;cnt == 0)erase(root,now); else splay(root,now,null); } void Travel(Node r){ if(r == null)return; Travel(r-&gt;ch[0]); bc[bc_top++] = r; Travel(r-&gt;ch[1]); } void CLEAR(Node &amp;root){ Travel(root); root = null; } //查询小于等于val的个数 int query(Node root,int val){ int ans = 0; Node x = root; while(x != null){ if(val &lt; x-&gt;key)x = x-&gt;ch[0]; else{ ans += x-&gt;ch[0]-&gt;size + x-&gt;cnt; x = x-&gt;ch[1]; } } return ans; }};namespace ScapeGoatTree{ const double alpha = 0.75; struct Node{ Node ch[2]; int size,nodeCount,key; Splay::Node root; bool isBad(){ return ch[0]-&gt;nodeCount &gt; alpha\nodeCount+5 || ch[1]-&gt;nodeCount &gt; alpha*nodeCount+5; } void push_up(){ size = 1+ch[0]-&gt;size+ch[1]-&gt;size; nodeCount = 1+ch[0]-&gt;nodeCount+ch[1]-&gt;nodeCount; } }; Node pool[MAXN]; Node *tail,*root,null; Node bc[MAXN];//用不上 int bc_top; void init(){ tail = pool; null = tail++; null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;size = null-&gt;nodeCount = 0; null-&gt;root = Splay::null; bc_top = 0; } inline Node newNode(int key){ Node p; if(bc_top)p = bc[–bc_top]; else p = tail++; p-&gt;key = key; p-&gt;ch[0] = p-&gt;ch[1] = null; p-&gt;size = p-&gt;nodeCount = 1; p-&gt;root = Splay::null; return p; } Node *buildTree(int *a,int l,int r){ if(l &gt;= r)return null; int mid = (l+r)/2; Node p = newNode(a[mid]); for(int i = l;i &lt; r;i++) Splay::insert(p-&gt;root,a[i]); p-&gt;ch[0] = buildTree(a,l,mid); p-&gt;ch[1] = buildTree(a,mid+1,r); p-&gt;push_up(); return p; } void Travel(Node p,vector&amp;v){ if(p == null)return; Travel(p-&gt;ch[0],v); v.push_back(p-&gt;key); Splay::CLEAR(p-&gt;root); bc[bc_top++] = p; Travel(p-&gt;ch[1],v); } Node divide(vector&amp;v,int l,int r){ if(l == r)return null; int mid = (l+r)/2; Node p = newNode(v[mid]); for(int i = l;i &lt; r;i++) Splay::insert(p-&gt;root,v[i]); p-&gt;ch[0] = divide(v,l,mid); p-&gt;ch[1] = divide(v,mid+1,r); p-&gt;push_up(); return p; } inline void rebuild(Node &amp;p){ vectorv; Travel(p,v); p = divide(v,0,v.size()); } //将第id个值修改为val int Modify(Node p,int id,int val){ if(id == p-&gt;ch[0]-&gt;size+1){ int v = p-&gt;key; Splay::erase(p-&gt;root,v); Splay::insert(p-&gt;root,val); p-&gt;key = val; return v; } int res; if(p-&gt;ch[0]-&gt;size &gt;= id) res = Modify(p-&gt;ch[0],id,val); else res = Modify(p-&gt;ch[1],id-p-&gt;ch[0]-&gt;size-1,val); Splay::erase(p-&gt;root,res); Splay::insert(p-&gt;root,val); return res; } Node **insert(Node *&amp;p,int id,int val){ if(p == null){ p = newNode(val); Splay::insert(p-&gt;root,val); return &null; } else { p-&gt;size++; p-&gt;nodeCount++; Splay::insert(p-&gt;root,val); Node res; if(id &lt;= p-&gt;ch[0]-&gt;size+1) res = insert(p-&gt;ch[0],id,val); else res = insert(p-&gt;ch[1],id-p-&gt;ch[0]-&gt;size-1,val); if(p-&gt;isBad())res = &p; return res; } } void insert(int id,int val){ Node p = insert(root,id,val); if(*p != null)rebuild(*p); } //查询在[l,r]区间，值小于等于val的个数 int query(Node p,int l,int r,int val){ if(p == null)return 0; if(l &lt;= 1 &amp;&amp; p-&gt;size &lt;= r) return Splay::query(p-&gt;root,val); else { int ans = 0; if(l &lt;= p-&gt;ch[0]-&gt;size) ans += query(p-&gt;ch[0],l,r,val); if(r &gt; p-&gt;ch[0]-&gt;size+1) ans += query(p-&gt;ch[1],l-p-&gt;ch[0]-&gt;size-1,r-p-&gt;ch[0]-&gt;size-1,val); if(p-&gt;key &lt;= val &amp;&amp; l &lt;= p-&gt;ch[0]-&gt;size+1 &amp;&amp; p-&gt;ch[0]-&gt;size+1 &lt;= r) ans++; return ans; } } int query(int L,int R,int k){ int ans; int l = 0, r = 1000000000; while(l &lt;= r){ int mid = (l+r)/2; if(query(root,L,R,mid) &gt;= k){ ans = mid; r = mid-1; } else l = mid+1; } return ans; } void debug(Node p){ if(p == null)return; debug(p-&gt;ch[0]); printf(“%d key %d lc %d rc %d size %d\n”,p-pool,p-&gt;key,p-&gt;ch[0]-pool,p-&gt;ch[1]-pool,p-&gt;root-&gt;size); debug(p-&gt;ch[1]); }};int a[MAXN];int main(){ int T; int n,m; scanf(“%d”,&amp;T); while(T–){ scanf(“%d%d”,&amp;n,&amp;m); Splay::init(); ScapeGoatTree::init(); for(int i = 0;i &lt; n;i++)scanf(“%d”,&amp;a[i]); ScapeGoatTree::root = ScapeGoatTree::buildTree(a,0,n); //ScapeGoatTree::debug(ScapeGoatTree::root); char op[10]; while(m–){ scanf(“%s”,op); if(op[0] == ‘Q’){ int x,y,k; scanf(“%d%d%d”,&amp;x,&amp;y,&amp;k); int ans = ScapeGoatTree::query(x,y,k); printf(“%d\n”,ans); } else if(op[0] == ‘C’){ int x,val; scanf(“%d%d”,&amp;x,&amp;val); ScapeGoatTree::Modify(ScapeGoatTree::root,x,val); } } } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>splay tree</category>
        <category>ZJU</category>
        <category>数据结构</category>
        <category>替罪羊树</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
        <tag>splay</tag>
        <tag>数据结构</tag>
        <tag>替罪羊树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3065 带插入区间K小值 （替罪羊树套splay）]]></title>
    <url>%2F2014%2F10%2F02%2Fbzoj3065%2F</url>
    <content type="text"><![CDATA[BZOJ3065 带插入、修改的区间k小值在线查询。 网上看的别人的做法确实没看懂， 然后自己想了一下，用替罪羊树套上splay去搞。 替罪羊树维护相对位置信息，然后每个子树用splay去维护值。 这样就可以查询一个区间 &lt;= val的出现了几次。 替罪羊树重要的是不会旋转，维护起来很好维护。 就是代码比较长了，splay+替罪羊， 300+行代码， 1A了，怕不怕！ 3065: 带插入区间K小值Time Limit: 60 Sec Memory Limit: 512 MB Submit: 810 Solved: 184 [Submit][Status] Description从前有n只跳蚤排成一行做早操，每只跳蚤都有自己的一个弹跳力a[i]。跳蚤国王看着这些跳蚤国欣欣向荣的情景，感到非常高兴。这时跳蚤国王决定理性愉悦一下，查询区间k小值。他每次向它的随从伏特提出这样的问题: 从左往右第x个到第y个跳蚤中，a[i]第k小的值是多少。 这可难不倒伏特，他在脑袋里使用函数式线段树前缀和的方法水掉了跳蚤国王的询问。 这时伏特发现有些跳蚤跳久了弹跳力会有变化，有的会增大，有的会减少。 这可难不倒伏特，他在脑袋里使用树状数组套线段树的方法水掉了跳蚤国王的询问。（orz 主席树） 这时伏特发现有些迟到的跳蚤会插入到这一行的某个位置上，他感到非常生气，因为……他不会做了。 请你帮一帮伏特吧。 快捷版题意：带插入、修改的区间k小值在线查询。 Input第一行一个正整数n，表示原来有n只跳蚤排成一行做早操。 第二行有n个用空格隔开的非负整数，从左至右代表每只跳蚤的弹跳力。 第三行一个正整数q，表示下面有多少个操作。 下面一共q行，一共三种操作对原序列的操作：（假设此时一共m只跳蚤） 1. Q x y k: 询问从左至右第x只跳蚤到从左至右第y只跳蚤中，弹跳力第k小的跳蚤的弹跳力是多少。 (1 &lt;= x &lt;= y &lt;= m, 1 &lt;= k &lt;= y - x + 1) 2. M x val: 将从左至右第x只跳蚤的弹跳力改为val。 (1 &lt;= x &lt;= m) 3. I x val: 在从左至右第x只跳蚤的前面插入一只弹跳力为val的跳蚤。即插入后从左至右第x只跳蚤是我刚插入的跳蚤。 (1 &lt;= x &lt;= m + 1) 为了体现在线操作，设lastAns为上一次查询的时候程序输出的结果，如果之前没有查询过，则lastAns = 0。 则输入的时候实际是： Q _x _y _k ——&gt; 表示 Q _x^lastAns _y^lastAns _k^lastAns M _x _val ——&gt; 表示 M _x^lastAns _val^lastAns I _x _val ——&gt; 表示 I _x^lastAns _val^lastAns 简单来说就是操作中输入的整数都要异或上一次询问的结果进行解码。 (祝Pascal的同学早日转C++，就不提供pascal版的描述了。) Output对于每个询问输出回答，每行一个回答。 Sample Input10 10 5 8 28 0 19 2 31 1 22 30 I 6 9 M 1 11 I 8 17 M 1 31 M 6 26 Q 2 7 6 I 23 30 M 31 7 I 22 27 M 26 18 Q 26 17 31 I 5 2 I 18 13 Q 3 3 3 I 27 19 Q 23 23 30 Q 5 13 5 I 3 0 M 15 27 Q 0 28 13 Q 3 29 11 M 2 8 Q 12 5 7 I 30 19 M 11 19 Q 17 8 29 M 29 4 Q 3 0 12 I 7 18 M 29 27 Sample Output28 2 31 0 14 15 14 27 15 14 HINT此题作为一个小小的研究来搞吧～做法有很多～不知道这题究竟有多少种做法。 请自觉O(log^2n)，我故意卡块状链表，块链A了的请受我深情一拜…… A掉的同学请在Discuss里面简要说下自己的做法吧～ 原序列长度 &lt;= 35000 插入个数 &lt;= 35000，修改个数 &lt;= 70000，查询个数 &lt;= 70000 ,0 &lt;= 每时每刻的权值 &lt;= 70000 由于是OJ上的题，所以数据无梯度。为了防止卡OJ，本题只有4组数据。 Source作者 vfleaking 题目限定值的范围是 0~70000. 我用splay的做法的话，这个值的范围可以很大了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667/* ***************Author :kuangbinCreated Time :2014/10/1 22:05:45File Name :E:\2014ACM\专题学习\数据结构\ScapeGoatTree\BZOJ3065.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 70010;namespace Splay&#123; struct Node *null; struct Node&#123; Node *ch[2],*fa; int size,key,cnt; inline void setc(Node *p,int d)&#123; ch[d] = p; p-&gt;fa = this; &#125; inline bool d()&#123; return fa-&gt;ch[1] == this; &#125; inline void push_up()&#123; size = ch[0]-&gt;size + ch[1]-&gt;size + cnt; &#125; void clear(int _key)&#123; size = cnt = 1; key = _key; ch[0] = ch[1] = fa = null; &#125; inline bool isroot()&#123; return fa == null || this != fa-&gt;ch[0] &amp;&amp; this != fa-&gt;ch[1]; &#125; &#125;; Node pool[MAXN*20],*tail; Node *bc[MAXN*20]; int bc_top;//内存回收 void init()&#123; tail = pool; bc_top = 0; null = tail++; null-&gt;size = null-&gt;cnt = 0; null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;fa = null; &#125; inline void rotate(Node *x)&#123; Node *f = x-&gt;fa, *ff = x-&gt;fa-&gt;fa; int c = x-&gt;d(), cc = f-&gt;d(); f-&gt;setc(x-&gt;ch[!c],c); x-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(x,cc); else x-&gt;fa = ff; f-&gt;push_up(); &#125; inline void splay(Node* &amp;root,Node* x,Node* goal)&#123; while(x-&gt;fa != goal)&#123; if(x-&gt;fa-&gt;fa == goal)rotate(x); else &#123; bool f = x-&gt;fa-&gt;d(); x-&gt;d() == f ? rotate(x-&gt;fa) : rotate(x); rotate(x); &#125; &#125; x-&gt;push_up(); if(goal == null)root = x; &#125; //找到r子树里面的最左边那个 Node* get_left(Node* r)&#123; Node* x = r; while(x-&gt;ch[0] != null)x = x-&gt;ch[0]; return x; &#125; //在root的树中删掉x void erase(Node* &amp;root,Node* x)&#123; splay(root,x,null); Node* t = root; if(t-&gt;ch[1] != null)&#123; root = t-&gt;ch[1]; splay(root,get_left(t-&gt;ch[1]),null); root-&gt;setc(t-&gt;ch[0],0); &#125; else root = root-&gt;ch[0]; bc[bc_top++] = x; root-&gt;fa = null; if(root != null)root-&gt;push_up(); &#125; Node* newNode(int key)&#123; Node* p; if(bc_top)p = bc[--bc_top]; else p = tail++; p-&gt;clear(key); return p; &#125; //插入一个值key void insert(Node* &amp;root,int key)&#123; if(root == null)&#123; root = newNode(key); return; &#125; Node* now = root; Node* pre = root-&gt;fa; while(now != null)&#123; if(now-&gt;key == key)&#123; now-&gt;cnt++; splay(root,now,null); return; &#125; pre = now; now = now-&gt;ch[key &gt;= now-&gt;key]; &#125; Node *x = newNode(key); pre-&gt;setc(x,key &gt;= pre-&gt;key); splay(root,x,null); &#125; //删除一个值key void erase(Node* &amp;root,int key)&#123; Node* now = root; while(now-&gt;key != key)&#123; now = now-&gt;ch[key &gt;= now-&gt;key]; &#125; now-&gt;cnt--; if(now-&gt;cnt == 0)erase(root,now); else splay(root,now,null); &#125; void Travel(Node* r)&#123; if(r == null)return; Travel(r-&gt;ch[0]); bc[bc_top++] = r; Travel(r-&gt;ch[1]); &#125; void CLEAR(Node* &amp;root)&#123; Travel(root); root = null; &#125; //查询小于等于val的个数 int query(Node *root,int val)&#123; int ans = 0; Node *x = root; while(x != null)&#123; if(val &lt; x-&gt;key)x = x-&gt;ch[0]; else&#123; ans += x-&gt;ch[0]-&gt;size + x-&gt;cnt; x = x-&gt;ch[1]; &#125; &#125; return ans; &#125;&#125;;namespace ScapeGoatTree&#123; const double alpha = 0.75; struct Node&#123; Node *ch[2]; int size,nodeCount,key; Splay::Node *root; bool isBad()&#123; return ch[0]-&gt;nodeCount &gt; alpha*nodeCount+5 || ch[1]-&gt;nodeCount &gt; alpha*nodeCount+5; &#125; void push_up()&#123; size = 1+ch[0]-&gt;size+ch[1]-&gt;size; nodeCount = 1+ch[0]-&gt;nodeCount+ch[1]-&gt;nodeCount; &#125; &#125;; Node pool[MAXN]; Node *tail,*root,*null; Node *bc[MAXN]; int bc_top; void init()&#123; tail = pool; null = tail++; null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;size = null-&gt;nodeCount = 0; null-&gt;root = Splay::null; bc_top = 0; &#125; inline Node* newNode(int key)&#123; Node *p; if(bc_top)p = bc[--bc_top]; else p = tail++; p-&gt;key = key; p-&gt;ch[0] = p-&gt;ch[1] = null; p-&gt;size = p-&gt;nodeCount = 1; p-&gt;root = Splay::null; return p; &#125; Node *buildTree(int *a,int l,int r)&#123; if(l &gt;= r)return null; int mid = (l+r)/2; Node *p = newNode(a[mid]); for(int i = l;i &lt; r;i++) Splay::insert(p-&gt;root,a[i]); p-&gt;ch[0] = buildTree(a,l,mid); p-&gt;ch[1] = buildTree(a,mid+1,r); p-&gt;push_up(); return p; &#125; void Travel(Node *p,vector&lt;int&gt;&amp;v)&#123; if(p == null)return; Travel(p-&gt;ch[0],v); v.push_back(p-&gt;key); Splay::CLEAR(p-&gt;root); bc[bc_top++] = p; Travel(p-&gt;ch[1],v); &#125; Node *divide(vector&lt;int&gt;&amp;v,int l,int r)&#123; if(l == r)return null; int mid = (l+r)/2; Node *p = newNode(v[mid]); for(int i = l;i &lt; r;i++) Splay::insert(p-&gt;root,v[i]); p-&gt;ch[0] = divide(v,l,mid); p-&gt;ch[1] = divide(v,mid+1,r); p-&gt;push_up(); return p; &#125; inline void rebuild(Node *&amp;p)&#123; vector&lt;int&gt;v; Travel(p,v); p = divide(v,0,v.size()); &#125; //将第id个值修改为val int Modify(Node *p,int id,int val)&#123; if(id == p-&gt;ch[0]-&gt;size+1)&#123; int v = p-&gt;key; Splay::erase(p-&gt;root,v); Splay::insert(p-&gt;root,val); p-&gt;key = val; return v; &#125; int res; if(p-&gt;ch[0]-&gt;size &gt;= id) res = Modify(p-&gt;ch[0],id,val); else res = Modify(p-&gt;ch[1],id-p-&gt;ch[0]-&gt;size-1,val); Splay::erase(p-&gt;root,res); Splay::insert(p-&gt;root,val); return res; &#125; Node **insert(Node *&amp;p,int id,int val)&#123; if(p == null)&#123; p = newNode(val); Splay::insert(p-&gt;root,val); return &amp;null; &#125; else &#123; p-&gt;size++; p-&gt;nodeCount++; Splay::insert(p-&gt;root,val); Node ** res; if(id &lt;= p-&gt;ch[0]-&gt;size+1) res = insert(p-&gt;ch[0],id,val); else res = insert(p-&gt;ch[1],id-p-&gt;ch[0]-&gt;size-1,val); if(p-&gt;isBad())res = &amp;p; return res; &#125; &#125; void insert(int id,int val)&#123; Node **p = insert(root,id,val); if(*p != null)rebuild(*p); &#125; //查询在[l,r]区间，值小于等于val的个数 int query(Node *p,int l,int r,int val)&#123; if(p == null)return 0; if(l &lt;= 1 &amp;&amp; p-&gt;size &lt;= r) return Splay::query(p-&gt;root,val); else &#123; int ans = 0; if(l &lt;= p-&gt;ch[0]-&gt;size) ans += query(p-&gt;ch[0],l,r,val); if(r &gt; p-&gt;ch[0]-&gt;size+1) ans += query(p-&gt;ch[1],l-p-&gt;ch[0]-&gt;size-1,r-p-&gt;ch[0]-&gt;size-1,val); if(p-&gt;key &lt;= val &amp;&amp; l &lt;= p-&gt;ch[0]-&gt;size+1 &amp;&amp; p-&gt;ch[0]-&gt;size+1 &lt;= r) ans++; return ans; &#125; &#125; int query(int L,int R,int k)&#123; int ans; int l = 0, r = 100000; while(l &lt;= r)&#123; int mid = (l+r)/2; if(query(root,L,R,mid) &gt;= k)&#123; ans = mid; r = mid-1; &#125; else l = mid+1; &#125; return ans; &#125;&#125;;int a[MAXN];int main()&#123; int n; while(scanf("%d",&amp;n) == 1)&#123; Splay::init(); ScapeGoatTree::init(); for(int i = 0;i &lt; n;i++)scanf("%d",&amp;a[i]); ScapeGoatTree::root = ScapeGoatTree::buildTree(a,0,n); int m; char op[10]; scanf("%d",&amp;m); int ans = 0; while(m--)&#123; scanf("%s",op); if(op[0] == 'Q')&#123; int x,y,k; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); x ^= ans; y ^= ans; k ^= ans; ans = ScapeGoatTree::query(x,y,k); printf("%d\n",ans); &#125; else if(op[0] == 'M')&#123; int x,val; scanf("%d%d",&amp;x,&amp;val); x ^= ans; val ^= ans; ScapeGoatTree::Modify(ScapeGoatTree::root,x,val); &#125; else if(op[0] == 'I')&#123; int x,val; scanf("%d%d",&amp;x,&amp;val); x ^= ans; val ^= ans; ScapeGoatTree::insert(x,val); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>算法</category>
        <category>splay tree</category>
        <category>数据结构</category>
        <category>替罪羊树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>splay</tag>
        <tag>数据结构</tag>
        <tag>替罪羊树</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6045 - Alien Abduction （动态KD树）]]></title>
    <url>%2F2014%2F10%2F01%2Fuvalive6045%2F</url>
    <content type="text"><![CDATA[UAVLive6045 题意： 给了二维平面上的N个整点（\(N \leq 50000\)）。每次操作给了点\((x_i,y_i)\),需要曼哈顿距离小于\(E\)的点进行一个变换。 输出最后的点的坐标，保证变换次数不超过50000. 这题做的方法比较多。 KD树的做法就是先进行坐标选择，转化成找一个矩形内的点。 但是这样的KD树需要进行插入和删除，这样普通的KD树将不能保持平衡。 动态的KD树其实就是KD树结合了替罪羊树的思想。 当不平衡的时候，找替罪羊，然后整颗树进行重构。 /* ***Author :kuangbinCreated Time :2014/9/30 23:07:14File Name :E:\2014ACM\专题学习\KD树\UVALive6045.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const double alpha = 0.75;struct Point{ int x,y,id;};struct Node{ Point e; int size,nodeCount; Node *lc,*rc; bool div; bool exist; bool isBad(){ return lc-&gt;nodeCount &gt; alpha*nodeCount+5 || rc-&gt;nodeCount &gt; alpha*nodeCount+5; } inline void push_up(){ size = exist + lc-&gt;size + rc-&gt;size; nodeCount = 1+lc-&gt;nodeCount+rc-&gt;nodeCount; }};Node pool[MAXN],*tail,*root,null;Node bc[MAXN];int bc_top;void init(){ tail = pool; null = tail++; null-&gt;lc = null-&gt;rc = null; null-&gt;size = null-&gt;nodeCount = 0; root = null; bc_top = 0;}Node newNode(Point e){ Node p; if(bc_top)p = bc[–bc_top]; else p = tail++; p-&gt;e = e; p-&gt;lc = p-&gt;rc = null; p-&gt;size = p-&gt;nodeCount = 1; p-&gt;exist = true; return p;}inline bool cmpX(const Point &amp;a,const Point &amp;b){ return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y) || (a.x == b.x &amp;&amp; a.y == b.y &amp;&amp; a.id &lt; b.id);}inline bool cmpY(const Point &amp;a,const Point &amp;b){ return a.y &lt; b.y || (a.y == b.y &amp;&amp; a.x &lt; b.x) || (a.y == b.y &amp;&amp; a.x == b.x &amp;&amp; a.id &lt; b.id);}inline bool cmp(const Point &amp;a,const Point &amp;b,bool div){ return div?cmpY(a,b):cmpX(a,b);}//注意a需要备份，否则就乱序Node *build(Point *a,int l,int r,bool div){ if(l &gt;= r)return null; int mid = (l+r)/2; nth_element(a+l,a+mid,a+r,div?cmpY:cmpX); Node p = newNode(a[mid]); p-&gt;div = div; p-&gt;lc = build(a,l,mid,!div); p-&gt;rc = build(a,mid+1,r,!div); p-&gt;push_up(); return p;}void Travel(Node p,vector&amp;v){ if(p == null)return; Travel(p-&gt;lc,v); if(p-&gt;exist)v.push_back(p-&gt;e); bc[bc_top++] = p; Travel(p-&gt;rc,v);}Node divide(vector&amp;v,int l,int r,bool div){ if(l &gt;= r)return null; int mid = (l+r)/2; nth_element(v.begin()+l,v.begin()+mid,v.begin()+r,div?cmpY:cmpX); Node p = newNode(v[mid]); p-&gt;div = div; p-&gt;lc = divide(v,l,mid,!div); p-&gt;rc = divide(v,mid+1,r,!div); p-&gt;push_up(); return p;}inline void rebuild(Node &amp;p){ vectorv; Travel(p,v); p = divide(v,0,v.size(),p-&gt;div);}Node \*insert(Node *&amp;p,Point a,bool div){ if(p == null){ p = newNode(a); p-&gt;div = div; return &null; } else { p-&gt;nodeCount++; p-&gt;size++; Node res; if(cmp(a,p-&gt;e,div)) res = insert(p-&gt;lc,a,!div); else res = insert(p-&gt;rc,a,!div); if(p-&gt;isBad())res = &p; return res; }}void insert(Point e){ Node p = insert(root,e,0); if(*p != null)rebuild(*p);}vectorvec;void getvec(Node p,int minx,int maxx,int miny,int maxy){ if(p-&gt;size == 0)return; if(p-&gt;exist &amp;&amp; minx &lt;= p-&gt;e.x &amp;&amp; p-&gt;e.x &lt;= maxx &amp;&amp; miny &lt;= p-&gt;e.y &amp;&amp; p-&gt;e.y &lt;= maxy){ vec.push_back(p-&gt;e.id); p-&gt;exist = 0; p-&gt;size–; } if(p-&gt;div? miny &lt;= p-&gt;e.y : minx &lt;= p-&gt;e.x)getvec(p-&gt;lc,minx,maxx,miny,maxy); if(p-&gt;div? maxy &gt;= p-&gt;e.y : maxx &gt;= p-&gt;e.x)getvec(p-&gt;rc,minx,maxx,miny,maxy); p-&gt;push_up();}Point p[MAXN],p2[MAXN];Point p3[MAXN];int main(){ int T; scanf(“%d”,&amp;T); int iCase = 0; int N,Q,W,H; while(T–){ iCase++; scanf(“%d%d%d%d”,&amp;N,&amp;Q,&amp;W,&amp;H); init(); for(int i = 0;i &lt; N;i++){ scanf(“%d%d”,&amp;p[i].x,&amp;p[i].y); p[i].id = p2[i].id = i; p2[i].x = p[i].x+p[i].y; p2[i].y = p[i].x-p[i].y; p3[i] = p2[i]; } root = build(p3,0,N,0); int X,Y,E,a,b,c,d,e,f; while(Q–){ scanf(“%d%d%d%d%d%d%d%d%d”,&amp;X,&amp;Y,&amp;E,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f); vec.clear(); int minx = X+Y-E; int maxx = X+Y+E; int miny = X-Y-E; int maxy = X-Y+E; getvec(root,minx,maxx,miny,maxy); int sz = vec.size(); for(int i = 0;i &lt; sz;i++){ int id = vec[i]; long long tx = p[id].x; long long ty = p[id].y; p[id].x = (tx\a+ty*b+(long long)(id+1)c)%W; p[id].y = (tx\d+ty*e+(long long)(id+1)*f)%H; p2[id].x = p[id].x+p[id].y; p2[id].y = p[id].x-p[id].y; insert(p2[id]); } } printf(“Case #%d:\n”,iCase); for(int i = 0;i &lt; N;i++) printf(“%d %d\n”,p[i].x,p[i].y); } return 0;}]]></content>
      <categories>
        <category>KD树</category>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>替罪羊树</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>替罪羊树</tag>
        <tag>KD树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6041 - Retrenchment （KD树）]]></title>
    <url>%2F2014%2F09%2F30%2Fuvalive6041%2F</url>
    <content type="text"><![CDATA[UVALive 就是求最近的点和次近的点，直接用KD树搞。 中间用了一发判断点在多边形内的模板。 /* ***Author :kuangbinCreated Time :2014/9/30 18:22:34File Name :E:\2014ACM\专题学习\KD树\UVALive6014.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 200100;inline long long sqr(long long x){return xx;}struct Point{ int x,y; Point(){} Point(int _x,int _y){ x = _x; y = _y; } long long distance(const Point &amp;b)const{ return sqr(x-b.x)+sqr(y-b.y); } void input(){ scanf(“%d%d”,&amp;x,&amp;y); } Point operator -(const Point &amp;b)const{ return Point(x-b.x,y-b.y); } long long operator ^(const Point &amp;b)const{ return (long long)x\b.y - (long long)y*b.x; } long long operator (const Point &amp;b)const{ return (long long)x\b.x + (long long)y*b.y; }};struct Line{ Point s,e; Line(){} Line(Point _s,Point _e){ s = _s; e = _e; } bool pointonseg(Point p){ return ((p-s)^(e-s)) == 0 &amp;&amp; ((p-s)(p-e)) &lt;= 0; }};struct polygon{ int n; Point p[100]; Line l[100]; void input(int _n){ n = _n; for(int i = 0;i &lt; n;i++) p[i].input(); } void getline(){ for(int i = 0;i &lt; n;i++) l[i] = Line(p[i],p[(i+1)%n]); } //2边上 //1内部 //0外部 int relationpoint(Point q){ getline(); for(int i = 0;i &lt; n;i++) if(l[i].pointonseg(q)) return 2; int cnt = 0; for(int i = 0;i &lt; n;i++){ int j = (i+1)%n; long long k = (q-p[j])^(p[i]-p[j]); int u = p[i].y - q.y; int v = p[j].y - q.y; if(k &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0)cnt++; if(k &lt; 0 &amp;&amp; v &lt; 0 &amp;&amp; u &gt;= 0)cnt–; } return cnt != 0; }}po;namespace KDTree{ struct Point { int x,y; int index; long long distance(const Point &amp;b)const{ return sqr(x-b.x) + sqr(y-b.y); } }; struct qnode{ Point p; long long dis; qnode(){} qnode(Point _p,long long _dis){ p = _p; dis = _dis; } bool operator &lt;(const qnode &amp;b)const{ if(dis != b.dis)return dis &lt; b.dis; else return p.index &lt; b.p.index; } }; priority_queueq; inline bool cmpX(const Point &amp;a,const Point &amp;b){ return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y) || (a.x == b.x &amp;&amp; a.y == b.y &amp;&amp; a.index &lt; b.index); } inline bool cmpY(const Point &amp;a,const Point &amp;b){ return a.y &lt; b.y || (a.y == b.y &amp;&amp; a.x &lt; b.x) || (a.y == b.y &amp;&amp; a.x == b.x &amp;&amp; a.index &lt; b.index); } bool cmp(const Point &amp;a,const Point &amp;b,bool div){ return div?cmpY(a,b):cmpX(a,b); } struct Node{ Point e; Node \lc,*rc; bool div; }pool[MAXN],*tail,*root; void init(){ tail = pool; } Node *build(Point *a,int l,int r,bool div){ if(l &gt;= r)return NULL; Node p = tail++; p-&gt;div = div; int mid = (l+r)/2; nth_element(a+l,a+mid,a+r,div?cmpY:cmpX); p-&gt;e = a[mid]; p-&gt;lc = build(a,l,mid,!div); p-&gt;rc = build(a,mid+1,r,!div); return p; } void search(Point p,Node x,bool div,int m){ if(!x)return; if(cmp(p,x-&gt;e,div)){ search(p,x-&gt;lc,!div,m); if(q.size() &lt; m){ q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); search(p,x-&gt;rc,!div,m); } else { if(p.distance(x-&gt;e) &lt;= q.top().dis){ q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); q.pop(); } if(!div){ if(sqr(x-&gt;e.x-p.x) &lt;= q.top().dis) search(p,x-&gt;rc,!div,m); } else { if(sqr(x-&gt;e.y-p.y) &lt;= q.top().dis) search(p,x-&gt;rc,!div,m); } } } else { search(p,x-&gt;rc,!div,m); if(q.size() &lt; m){ q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); search(p,x-&gt;lc,!div,m); } else { if(p.distance(x-&gt;e) &lt;= q.top().dis){ q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); q.pop(); } if(!div){ if(sqr(x-&gt;e.x-p.x) &lt;= q.top().dis) search(p,x-&gt;lc,!div,m); } else { if(sqr(x-&gt;e.y-p.y) &lt;= q.top().dis) search(p,x-&gt;lc,!div,m); } } } } void search(Point p,int m){ while(!q.empty())q.pop(); search(p,root,0,m); }};Point p[MAXN];KDTree::Point pp[MAXN]; int main(){ int T; scanf(“%d”,&amp;T); int iCase = 0; while(T–){ iCase++; int n; scanf(“%d”,&amp;n); for(int i = 0;i &lt; n;i++)p[i].input(); int R; printf(“Case #%d:\n”,iCase); scanf(“%d”,&amp;R); for(int r = 1; r &lt;= R;r++){ printf(“Region %d\n”,r); int bb; scanf(“%d”,&amp;bb); po.input(bb); int cnt = 0; for(int i = 0;i &lt; n;i++){ if(po.relationpoint(p[i]) &gt; 0){ pp[cnt].x = p[i].x; pp[cnt].y = p[i].y; pp[cnt].index = i; cnt++; } } KDTree::init(); KDTree::root = KDTree::build(pp,0,cnt,0); KDTree::Point o; int m; scanf(“%d”,&amp;m); while(m–){ scanf(“%d%d”,&amp;o.x,&amp;o.y); KDTree::search(o,2); if(KDTree::q.size() != 2)while(1); KDTree::Point p2 = KDTree::q.top().p; KDTree::q.pop(); KDTree::Point p1 = KDTree::q.top().p; KDTree::q.pop(); printf(“%d %d\n”,p1.index+1,p2.index+1); } } } return 0;}]]></content>
      <categories>
        <category>KD树</category>
        <category>Online Judge</category>
        <category>UVALive</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>KD树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 455 D. Serega and Fun （Scapegoat-Tree）]]></title>
    <url>%2F2014%2F09%2F30%2Fcf455d%2F</url>
    <content type="text"><![CDATA[链接： here 这题的做法比较多。 今天学习了cwj巨巨的替罪羊树做法，调试了一个下午，卧槽！ 替罪羊树的好处就是不需要旋转，这样的话，维护起来就很方便了。 Links: edward-mj Scapegoat-Tree 套了一个map, 然后就可以轻松搞定这个题了。！ 很优美的做法。 代码： CF 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383/* ***************Author :kuangbinCreated Time :2014/9/30 14:29:03File Name :E:\2014ACM\专题学习\数据结构\ScapeGoatTree\CF455D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 200010;const double alpha = 0.75;struct Node&#123; Node *ch[2]; int size,key,nodeCount; bool exist; map&lt;int,int&gt;mp; bool isBad()&#123; return ch[0]-&gt;nodeCount &gt; alpha*nodeCount+5 || ch[1]-&gt;nodeCount &gt; alpha*nodeCount + 5; &#125; void push_up()&#123; size = exist + ch[0]-&gt;size + ch[1]-&gt;size; nodeCount = 1 + ch[0]-&gt;nodeCount + ch[1]-&gt;nodeCount; mp.clear(); if(exist)mp[key]++; for(map&lt;int,int&gt;::iterator it = ch[0]-&gt;mp.begin();it != ch[0]-&gt;mp.end();it++) mp[(*it).first] += (*it).second; for(map&lt;int,int&gt;::iterator it = ch[1]-&gt;mp.begin();it != ch[1]-&gt;mp.end();it++) mp[(*it).first] += (*it).second; &#125;&#125;;struct ScapeGoatTree&#123; Node pool[MAXN]; Node *tail,*root,*null; Node *bc[MAXN];//内存回收 int bc_top; void init()&#123; tail = pool; null = tail++; null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;size = null-&gt;key = null-&gt;nodeCount = 0; null-&gt;mp.clear(); root = null; bc_top = 0; &#125; inline Node *newNode(int key)&#123; Node *p; if(bc_top)p = bc[--bc_top]; else p = tail++; p-&gt;ch[0] = p-&gt;ch[1] = null; p-&gt;size = p-&gt;nodeCount = 1; p-&gt;key = key; p-&gt;exist = true; p-&gt;mp.clear(); p-&gt;mp[key] = 1; return p; &#125; Node *buildTree(int *a,int l,int r)&#123; if(l &gt;= r)return null; int mid = (l+r)&gt;&gt;1; Node *p = newNode(a[mid]); p-&gt;ch[0] = buildTree(a,l,mid); p-&gt;ch[1] = buildTree(a,mid+1,r); p-&gt;push_up(); return p; &#125; inline void Travel(Node *p,vector&lt;Node \*&gt;&amp;v)&#123; if(p == null)return; Travel(p-&gt;ch[0],v); if(p-&gt;exist)v.push_back(p); else bc[bc_top++] = p; Travel(p-&gt;ch[1],v); &#125; inline Node *divide(vector&lt;Node \*&gt;&amp;v,int l,int r)&#123; if(l &gt;= r)return null; int mid = (l+r)/2; Node *p = v[mid]; p-&gt;ch[0] = divide(v,l,mid); p-&gt;ch[1] = divide(v,mid+1,r); p-&gt;push_up(); return p; &#125; //重构，注意p要引用 inline void rebuild(Node *&amp;p)&#123; vector&lt;Node *&gt;v; Travel(p,v); p = divide(v,0,v.size()); &#125; //删除第id个元素，返回第id个元素的值 inline int erase(Node *p,int id)&#123; if(p-&gt;exist &amp;&amp; id == p-&gt;ch[0]-&gt;size + 1)&#123; p-&gt;exist = 0; p-&gt;mp[p-&gt;key]--; p-&gt;size--; return p-&gt;key; &#125; p-&gt;size--; int res; if(p-&gt;ch[0]-&gt;size &gt;= id) res = erase(p-&gt;ch[0],id); else res = erase(p-&gt;ch[1],id - p-&gt;ch[0]-&gt;size - p-&gt;exist); p-&gt;mp[res]--; return res; &#125; //删除一定的点以后重构 void check_erase()&#123; if(root-&gt;size &lt; 0.5*root-&gt;nodeCount) rebuild(root); &#125; Node **insert(Node *&amp;p,int id,int val)&#123; if(p == null)&#123; p = newNode(val); return &amp;null; &#125; else &#123; p-&gt;size++; p-&gt;nodeCount++; p-&gt;mp[val]++; Node ** res; if(id &lt;= p-&gt;ch[0]-&gt;size+p-&gt;exist) res = insert(p-&gt;ch[0],id,val); else res = insert(p-&gt;ch[1],id-p-&gt;ch[0]-&gt;size-p-&gt;exist,val); if(p-&gt;isBad())res = &amp;p; return res; &#125; &#125; //在第id个位置插入数val void insert(int id,int val)&#123; Node **p = insert(root,id,val); if(*p != null)rebuild(*p); &#125; //查询[l,r]之间值为val的数的个数 int query(Node *p,int l,int r,int val)&#123; if(p == null)return 0; if(l &lt;= 1 &amp;&amp; p-&gt;size &lt;= r) return p-&gt;mp.count(val)?p-&gt;mp[val]:0; else &#123; int ans = 0; if(l &lt;= p-&gt;ch[0]-&gt;size) ans += query(p-&gt;ch[0],l,r,val); if(r &gt; p-&gt;ch[0]-&gt;size+p-&gt;exist) ans += query(p-&gt;ch[1],l - p-&gt;ch[0]-&gt;size - p-&gt;exist, r - p-&gt;ch[0]-&gt;size - p-&gt;exist,val); if(p-&gt;exist &amp;&amp; p-&gt;key == val &amp;&amp; l &lt;= p-&gt;ch[0]-&gt;size+1 &amp;&amp; r &gt;= p-&gt;ch[0]-&gt;size+1) ans++; return ans; &#125; &#125;&#125;tree;int a[MAXN];int main()&#123; int n; while(scanf("%d",&amp;n) == 1)&#123; tree.init(); for(int i = 0;i &lt; n;i++)scanf("%d",&amp;a[i]); tree.root = tree.buildTree(a,0,n); int m; int op,l,r,k; scanf("%d",&amp;m); int ans = 0; while(m--)&#123; scanf("%d",&amp;op); if(op == 1)&#123; scanf("%d%d",&amp;l,&amp;r); l = ((l+ans-1)%n)+1; r = ((r+ans-1)%n)+1; if(l &gt; r)swap(l,r); int v = tree.erase(tree.root,r); //tree.check_erase(); //有时候可以加上删除重构 tree.insert(l,v); &#125; else &#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); l = ((l+ans-1)%n)+1; r = ((r+ans-1)%n)+1; k = ((k+ans-1)%n)+1; if(l &gt; r)swap(l,r); ans = tree.query(tree.root,l,r,k); printf("%d\n",ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>算法</category>
        <category>数据结构</category>
        <category>替罪羊树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>替罪羊树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3224: Tyvj 1728 普通平衡树 （Scapegoat tree）]]></title>
    <url>%2F2014%2F09%2F30%2Fbzoj3224%2F</url>
    <content type="text"><![CDATA[BZOJ3224 水题一样。 为了练习一下替罪羊树，用这个来搞了一发。 替罪羊树可以不需要旋转来保存平衡。 当然在这题还看不到他的优势。 3224: Tyvj 1728 普通平衡树Time Limit: 10 Sec Memory Limit: 128 MB Submit: 1956 Solved: 769 [Submit][Status] Description您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 1. 插入x数 2. 删除x数(若有多个相同的数，因只删除一个) 3. 查询x数的排名(若有多个相同的数，因输出最小的排名) 4. 查询排名为x的数 5. 求x的前驱(前驱定义为小于x，且最大的数) 6. 求x的后继(后继定义为大于x，且最小的数) Input第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号(1&lt;=opt&lt;=6) Output对于操作3,4,5,6每行输出一个数，表示对应答案 Sample Input10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598 Sample Output106465 84185 492737 HINT1.n的数据范围：n&lt;=100000 2.每个数的数据范围：[-1e7,1e7] Source平衡树 题意很简单。 直接替罪羊树练习了一发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317/* ***************Author :kuangbinCreated Time :2014/9/30 8:13:45File Name :E:\2014ACM\专题学习\数据结构\ScapeGoatTree\BZOJ3224.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 200010;const double alpha = 0.75;struct Node&#123; Node *ch[2]; int size,key,nodeCount; bool exist; bool isBad()&#123; return ch[0]-&gt;nodeCount &gt; alpha*nodeCount + 5 || ch[1]-&gt;nodeCount &gt; alpha*nodeCount + 5; &#125; void push_up()&#123; size = exist + ch[0]-&gt;size + ch[1]-&gt;size; nodeCount = 1 + ch[0]-&gt;nodeCount + ch[1]-&gt;nodeCount; &#125;&#125;;struct ScapeGoatTree&#123; Node pool[MAXN]; Node *tail,*root,*null; Node *bc[MAXN];//内存回收 int bc_top; void init()&#123; tail = pool; null = tail++; null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;size = null-&gt;key = null-&gt;nodeCount = 0; root = null; bc_top = 0; &#125; inline Node *newNode(int key)&#123; Node *p; if(bc_top)p = bc[--bc_top]; else p = tail++; p-&gt;ch[0] = p-&gt;ch[1] = null; p-&gt;size = 1; p-&gt;key = key; p-&gt;nodeCount = 1; p-&gt;exist = true; return p; &#125; inline void Travel(Node *p,vector&lt;Node \*&gt;&amp;v)&#123; if(p == null)return; Travel(p-&gt;ch[0],v); if(p-&gt;exist)v.push_back(p); else bc[bc_top++] = p; Travel(p-&gt;ch[1],v); &#125; inline Node *divide(vector&lt;Node \*&gt;&amp;v,int l,int r)&#123; if(l &gt;= r)return null; int mid = (l+r)/2; Node *p = v[mid]; p-&gt;ch[0] = divide(v,l,mid); p-&gt;ch[1] = divide(v,mid+1,r); p-&gt;push_up(); return p; &#125; inline void rebuild(Node *&amp;p)&#123; vector&lt;Node *&gt;v; Travel(p,v); p = divide(v,0,v.size()); &#125; Node **insert(Node *&amp;p,int val)&#123; if(p == null)&#123; p = newNode(val); return &amp;null; &#125; else &#123; p-&gt;size++; p-&gt;nodeCount++; int d = (val &gt;= p-&gt;key); Node **res = insert(p-&gt;ch[d],val); if(p-&gt;isBad())res = &amp;p; return res; &#125; &#125; //插入一个值为val的点 void insert(int val)&#123; Node **p = insert(root,val); if(*p != null)rebuild(*p); &#125; //删除第id个点 void erase(Node *p,int id)&#123; if(p-&gt;exist &amp;&amp; id == p-&gt;ch[0]-&gt;size+1)&#123; p-&gt;exist = 0; p-&gt;size--; return; &#125; p-&gt;size--; if(id &lt;= p-&gt;ch[0]-&gt;size+p-&gt;exist) erase(p-&gt;ch[0],id); else erase(p-&gt;ch[1],id - p-&gt;ch[0]-&gt;size - p-&gt;exist); &#125; //查询小于val的数的个数+1 int rank(int val)&#123; Node *now = root; int ans = 1; while(now != null)&#123; if(now-&gt;key &gt;= val)now = now-&gt;ch[0]; else &#123; ans += now-&gt;ch[0]-&gt;size + now-&gt;exist; now = now-&gt;ch[1]; &#125; &#125; return ans; &#125; int get_kth(int k)&#123; Node *now = root; while(now != null)&#123; if(now-&gt;exist &amp;&amp; k == now-&gt;ch[0]-&gt;size+1) return now-&gt;key; else if(now-&gt;ch[0]-&gt;size &gt;= k)now = now-&gt;ch[0]; else &#123; k -= now-&gt;ch[0]-&gt;size + now-&gt;exist; now = now-&gt;ch[1]; &#125; &#125; &#125; //删除一个值为val的点 void erase(int val)&#123; erase(root,rank(val)); if(root-&gt;size &lt; alpha*root-&gt;nodeCount) rebuild(root); &#125;&#125;tree;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1)&#123; tree.init(); int op,x; while(n--)&#123; scanf("%d%d",&amp;op,&amp;x); if(op == 1)tree.insert(x); else if(op == 2) tree.erase(x); else if(op == 3)printf("%d\n",tree.rank(x)); else if(op == 4)printf("%d\n",tree.get_kth(x)); else if(op == 5)printf("%d\n",tree.get_kth(tree.rank(x)-1)); else printf("%d\n",tree.get_kth(tree.rank(x+1))); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>替罪羊树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>替罪羊树</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014 ACM/ICPC Asia Regional Shanghai Online 题解]]></title>
    <url>%2F2014%2F09%2F27%2F2014shanghaionline%2F</url>
    <content type="text"><![CDATA[负责出了一场网络赛，勉勉强强算是顺利过去了，虽然产生了很多意外~~本场共有12道题，教练提供了3个题给我，学弟shumj出的1011的LCT。 然后本来这场是11个题的，开场前教练担心爆零的比较多，临时叫我加了一个水题，就是1012了。 搞完这场网络赛，估计被喷出翔了, 虽然有个别题我卡的比较紧，但是也算卡的合理的，其他题目的时限都是比较宽的了. 出题一般我都会弃掉恶心的模拟，代码量很大的题，这里的题目感觉代码量都比较小。。 但是我一般出题也出模板题, 就是来拼模板的，怕不怕！！ 比较抱歉的就是1001和1008的Rejudge. 出题最不应该rejudge了, 但是因为没有好的tester. 大部分题是我自己出，自己当的tester. 1001数据是没有问题的，是OJ数据上传出现问题，然后及时加上数据。 主要是1008，因为这题我暴力对拍过的，感觉数据是正确的，也没有仔细检查。 然后比赛过程中发现我的暴力对拍写错，标程也犯了一样的错误，然后修正后两个吻合了！ 然后就出现了1008的Rejudge！ 为两次Rejudge以及各种卡常数，表示深深的歉意！ 我就是这么弱！ 没办法。 这也算是退役前出的最后一场比赛吧！ 下面是简单题解。 1001： HDU5042 这一题其实主要就是因为GCD是分段的，所以分成一段一段去搞就可以了。 就是说，可能 [l,r1] ….[l,r2] 的gcd都是一样的。 因为如果 是 [l,r]之间的gcd的话， 随着r的增大，这个值是不增的，所以最多分成了log(10^5)段. 然后就可以胡搞了，当然也可以使用ST去求gcd,然后也可以搞出来。 这一题前面出现一片RE， 然后检查数据发现OJ没传上数据，然后进行了修正。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373/* ***************Author :kuangbinCreated Time :2014/9/5 15:28:45File Name :A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int MAXN = 100010;long long gcd(long long a,long long b)&#123; if(b == 0)return a; return gcd(b,a%b);&#125;int F[MAXN];int find(int x)&#123; if(F[x] == -1)return x; return F[x] = find(F[x]);&#125;void bing(int x,int y)&#123; int t1 = find(x); int t2 = find(y); if(t1 != t2)F[t2] = t1;&#125;int a[MAXN];struct Node1&#123; int r1,r2; int val; Node1(int _r1 = 0,int _r2 = 0,int _val = 0)&#123; r1 = _r1; r2 = _r2; val = _val; &#125; bool operator &lt;(const Node1 &amp;b)const&#123; if(r1 != b.r1)return r1 &lt; b.r1; else r2 &lt; b.r2; &#125;&#125;;vector&lt;Node1&gt;vec1[MAXN];struct Node2&#123; int l,r1,r2; long long sum; Node2(int _l = 0,int _r1 = 0,int _r2 = 0)&#123; l = _l; r1 = _r1; r2 = _r2; &#125; bool operator &lt;(const Node2 &amp;b)const&#123; if(l != b.l)return l &lt; b.l; else return r1 &lt; b.r1; &#125;&#125;;vector&lt;Node2&gt;vec2[MAXN];int num1[MAXN];int b[MAXN];int main()&#123; //freopen("A.in","r",stdin); //freopen("A.out","w",stdout); int T; scanf("%d",&amp;T); assert(T &lt;= 10); int n,Q; int iCase = 0; while(T--)&#123; iCase++; printf("Case #%d:\n",iCase); scanf("%d%d",&amp;n,&amp;Q); assert(n &gt;= 1 &amp;&amp; n &lt;= 100000 &amp;&amp; Q &gt;= 1 &amp;&amp; Q &lt;= 100000); int Max = 1; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d",&amp;a[i]); assert(a[i] &gt;= 1 &amp;&amp; a[i] &lt;= 100000); vec1[i].clear(); Max = max(Max,a[i]); &#125; for(int i = 1;i &lt;= Max;i++)vec2[i].clear(); F[n+1] = -1; for(int i = n;i &gt;= 1;i--)&#123; F[i] = -1; int start = i; int pre = i; b[i] = a[i]; for(int j = find(i+1);j &lt;= n;j = find(j+1))&#123; b[j] = gcd(a[i],b[j]); if(b[j] != b[pre])&#123; vec1[i].push_back(Node1(start,pre,b[pre])); vec2[b[pre]].push_back(Node2(i,start,pre)); start = pre+1; &#125; else bing(j,pre); pre = j; &#125; vec1[i].push_back(Node1(start,n,b[n])); vec2[b[n]].push_back(Node2(i,start,n)); sort(vec1[i].begin(),vec1[i].end()); /* printf("i %d\n",i); int sz = vec1[i].size(); for(int j = 0;j &lt; sz;j++) printf("%d %d %d\n",vec1[i][j].r1,vec1[i][j].r2,vec1[i][j].val); */ &#125; num1[0] = 0; for(int i = 1;i &lt;= Max;i++)&#123; sort(vec2[i].begin(),vec2[i].end()); int sz = vec2[i].size(); if(sz)num1[i] = num1[i-1]+1; else num1[i] = num1[i-1]; for(int j = 0;j &lt; sz;j++)&#123; if(j == 0)vec2[i][j].sum = 0; else vec2[i][j].sum = vec2[i][j-1].sum; vec2[i][j].sum += vec2[i][j].r2-vec2[i][j].r1+1; &#125; /* printf("i: %d\n",i); printf("num1:%d\n",num1[i]); for(int j = 0;j &lt; sz;j++) printf("%d %d %d %I64d\n",vec2[i][j].l,vec2[i][j].r1,vec2[i][j].r2,vec2[i][j].sum); */ &#125; char op[20]; long long k1,k2; while(Q--)&#123; scanf("%s%I64d%I64d",op,&amp;k1,&amp;k2); if(op[0] == 'R')&#123; assert(k1 &gt;= 1 &amp;&amp; k1 &lt;= k2 &amp;&amp; k2 &lt;= n); int id ; int sz = vec1[k1].size(); int l = 0, r = sz-1; while(l &lt;= r)&#123; int mid = (l+r)/2; if(vec1[k1][mid].r1 &lt;= k2 &amp;&amp; k2 &lt;= vec1[k1][mid].r2)&#123; id = mid; break; &#125; else if(vec1[k1][mid].r2 &lt; k2)l = mid+1; else r = mid-1; &#125; int val = vec1[k1][id].val; int ans1 = num1[val]; id = lower_bound(vec2[val].begin(),vec2[val].end(),Node2(k1,0,0)) - vec2[val].begin(); long long ans2; if(id == 0)ans2 = k2 - vec2[val][id].r1 + 1; else ans2 = vec2[val][id-1].sum + k2 - vec2[val][id].r1 + 1; printf("%d %I64d\n",ans1,ans2); &#125; else &#123; assert(k1 &gt;= 1 &amp;&amp; k1 &lt;= (long long)n(n+1)/2 &amp;&amp; k2 &gt;= 1 &amp;&amp; k2 &lt;= (long long)n(n+1)/2); int id1 = lower_bound(num1+1,num1+Max+1,k1) - num1; if(id1 &gt; Max || num1[id1] != k1)&#123; printf("-1\n"); continue; &#125; int sz = vec2[id1].size(); if(k2 &gt; vec2[id1][sz-1].sum)&#123; printf("-1\n"); continue; &#125; int l = 0, r = sz-1; int id2 = 0; while(l &lt;= r)&#123; int mid = (l+r)/2; long long ss = vec2[id1][mid].sum - (vec2[id1][mid].r2 - vec2[id1][mid].r1 + 1); if(k2 &gt; ss)&#123; id2 = mid; l = mid+1; &#125; else r = mid-1; &#125; k2 -= vec2[id1][id2].sum - (vec2[id1][id2].r2 - vec2[id1][id2].r1 + 1); printf("%d %d\n",vec2[id1][id2].l,(int)(vec2[id1][id2].r1 + k2 - 1)); &#125; &#125; &#125; return 0;&#125; 1002题： [HDU5043](http://acm.hdu.edu.cn/showproblem.php?pid=5043) 这个题就是Lucas定理的简单应用啊~~ 数位DP可搞。 这题是5倍以后标程啊，我没卡常数~ 小问题答案其实是 C(M,k1) * C(M-k1,k2) * C(M-k1-k2,k3)*********** M = k1+k2+k3+.. 如果要模P不等于0，就是k1,k2,...kn的P进制的和不能有进位。 然后就是数位DP可搞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/* ***************Author :kuangbinCreated Time :2014/9/25 0:07:36File Name :1002.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int MOD = 1e8+9;void Add(int &amp;a,int b)&#123; a += b; if(a &gt;= MOD)a -= MOD;&#125;int vis[10][33][22][1&lt;&lt;10];int dp[10][33][22][1&lt;&lt;10];int TT;int prime;int n;int bit[10][33];int dfs(int id,int pos,int sum,int s)&#123; if(id == n)&#123; id = 0; pos--; sum = 0; if(pos == -1)return 1; &#125; if(vis[id][pos][sum][s] == TT)return dp[id][pos][sum][s]; int end = (s&amp;(1&lt;&lt;id))?bit[id][pos]:prime-1; int ans = 0; for(int i = 0;i &lt;= end;i++)&#123; if(sum + i &gt;= prime)break; Add(ans,dfs(id+1,pos,sum+i,i == end? s : (s &amp; (~(1&lt;&lt;id))))); &#125; vis[id][pos][sum][s] = TT; return dp[id][pos][sum][s] = ans;&#125;int x[10];int solve()&#123; memset(bit,0,sizeof(bit)); int Max = 0; for(int i = 0;i &lt; n;i++)&#123; int cnt = 0; do&#123; bit[i][cnt++] = x[i]%prime; x[i] /= prime; &#125; while(x[i]); Max = max(Max,cnt); &#125; return dfs(0,Max-1,0,(1&lt;&lt;n)-1);&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); TT = 0; memset(vis,0,sizeof(vis)); int T; scanf("%d",&amp;T); assert(T &lt;= 50 &amp;&amp; T &gt;= 1); int iCase = 0; while(T--)&#123; iCase++; TT++; scanf("%d%d",&amp;n,&amp;prime); assert(n &gt;= 1 &amp;&amp; n &lt;= 10); assert(prime == 2 || prime == 3 || prime == 5 || prime == 7 || prime == 11 || prime == 13 || prime == 17 || prime == 19); long long tot = 1; for(int i = 0;i &lt; n;i++)&#123; scanf("%d",&amp;x[i]); assert(x[i] &gt;= 1 &amp;&amp; x[i] &lt;= 1000000000); tot = tot*(1+x[i])%MOD; &#125; tot -= solve(); tot = (tot%MOD+MOD)%MOD; printf("Case #%d: %d\n",iCase,(int)tot); &#125; return 0;&#125; 1003： 很简单的题目, 因为我卡常数了，让大家的罚时大增~~ 原意是想卡掉LCT或者其他的什么nlogn, n longnlogn算法的，后来发现O(n+m)的比不上nlogn的算法。因为常数好大。 然后就变成了谁的姿势好，谁就可过。 至于出现有很多的PE，是我故意安排的。 我要求输出3行的，你们的程序n=1的时候输出2行，能不PE吗？ 一种做法是Tarjan进行LCA,然后进行加减啊，然后扫一遍。 或者进行树链剖分转为线性，然后搞。 其余算法也可能可以卡过~ 但是本题要输入输出挂，标程也无耻地用了~~尽力吐槽吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483/* ***************Author :kuangbinCreated Time :2014/9/9 15:33:50File Name :C.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int MAXN = 100010;struct Edge&#123; int to,next; int index;&#125;edge[MAXN*2];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;inline void addedge(int u,int v,int index)&#123; edge[tot].to = v; edge[tot].next = head[u]; edge[tot].index = index; head[u] = tot++;&#125;int F[MAXN];inline int find(int x)&#123; if(F[x] == -1)return x; return F[x] = find(F[x]);&#125;inline void bing(int x,int y)&#123; int t1 = find(x); int t2 = find(y); if(t1 != t2)F[t1] = t2;&#125;long long PF[MAXN],EF[MAXN];struct Node&#123; int id; int v,val; int next; Node(int _id = 0,int _v = 0,int _val = 0)&#123; id = _id; v = _v; val = _val; &#125;&#125;query[MAXN*2];int h[MAXN];int tt;inline void init2()&#123; tt = 0; memset(h,-1,sizeof(h));&#125;inline void add_query(int u,int v,int id,int val)&#123; query[tt].id = id; query[tt].next = h[u]; query[tt].v = v; query[tt].val = val; h[u] = tt++;&#125;bool vis[MAXN];int fa[MAXN];bool ff[MAXN];int sta[MAXN];int cur[MAXN];void dfs1(int u,int pre)&#123; memcpy(cur,head,sizeof(head)); memset(ff,false,sizeof(ff)); fa[1] = -1; int top = 0; sta[top++] = 1; while(top != 0)&#123; u = sta[top-1]; if(!ff[u])ff[u] = true; bool flag = false; for(int i = cur[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(ff[v])continue; fa[v] = u; sta[top++] = v; flag = true; cur[u] = edge[i].next; break; &#125; if(!flag)&#123; top--; for(int i = h[u];i != -1;i = query[i].next)&#123; int v = query[i].v; int type = query[i].id; int w = query[i].val; if(vis[v])&#123; if(type == 1)&#123; PF[find(v)] -= w; if(fa[find(v)] != -1)PF[fa[find(v)]] -= w; PF[v] += w; &#125; else &#123; EF[find(v)] -= 2*w; EF[v] += w; &#125; &#125; else &#123; if(type == 1)PF[v] += w; else EF[v] += w; &#125; &#125; if(fa[u] != -1)bing(u,fa[u]); vis[u] = true; &#125; &#125;&#125;long long a[MAXN];long long ans1[MAXN],ans2[MAXN];int gg[MAXN];void dfs2(int u,int pre)&#123; int l,r; gg[l = r = 1] = 1; for(;l &lt;= r;l++) for(int i = head[gg[l]];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[gg[l]])continue; gg[++r] = v; &#125; for(l--;l;l--)&#123; u = gg[l]; for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[u])continue; EF[u] += EF[v]; PF[u] += PF[v]; ans2[edge[i].index] = EF[v]; &#125; ans1[u] = PF[u] + a[u]; &#125;&#125;//适用于正负整数template &lt;class T&gt;inline bool scan_d(T &amp;ret) &#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar(); sgn=(c=='-')?-1:1; ret=(c=='-')?0:(c-'0'); while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9') ret=ret*10+(c-'0'); ret*=sgn; return 1;&#125;inline void out(long long x) &#123; if(x&gt;9) out(x/10); putchar(x%10+'0');&#125;int main()&#123; //freopen("C.in","r",stdin); //freopen("C.out","w",stdout); //freopen("in.txt","r",stdin); //freopen("out1.txt","w",stdout); int n,m; int T; scanf("%d",&amp;T); int iCase = 0; while(T--)&#123; iCase++; init(); //scanf("%d%d",&amp;n,&amp;m); scan_d(n); scan_d(m); assert(n &gt;= 1 &amp;&amp; n &lt;= 100000 &amp;&amp; m &gt;= 1 &amp;&amp; m &lt;= 100000); memset(a,0,sizeof(a)); int u,v,w; for(int i = 1;i &lt; n;i++)&#123; //scanf("%d%d",&amp;u,&amp;v); scan_d(u); scan_d(v); addedge(u,v,i); addedge(v,u,i); &#125; char op[20]; init2(); while(m--)&#123; //scanf("%s%d%d%d",op,&amp;u,&amp;v,&amp;w); scanf("%s",op); scan_d(u); scan_d(v); scan_d(w); assert(u &gt;= 1 &amp;&amp; u &lt;= n); assert(v &gt;= 1 &amp;&amp; v &lt;= n); assert(abs(w) &lt;= 100000); if(op[3] == '1')&#123; if(u == v)a[u] += w; else &#123; // vec[u].push_back(Node(1,v,w)); //vec[v].push_back(Node(1,u,w)); add_query(u,v,1,w); add_query(v,u,1,w); &#125; &#125; else &#123; if(u == v)continue; else &#123; //vec[u].push_back(Node(2,v,w)); //vec[v].push_back(Node(2,u,w)); add_query(u,v,2,w); add_query(v,u,2,w); &#125; &#125; &#125; memset(PF,0,sizeof(PF)); memset(EF,0,sizeof(EF)); memset(F,-1,sizeof(F)); memset(vis,false,sizeof(vis)); dfs1(1,-1); //for(int i = 1;i &lt;= n;i++) //printf("%I64d %I64d\n",PF[i],EF[i]); //memset(ans1,0,sizeof(ans1)); //memset(ans2,0,sizeof(ans2)); dfs2(1,-1); printf("Case #%d:\n",iCase); for(int i = 1;i &lt;= n;i++)&#123; //printf("%I64d",ans1[i]); out(ans1[i]); if(i &lt; n)printf(" "); else printf("\n"); &#125; for(int i = 1;i &lt; n;i++)&#123; //printf("%I64d",ans2[i]); out(ans2[i]); if(i &lt; n-1)printf(" "); &#125; printf("\n"); &#125; return 0;&#125; 树链剖分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375/* ***************Author :kuangbinCreated Time :2014/9/24 14:12:20File Name :F:\题目_上海网络赛\2014上海网络赛题目\C\标程\C3.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;struct Edge&#123; int to,next;&#125;edge[MAXN*2];int head[MAXN],tot;int top[MAXN];int fa[MAXN];int deep[MAXN];int num[MAXN];int p[MAXN];int fp[MAXN];int son[MAXN];int pos;void init()&#123; tot = 0; memset(head,-1,sizeof(head)); pos = 1; memset(son,-1,sizeof(son));&#125;inline void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;inline void dfs1(int u,int pre,int d)&#123; deep[u] = d; fa[u] = pre; num[u] = 1; for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v != pre)&#123; dfs1(v,u,d+1); num[u] += num[v]; if(son[u] == -1 || num[v] &gt; num[son[u]]) son[u] = v; &#125; &#125;&#125;inline void getpos(int u,int sp)&#123; top[u] = sp; p[u] = pos++; fp[p[u]] = u; if(son[u] == -1)return; getpos(son[u],sp); for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v != son[u] &amp;&amp; v != fa[u]) getpos(v,v); &#125;&#125;long long w1[MAXN];void add1(int u,int v,int w)&#123; int f1 = top[u],f2 = top[v]; while(f1 != f2)&#123; if(deep[f1] &lt; deep[f2])&#123; swap(f1,f2); swap(u,v); &#125; w1[p[f1]] += w; w1[p[u]+1] -= w; u = fa[f1]; f1 = top[u]; &#125; if(deep[u] &gt; deep[v])swap(u,v); w1[p[u]] += w; w1[p[v]+1] -= w;&#125;long long w2[MAXN];void add2(int u,int v,int w)&#123; int f1 = top[u], f2 = top[v]; while(f1 != f2)&#123; if(deep[f1] &lt; deep[f2])&#123; swap(f1,f2); swap(u,v); &#125; w2[p[f1]] += w; w2[p[u]+1] -= w; u = fa[f1]; f1 = top[u]; &#125; if(u == v)return; if(deep[u] &gt; deep[v])swap(u,v); w2[p[son[u]]] += w; w2[p[v]+1] -= w;&#125;//适用于正负整数template &lt;class T&gt;inline bool scan_d(T &amp;ret) &#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar(); sgn=(c=='-')?-1:1; ret=(c=='-')?0:(c-'0'); while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9') ret=ret*10+(c-'0'); ret*=sgn; return 1;&#125;inline void out(long long x) &#123; if(x&gt;9) out(x/10); putchar(x%10+'0');&#125;pair&lt;int,int&gt;pp[MAXN];int link[MAXN];long long ans1[MAXN],ans2[MAXN];int main()&#123; int __size__ = 256 &lt;&lt; 20;char * __p__ = (char *) malloc(__size__) + __size__;__asm__("movl %0,%%esp\n"::"r"(__p__)); //freopen("in.txt","r",stdin); //freopen("out2.txt","w",stdout); int n,m; int T; int iCase = 0; scanf("%d",&amp;T); while(T--)&#123; iCase++; init(); scan_d(n); scan_d(m); memset(w1,0,sizeof(w1)); memset(w2,0,sizeof(w2)); int u,v,w; for(int i = 1;i &lt; n;i++)&#123; scan_d(u); scan_d(v); addedge(u,v); addedge(v,u); pp[i] = make_pair(u,v); &#125; dfs1(1,0,0); getpos(1,1); for(int i = 1;i &lt; n;i++)&#123; if(deep[pp[i].first] &gt; deep[pp[i].second]) swap(pp[i].first,pp[i].second); link[pp[i].second] = i; &#125; char op[10]; while(m--)&#123; scanf("%s",op); scan_d(u); scan_d(v); scan_d(w); if(op[3] == '1')&#123; add1(u,v,w); &#125; else add2(u,v,w); &#125; for(int i = 1;i &lt;= n;i++)&#123; w1[i] += w1[i-1]; w2[i] += w2[i-1]; ans1[fp[i]] = w1[i]; ans2[link[fp[i]]] = w2[i]; &#125; printf("Case #%d:\n",iCase); for(int i = 1;i &lt;= n;i++)&#123; //printf("%I64d",ans1[i]); out(ans1[i]); if(i &lt; n)printf(" "); else printf("\n"); &#125; for(int i = 1;i &lt; n;i++)&#123; //printf("%I64d",ans2[i]); out(ans2[i]); if(i &lt; n-1)printf(" "); &#125; printf("\n"); &#125; return 0;&#125; 1004 HDU5045 直接状压DP。 可能题意好多人没理解，但是该表述的都表述清楚了，英语太渣了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* ***************Author :kuangbinCreated Time :2014/9/10 20:04:53File Name :D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;double dp[1010][1&lt;&lt;10];bool vis[1010][1&lt;&lt;10];double p[10][1010];int n,m;double solve(int id,int s)&#123; if(s == (1&lt;&lt;n)-1)s = 0; if(vis[id][s])return dp[id][s]; vis[id][s] = true; dp[id][s] = 0; if(id == m)return dp[id][s]; for(int i = 0;i &lt; n;i++)&#123; if(s&amp;(1&lt;&lt;i))continue; dp[id][s] = max(dp[id][s],(1-p[i][id])*solve(id+1,s|(1&lt;&lt;i))+p[i][id]*(solve(id+1,s|(1&lt;&lt;i))+1)); &#125; return dp[id][s];&#125;int main()&#123; //freopen("D.in","r",stdin); //freopen("D.out","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); while(T--)&#123; iCase++; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) scanf("%lf",&amp;p[i][j]); memset(vis,false,sizeof(vis)); printf("Case #%d: %.5lf\n",iCase,solve(0,0)); &#125; return 0;&#125; 1005： HDU5046 直接DLX模板题！！！ 有点裸！ 而且貌似好多人被卡了！！！模板不够优啊！ 这题3倍标程了，感觉也够了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int maxnode = 4000;const int MaxM = 70;const int MaxN = 70;int K;struct DLX&#123; int n,m,size; int U[maxnode],D[maxnode],R[maxnode],L[maxnode],Row[maxnode],Col[maxnode]; int H[MaxN],S[MaxM]; int ands,ans[MaxN]; void init(int _n,int _m) &#123; n = _n; m = _m; for(int i = 0;i &lt;= m;i++) &#123; S[i] = 0; U[i] = D[i] = i; L[i] = i-1; R[i] = i+1; &#125; R[m] = 0; L[0] = m; size = m; for(int i = 1;i &lt;= n;i++) H[i] = -1; &#125; void Link(int r,int c) &#123; ++S[Col[++size]=c]; Row[size] = r; D[size] = D[c]; U[D[c]] = size; U[size] = c; D[c] = size; if(H[r] &lt; 0)H[r] = L[size] = R[size] = size; else &#123; R[size] = R[H[r]]; L[R[H[r]]] = size; L[size] = H[r]; R[H[r]] = size; &#125; &#125; void remove(int c) &#123; for(int i = D[c];i != c;i = D[i]) L[R[i]] = L[i], R[L[i]] = R[i]; &#125; void resume(int c) &#123; for(int i = U[c];i != c;i = U[i]) L[R[i]]=R[L[i]]=i; &#125; bool v[maxnode]; int f() &#123; int ret = 0; for(int c = R[0];c != 0;c = R[c])v[c] = true; for(int c = R[0];c != 0;c = R[c]) if(v[c]) &#123; ret++; v[c] = false; for(int i = D[c];i != c;i = D[i]) for(int j = R[i];j != i;j = R[j]) v[Col[j]] = false; &#125; return ret; &#125; bool Dance(int d) &#123; if(d + f() &gt; K)return false; if(R\[0\] == 0)return d &lt;= K; int c = R\[0\]; for(int i = R\[0\];i != 0;i = R\[i\]) if(S\[i\] &lt; S\[c\]) c = i; for(int i = D\[c\];i != c;i = D\[i\]) &#123; remove(i); for(int j = R\[i\];j != i;j = R\[j\])remove(j); if(Dance(d+1))return true; for(int j = L\[i\];j != i;j = L\[j\])resume(j); resume(i); &#125; return false; &#125;&#125;;DLX g;struct Point&#123; int x,y; void input() &#123; scanf("%d%d",&amp;x,&amp;y); &#125;&#125;city[MaxM];long long dis(Point a,Point b)&#123; return (long long)abs(a.x-b.x)+(long long)abs(a.y-b.y);&#125;int main()&#123; //freopen("E.in","r",stdin); //freopen("E.out","w",stdout); int T; int n; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; scanf("%d%d",&amp;n,&amp;K); assert(n &gt;= 1 &amp;&amp; n &lt;= 60 &amp;&amp; K &gt;= 1 &amp;&amp; K &lt;= n); for(int i = 0;i &lt; n;i++)&#123; city[i].input(); assert(abs(city[i].x) &lt;= 1000000000); assert(abs(city[i].y) &lt;= 1000000000); &#125; long long l = 0, r = 100000000000LL; long long ans = 0; while(l &lt;= r) &#123; long long mid = (l+r)/2; g.init(n,n); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(dis(city[i],city[j]) &lt;= mid) g.Link(i+1,j+1); if(g.Dance(0))&#123;r = mid-1;ans = mid;&#125; else l = mid+1; &#125; printf("Case #%d: %I64d\n",iCase,ans); &#125; return 0;&#125; 1006： [HDU5047](http://acm.hdu.edu.cn/showproblem.php?pid=5047) 直接根据多少个交点，多少个边，然后就是推公式。 很简单，故意组数比较多，可能少数JAVA. sorry. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251/* ***************Author :kuangbinCreated Time :2014/9/11 13:19:51File Name :F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;/* * 高精度，支持乘法和加法 */struct BigInt&#123; const static int mod = 10000; const static int DLEN = 4; int a[600],len; BigInt() &#123; memset(a,0,sizeof(a)); len = 1; &#125; BigInt(long long v) &#123; memset(a,0,sizeof(a)); len = 0; do &#123; a[len++] = v%mod; v /= mod; &#125;while(v); &#125; BigInt(const char s[]) &#123; memset(a,0,sizeof(a)); int L = strlen(s); len = L/DLEN; if(L%DLEN)len++; int index = 0; for(int i = L-1;i &gt;= 0;i -= DLEN) &#123; int t = 0; int k = i - DLEN + 1; if(k &lt; 0)k = 0; for(int j = k;j &lt;= i;j++) t = t*10 + s[j] - '0'; a[index++] = t; &#125; &#125; BigInt operator +(const BigInt &amp;b)const &#123; BigInt res; res.len = max(len,b.len); for(int i = 0;i &lt;= res.len;i++) res.a[i] = 0; for(int i = 0;i &lt; res.len;i++) &#123; res.a[i] += ((i &lt; len)?a[i]:0)+((i &lt; b.len)?b.a[i]:0); res.a[i+1] += res.a[i]/mod; res.a[i] %= mod; &#125; if(res.a[res.len] &gt; 0)res.len++; return res; &#125; BigInt operator *(const BigInt &amp;b)const &#123; BigInt res; for(int i = 0; i &lt; len;i++) &#123; int up = 0; for(int j = 0;j &lt; b.len;j++) &#123; int temp = a[i]*b.a[j] + res.a[i+j] + up; res.a[i+j] = temp%mod; up = temp/mod; &#125; if(up != 0) res.a[i + b.len] = up; &#125; res.len = len + b.len; while(res.a[res.len - 1] == 0 &amp;&amp;res.len &gt; 1)res.len--; return res; &#125; void output() &#123; printf("%d",a[len-1]); for(int i = len-2;i &gt;=0 ;i--) printf("%04d",a[i]); printf("\n"); &#125;&#125;;BigInt A,B;int main()&#123; //freopen("F.in","r",stdin); //freopen("F.out","w",stdout); int iCase = 0; int T; scanf("%d",&amp;T); assert(T &gt;= 1 &amp;&amp; T &lt;= 100000); assert(T == 100000); long long n; while(T--)&#123; iCase++; scanf("%I64d",&amp;n); assert(n &gt;= 0 &amp;&amp; n &lt;= 1000000000000LL); if(n == 0)&#123; printf("Case #%d: 1\n",iCase); continue; &#125; A = (BigInt(n)*BigInt(8*n-7))+1; printf("Case #%d: ",iCase); A.output(); &#125; return 0;&#125; 1007: [HDU5048](http://acm.hdu.edu.cn/showproblem.php?pid=5048) 比较水的几何了。 只要解方程去求线段和椭球的交点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397/* ***************Author :kuangbinCreated Time :2014/9/15 17:56:58File Name :E:\2014ACM\题目_上海网络赛\color\标程\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const double eps = 1e-8;inline double sqr(double x)&#123;return x*x;&#125;struct Point&#123; double x,y,z; void input()&#123; scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;z); assert(fabs(x) &lt;= 10000); assert(fabs(y) &lt;= 10000); assert(fabs(z) &lt;= 10000); &#125;&#125;;struct Line&#123; Point s,e; void input()&#123; s.input(); e.input(); &#125; double len()&#123; return sqrt((s.x-e.x)(s.x-e.x)+(s.y-e.y)(s.y-e.y)+(s.z-e.z)*(s.z-e.z)); &#125;&#125;;struct Ellipsoid&#123; double x,y,z,a,b,c; char color[5]; void input()&#123; scanf("%lf%lf%lf%lf%lf%lf%s",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c,color); assert(fabs(x) &lt;= 10000); assert(fabs(y) &lt;= 10000); assert(fabs(z) &lt;= 10000); assert(a &gt;= 1 &amp;&amp; a &lt;= 10000); assert(b &gt;= 1 &amp;&amp; b &lt;= 10000); assert(c &gt;= 1 &amp;&amp; c &lt;= 10000); assert(color[0] == 'R' || color[0] == 'G' || color[0] == 'B'); &#125; void output()&#123; printf("%lf %lf %lf %lf %lf %lf %s\n",x,y,z,a,b,c,color); &#125;&#125;;double calc(vector&lt;Line&gt;line,vector&lt;Ellipsoid&gt;el)&#123; //for(int i = 0; i &lt; el.size();i++) //el[i].output(); double ans = 0; int sz1 = line.size(); for(int i = 0;i &lt; sz1;i++)&#123; vector&lt;pair&lt;double,int&gt; &gt;vec; vec.push_back(make_pair(0.0,0)); vec.push_back(make_pair(1.0,0)); double len = line[i].len(); if(fabs(len) &lt; eps)continue; double x1 = line[i].s.x; double y1 = line[i].s.y; double z1 = line[i].s.z; double dx = line[i].e.x - line[i].s.x; double dy = line[i].e.y - line[i].s.y; double dz = line[i].e.z - line[i].s.z; //printf("%lf %lf %lf %lf %lf %lf\n",line[i].s.x,line[i].s.y,line[i].s.z,line[i].e.x,line[i].e.y,line[i].e.z); int sz = el.size(); for(int j = 0;j &lt; sz;j++)&#123; double a = sqr(dx)/sqr(el[j].a) + sqr(dy)/sqr(el[j].b) + sqr(dz)/sqr(el[j].c); double b = 2*dx*(x1-el[j].x)/sqr(el[j].a) + 2*dy*(y1-el[j].y)/sqr(el[j].b) + 2*dz*(z1-el[j].z)/sqr(el[j].c); double c = sqr(x1-el[j].x)/sqr(el[j].a) + sqr(y1-el[j].y)/sqr(el[j].b) \+ sqr(z1-el[j].z)/sqr(el[j].c) - 1; double delta = b*b - 4*a*c; //cout&lt;&lt;delta&lt;&lt;endl; if(delta &lt; eps)continue; double k1 = (-b+sqrt(delta))/(2*a); double k2 = (-b-sqrt(delta))/(2*a); //printf("a %.10lf b %.10lf c %.10lf \n",a,b,c); //printf("%.10lf %.10lf\n",k1,k2); if(k1 &gt; k2)swap(k1,k2); k1 = max(0.0,k1); k2 = min(1.0,k2); //printf("%.10lf %.10lf\n",k1,k2); if(k1 &gt;= k2)continue; vec.push_back(make_pair(k1,1)); vec.push_back(make_pair(k2,-1)); &#125; int cnt = 0; sort(vec.begin(),vec.end()); int sz2 = vec.size(); double pre = 0; for(int j = 0;j &lt; sz2;j++)&#123; if(cnt &gt; 0) ans += (vec[j].first - pre)*len; pre = vec[j].first; cnt += vec[j].second; &#125; &#125; return ans;&#125;Line line[110];Ellipsoid el[110];vector&lt;Line&gt;vec1;vector&lt;Ellipsoid&gt;vec2;int main()&#123; //freopen("G.in","r",stdin); //freopen("G.out","w",stdout); int T; scanf("%d",&amp;T); assert(T &gt;= 1 &amp;&amp; T &lt;= 100); int iCase = 0; int n,m; while(T--)&#123; iCase++; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++)line[i].input(); for(int i = 0;i &lt; m;i++)&#123; el[i].input(); // printf("i %d %c\n",i,el[i].color[0]); &#125; vec1.clear(); for(int i = 0;i &lt; n;i++)vec1.push_back(line[i]); double tot = 0; for(int i = 0;i &lt; n;i++)tot += line[i].len(); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'R') vec2.push_back(el[i]); double R = calc(vec1,vec2); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'G') vec2.push_back(el[i]); double G = calc(vec1,vec2); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'B') vec2.push_back(el[i]); double B = calc(vec1,vec2); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'R' || el[i].color[0] == 'G') vec2.push_back(el[i]); double RG = calc(vec1,vec2); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'R' || el[i].color[0] == 'B') vec2.push_back(el[i]); double RB = calc(vec1,vec2); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'G' || el[i].color[0] == 'B') vec2.push_back(el[i]); double GB = calc(vec1,vec2); vec2.clear(); for(int i = 0;i &lt; m;i++) if(el[i].color[0] == 'R' || el[i].color[0] == 'G' || el[i].color[0] == 'B') vec2.push_back(el[i]); double RGB = calc(vec1,vec2); //printf("tot %.6lf R %lf G %lf B %lf RG %lf RB %lf GB %lf RGB %lf\n",tot,R,G,B,RG,RB,GB,RGB); double ans1 = RGB - GB; double ans2 = RGB - RB; double ans3 = RGB - RG; double ans4 = RGB - B - ans1 - ans2; double ans5 = RGB - G - ans1 - ans3; double ans6 = RGB - R - ans2 - ans3; double ans7 = R + G - RG - ans4; double aa = tot-RGB; if(fabs(aa) &lt; eps)aa = 0; if(fabs(ans1) &lt; eps)ans1 = 0; if(fabs(ans2) &lt; eps)ans2 = 0; if(fabs(ans3) &lt; eps)ans3 = 0; if(fabs(ans4) &lt; eps)ans4 = 0; if(fabs(ans5) &lt; eps)ans5 = 0; if(fabs(ans6) &lt; eps)ans6 = 0; if(fabs(ans7) &lt; eps)ans7 = 0; //printf("Case #%d:\n",iCase); printf("%.10lf\n",aa); printf("%.10lf\n",ans1); printf("%.10lf\n",ans2); printf("%.10lf\n",ans3); printf("%.10lf\n",ans4); printf("%.10lf\n",ans5); printf("%.10lf\n",ans6); printf("%.10lf\n",ans7); &#125; return 0;&#125; 1008： [HDU5049](http://acm.hdu.edu.cn/showproblem.php?pid=5049) 就是一个简单的DP。 使用矩阵去优化。 故意把范围设的不大的，太大一想就是矩阵了。 注意特判一些情况。 还有答案为0，可能不是 Impossible. 故意造的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477/* ***************Author :kuangbinCreated Time :2014/9/16 22:41:06File Name :E:\2014ACM\题目_上海网络赛\Guess\标程\H.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int MOD = 20140927;struct Matrix&#123; int mat[2][2]; void init()&#123; memset(mat,0,sizeof(mat)); &#125; Matrix operator *(const Matrix &amp;b)const&#123; Matrix ret; for(int i = 0;i &lt; 2;i++) for(int j = 0;j &lt; 2;j++)&#123; ret.mat[i][j] = 0; for(int k = 0;k &lt; 2;k++)&#123; ret.mat[i][j] += (long long)mat[i][k]*b.mat[k][j]%MOD; if(ret.mat[i][j] &gt;= MOD) ret.mat[i][j] -= MOD; &#125; &#125; return ret; &#125; void output()&#123; printf("%d %d\n%d %d\n",mat[0][0],mat[0][1],mat[1][0],mat[1][1]); &#125;&#125;;Matrix pow_M(Matrix A,int n)&#123; Matrix ret; ret.mat[0][0] = ret.mat[1][1] = 1; ret.mat[0][1] = ret.mat[1][0] = 0; Matrix tmp = A; while(n)&#123; if(n&amp;1)ret = ret*tmp; tmp = tmp*tmp; n &gt;&gt;= 1; &#125; return ret;&#125;Matrix A[11*11*11 + 100];vector&lt;int&gt;vec;Matrix B;Matrix C;struct Matrix2&#123; int mat[2][2]; void init()&#123; memset(mat,0,sizeof(mat)); &#125; Matrix2 operator *(const Matrix2 &amp;b)const&#123; Matrix2 ret; for(int i = 0;i &lt; 2;i++) for(int j = 0;j &lt; 2;j++)&#123; ret.mat[i][j] = 0; for(int k = 0;k &lt; 2;k++) if(mat[i][k] &amp;&amp; b.mat[k][j]) ret.mat[i][j] = 1; &#125; return ret; &#125;&#125;;Matrix2 pow_M(Matrix2 A,int n)&#123; Matrix2 ret; ret.mat[0][0] = ret.mat[1][1] = 1; ret.mat[0][1] = ret.mat[1][0] = 0; Matrix2 tmp = A; while(n)&#123; if(n&amp;1)ret = ret*tmp; tmp = tmp*tmp; n &gt;&gt;= 1; &#125; return ret;&#125;Matrix2 A2[11*11*11 + 100];Matrix2 B2;Matrix2 C2;void Add(int &amp;a,int b)&#123; if(a || b)a = 1;&#125;int main()&#123; //freopen("H.in","r",stdin); //freopen("H.out","w",stdout); for(int i = 0;i &lt; 11*11*11;i++)A[i].init(); for(int i = 0;i &lt; 11*11*11;i++)A2[i].init(); for(int x = 0;x &lt; 11;x++) for(int y = 0;y &lt; 11;y++) for(int z = 0; z &lt; 11;z++)&#123; int id = x*11*11 + y*11 + z; for(int i = 0;i &lt; 10;i++)&#123; if(x != 10 &amp;&amp; x != i)continue; for(int j = 0;j &lt; 10;j++)&#123; if(y != 10 &amp;&amp; y != j)continue; for(int k = 0;k &lt; 10;k++)&#123; if(z != 10 &amp;&amp; z != k)continue; if(i + j == k)A[id].mat[0][0]++; if(i + j == 10 + k)A[id].mat[0][1]++; if(i + j + 1 == k)A[id].mat[1][0]++; if(i + j + 1 == 10 + k)A[id].mat[1][1]++; if(i + j == k)Add(A2[id].mat[0][0],1); if(i + j == 10 + k)Add(A2[id].mat[0][1],1); if(i + j + 1 == k)Add(A2[id].mat[1][0],1); if(i + j + 1 == 10 + k)Add(A2[id].mat[1][1],1); &#125; &#125; &#125; &#125; int T; int iCase = 0; int n1,m1,n2,m2,n3,m3; scanf("%d",&amp;T); while(T--)&#123; iCase++; scanf("%d%d",&amp;n1,&amp;m1); assert(n1 &gt;= 1 &amp;&amp; n1 &lt;= 10000000); assert(m1 &gt;= 0 &amp;&amp; m1 &lt;= n1); map&lt;int,int&gt;mp1; map&lt;int,int&gt;mp2; map&lt;int,int&gt;mp3; bool flag = true; vec.clear(); int id,x; while(m1--)&#123; scanf("%d%d",&amp;id,&amp;x); id = n1 - 1 - id; vec.push_back(id); if(mp1.find(id) != mp1.end())&#123; if(mp1[id] != x)flag = false; &#125; else mp1[id] = x; &#125; scanf("%d%d",&amp;n2,&amp;m2); assert(n2 &gt;= 1 &amp;&amp; n2 &lt;= 10000000); assert(m2 &gt;= 0 &amp;&amp; m2 &lt;= n2); while(m2--)&#123; scanf("%d%d",&amp;id,&amp;x); id = n2 - 1 - id; vec.push_back(id); if(mp2.find(id) != mp2.end())&#123; if(mp2[id] != x)flag = false; &#125; else mp2[id] = x; &#125; scanf("%d%d",&amp;n3,&amp;m3); assert(n3 &gt;= 1 &amp;&amp; n3 &lt;= 10000000); assert(m3 &gt;= 0 &amp;&amp; m3 &lt;= n3); while(m3--)&#123; scanf("%d%d",&amp;id,&amp;x); id = n3 - 1 - id; vec.push_back(id); if(mp3.find(id) != mp3.end())&#123; if(mp3[id] != x)flag = false; &#125; else mp3[id] = x; &#125; if((!flag) || (n1 &lt; max(n2,n3)) || (n1 &gt; max(n2,n3)+1))&#123; printf("Case #%d: IMPOSSIBLE\n",iCase); continue; &#125; //vec.push_back(n1-1); vec.push_back(n2-1); vec.push_back(n3-1); sort(vec.begin(),vec.end()); vec.erase(unique(vec.begin(),vec.end()),vec.end()); int mn = max(n2,n3); B.init(); B.mat[0][0] = B.mat[1][1] = 1; B2.init(); B2.mat[0][0] = B2.mat[1][1] = 1; if(vec[0] &gt; 0)B = B * pow_M(A[10*11*11+10*11+10],vec[0]); if(vec[0] &gt; 0)B2 = B2 * pow_M(A2[10*11*11+10*11+10],vec[0]); int sz = vec.size(); for(int i = 0;i &lt; sz;i++)&#123; //printf("%d\n",vec[i]); //B.output(); if(i &gt; 0)&#123; B = B * pow_M(A[10*11*11+10*11+10],vec[i]-vec[i-1]-1); &#125; int x,y,z; if(mp2.find(vec[i]) == mp2.end())x = 10; else x = mp2[vec[i]]; if(vec[i] &gt;= n2)x = 0; if(mp3.find(vec[i]) == mp3.end())y = 10; else y = mp3[vec[i]]; if(vec[i] &gt;= n3)y = 0; if(mp1.find(vec[i]) == mp1.end())z = 10; else z = mp1[vec[i]]; if(vec[i] &gt;= n1)z = 0; if(vec[i] != n2-1 &amp;&amp; vec[i] != n3-1)&#123; B = B * A[x*11*11+y*11+z]; B2 = B2 * A2[x*11*11+y*11+z]; &#125; else &#123; C.init(); C2.init(); for(int p = 0;p &lt; 10;p++) for(int q = 0;q &lt; 10;q++) for(int r = 0;r &lt; 10;r++)&#123; if(x != 10 &amp;&amp; p != x)continue; if(y != 10 &amp;&amp; q != y)continue; if(z != 10 &amp;&amp; r != z)continue; if(n2 != 1 &amp;&amp; vec[i] == n2-1 &amp;&amp; p == 0)continue; if(n3 != 1 &amp;&amp; vec[i] == n3-1 &amp;&amp; q == 0)continue; if(vec[i] &gt;= n2 &amp;&amp; p != 0)continue; if(vec[i] &gt;= n3 &amp;&amp; q != 0)continue; if(p+q == r)C.mat[0][0]++; if(p+q == r+10)C.mat[0][1]++; if(p+q+1 == r)C.mat[1][0]++; if(p+q+1 == r + 10)C.mat[1][1]++; if(p+q == r)Add(C2.mat\[0\]\[0\],1); if(p+q == r+10)Add(C2.mat\[0\]\[1\],1); if(p+q+1 == r)Add(C2.mat\[1\]\[0\],1); if(p+q+1 == r + 10)Add(C2.mat\[1\]\[1\],1); &#125; //C.output(); B = B*C; B2 = B2*C2; &#125; &#125; int ans = 0; int ans2 = 0; if(n1 == max(n2,n3))&#123; ans = B.mat\[0\]\[0\]; ans2 = B2.mat\[0\]\[0\]; &#125; else&#123; if(mp1.find(n1-1) != mp1.end() &amp;&amp; mp1\[n1-1\] != 1)&#123; printf("Case #%d: IMPOSSIBLE\\n",iCase); continue; &#125; ans = B.mat\[0\]\[1\]; ans2 = B2.mat\[0\]\[1\]; &#125; //printf("%d %d\\n",ans,ans2); if(ans2 == 0)printf("Case #%d: IMPOSSIBLE\\n",iCase); else printf("Case #%d: %d\\n",iCase,ans); &#125; return 0;&#125; 1009： [HDU5050](http://acm.hdu.edu.cn/showproblem.php?pid=5050) 就是求两个大数的GCD。 JAVA可以随便搞！ 本题定位就是签到题。当然C++也可以搞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225/* ***************Author :kuangbinCreated Time :2014/9/18 16:43:54File Name :F:\题目_上海网络赛\dividedland\标程\I.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;struct BigNum&#123; int a[10100]; int n; void input(char str[])&#123; n = strlen(str); for(int i = 0;i &lt; n;i++) a[i] = str[n-1-i]-'0'; &#125; bool operator &lt;(const BigNum &amp;b)const&#123; if(n &lt; b.n)return true; if(n &gt; b.n)return false; for(int i = n-1;i &gt;= 0;i--)&#123; if(a[i] &lt; b.a[i])return true; if(a[i] &gt; b.a[i])return false; &#125; return true; &#125; BigNum operator -(const BigNum &amp;b)const&#123; BigNum ret; ret.n = n; int mu = 0; for(int i = 0;i &lt; n;i++)&#123; int tmp; if(i &lt; b.n)tmp = a[i] - b.a[i] - mu; else tmp = a[i] - mu; if(tmp &gt;= 0)&#123; mu = 0; ret.a[i] = tmp; &#125; else &#123; mu = 1; ret.a[i] = tmp+2; &#125; &#125; while(ret.n &gt; 0 &amp;&amp; ret.a[ret.n-1] == 0)ret.n--; return ret; &#125; BigNum div2()&#123; BigNum ret; ret.n = n-1; for(int i = 0;i &lt; n-1;i++) ret.a[i] = a[i+1]; return ret; &#125; void output()&#123; for(int i = n-1;i &gt;= 0;i--) printf("%d",a[i]); &#125;&#125;;void gcd(BigNum a,BigNum b)&#123; int c2 = 0; while(a.n &amp;&amp; b.n)&#123; if(a.a[0])&#123; if(b.a[0])&#123; if(b &lt; a)a = a-b; else b = b-a; &#125; else b = b.div2(); &#125; else &#123; if(b.a[0])a = a.div2(); else&#123; a = a.div2(); b = b.div2(); c2++; &#125; &#125; &#125; if(a.n)a.output(); else b.output(); while(c2--)&#123; printf("0"); &#125; printf("\n");&#125;char str[10010];BigNum a,b,c;int main()&#123; //freopen("I.in","r",stdin); //freopen("I.out","w",stdout); int T; scanf("%d",&amp;T); int iCase = 0; while(T--)&#123; iCase++; scanf("%s",str); a.input(str); scanf("%s",str); b.input(str); printf("Case #%d: ",iCase); gcd(a,b); &#125; return 0;&#125; 1010： [HDU5051](http://acm.hdu.edu.cn/showproblem.php?pid=5051) Benford&apos;s law http://baike.baidu.com/view/1405011.htm?from_id=11319476&amp;type=syn&amp;fromtitle=Benford%27s+law&amp;fr=aladdin http://zh.wikipedia.org/wiki/%E6%9C%AC%E7%A6%8F%E7%89%B9%E5%AE%9A%E5%BE%8B 这个教练提供的题。 特判一些情况就可以AC了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* ***************Author :kuangbinCreated Time :2014/9/18 20:01:40File Name :F:\题目_上海网络赛\fraction\标程\J.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("J.in","r",stdin); //freopen("J.out","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); int n,b,q; while(T--)&#123; iCase++; scanf("%d%d%d",&amp;n,&amp;b,&amp;q); printf("Case #%d: ",iCase); if(q == 1)&#123; bool flag = false; while(b)&#123; if(n == b)&#123; flag = true; break; &#125; b /= 10; &#125; if(flag)printf("1.00000\n"); else printf("0.00000\n"); &#125; else if(q == 10 || q == 100 || q == 1000)&#123; b *= 100000; bool flag = false; while(b)&#123; if(n == b)&#123; flag = true; break; &#125; b /= 10; &#125; if(flag)printf("1.00000\n"); else printf("0.00000\n"); &#125; else &#123; double ans = (log(n+1)-log(n))/log(10); printf("%.5lf\n",ans); &#125; &#125; return 0;&#125; 1011： [HDU5052](http://acm.hdu.edu.cn/showproblem.php?pid=5052) shumj出的LCT题。 直接LCT搞就可以了。 LCT的姿势不够优美可能被卡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393/* ***************Author :kuangbinCreated Time :2014/9/18 21:59:15File Name :K.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int MAXN = 50010;const int INF = 0x3f3f3f3f;struct Node *null;struct Node&#123; Node *fa,*ch[2]; int val; int Max,Min; int mm; int rmm; int rev,add; inline void clear(int _val)&#123; fa = ch[0] = ch[1] = null; val = Max = Min = _val; mm = 0; rmm = 0; rev = 0; add = 0; &#125; inline void push_up()&#123; if(this == null)return; mm = 0; mm = max(mm,ch[0]-&gt;mm); mm = max(mm,ch[1]-&gt;mm); mm = max(mm,max(val,ch[1]-&gt;Max)-ch[0]-&gt;Min); mm = max(mm,ch[1]-&gt;Max-min(ch[0]-&gt;Min,val)); rmm = 0; rmm = max(rmm,ch[0]-&gt;rmm); rmm = max(rmm,ch[1]-&gt;rmm); rmm = max(rmm,max(val,ch[0]-&gt;Max)-ch[1]-&gt;Min); rmm = max(rmm,ch[0]-&gt;Max-min(ch[1]-&gt;Min,val)); Max = max(val,max(ch[0]-&gt;Max,ch[1]-&gt;Max)); Min = min(val,min(ch[0]-&gt;Min,ch[1]-&gt;Min)); &#125; inline void setc(Node *p,int d)&#123; ch[d] = p; p-&gt;fa = this; &#125; inline bool d()&#123; return fa-&gt;ch[1] == this; &#125; inline bool isroot()&#123; return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; &#125; inline void flip()&#123; if(this == null)return; swap(ch[0],ch[1]); swap(mm,rmm); rev ^= 1; &#125; inline void update_add(int w)&#123; if(this == null)return; val += w; Min += w; Max += w; add += w; &#125; inline void push_down()&#123; if(this == null)return; if(rev)&#123; ch[0]-&gt;flip(); ch[1]-&gt;flip(); rev = 0; &#125; if(add)&#123; ch[0]-&gt;update_add(add);ch[1]-&gt;update_add(add); add = 0; &#125; &#125; inline void go()&#123; if(!isroot())fa-&gt;go(); push_down(); &#125; inline void rot()&#123; Node *f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); &#125; inline Node* splay()&#123; go(); while(!isroot())&#123; if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); &#125; push_up(); return this; &#125; inline Node* access()&#123; for(Node *p = this, *q = null; p != null; q = p, p = p-&gt;fa)&#123; p-&gt;splay()-&gt;setc(q,1); p-&gt;push_up(); &#125; return splay(); &#125; inline void make_root()&#123; access()-&gt;flip(); &#125;&#125;;Node pool[MAXN],*tail;Node *node[MAXN];struct Edge&#123; int to,next;&#125;edge[MAXN*2];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;inline void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int g[MAXN];int fa[MAXN];void bfs(int s)&#123; int l,r; g[l=r=1] = s; fa[s] = s; while(l &lt;= r)&#123; int u = g[l++]; for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[u])continue; fa[v] = u; node[v]-&gt;fa = node[u]; g[++r] = v; &#125; &#125;&#125;int main()&#123; //freopen("big1.in","r",stdin); //freopen("out1.txt","w",stdout); int T; int n,m; scanf("%d",&amp;T); assert(T &gt; 0 &amp;&amp; T &lt;= 10); while(T--)&#123; scanf("%d",&amp;n); //assert(n &gt; 0 &amp;&amp; n &lt;= 50000); tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;Max = -INF; null-&gt;Min = INF; null-&gt;mm = 0; null-&gt;add = null-&gt;rev = 0; int w; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d",&amp;w); //assert(w &gt; 0 &amp;&amp; w &lt;= 10000); node[i] = tail++; node[i]-&gt;clear(w); &#125; init(); int u,v; for(int i = 1;i &lt; n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; bfs(1); scanf("%d",&amp;m); while(m--)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); //assert(u &gt;= 1 &amp;&amp; u &lt;= n &amp;&amp; v &gt;= 1 &amp;&amp; v &lt;= n); //assert(w &gt; 0 &amp;&amp; w &lt;= 10000); node[u]-&gt;make_root(); node[v]-&gt;access(); printf("%d\n",node[v]-&gt;mm); node[v]-&gt;update_add(w); &#125; &#125; return 0;&#125; 1012： [HDU5053](http://acm.hdu.edu.cn/showproblem.php?pid=5053) 签到题！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* ***************Author :kuangbinCreated Time :2014/9/27 10:51:53File Name :E:\2014ACM\题目_上海网络赛\cube\标程\L.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("L.in","r",stdin); //freopen("L.out","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); long long a,b; while(T--)&#123; iCase++; scanf("%I64d%I64d",&amp;a,&amp;b); a--; long long ans = (b(b+1)/2)(b(b+1)/2) - (a(a+1)/2)(a(a+1)/2); printf("Case #%d: %I64d\n",iCase,ans); &#125; return 0;&#125; 再次为两次Rejudge深表歉意！]]></content>
      <categories>
        <category>Contest</category>
        <category>Online Judge</category>
        <category>套题</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4918 Query on the subtree （树分治）]]></title>
    <url>%2F2014%2F09%2F26%2Fhdu4918%2F</url>
    <content type="text"><![CDATA[HDU4918 经典的树分治的题目。 进行点分治。 题意： 给一颗树，每个点有权值。 两种操作： 一种是把某个点的权值改为v. 一种是查询距离u不超过d的权值和。 树分治结合树状数组去搞。 树分治的关键就是每个点最多被logn个点更新到。 这样的话，就很容易搞了、 Query on the subtreeTime Limit: 16000/8000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 320 Accepted Submission(s): 109 Problem Description bobo has a tree, whose vertices are conveniently labeled by 1,2,…,n. At the very begining, the i-th vertex is assigned with weight wi.There are q operations. Each operations are of the following 2 types: Change the weight of vertex v into x (denoted as “! v x”), Ask the total weight of vertices whose distance are no more than d away from vertex v (denoted as “? v d”). Note that the distance between vertex u and v is the number of edges on the shortest path between them. Input The input consists of several tests. For each tests:The first line contains n,q (1≤n,q≤105). The second line contains n integers w1,w2,…,wn (0≤wi≤104). Each of the following (n - 1) lines contain 2 integers ai,bidenoting an edge between vertices ai and bi (1≤ai,bi≤n). Each of the following q lines contain the operations (1≤v≤n,0≤x≤104,0≤d≤n). Output For each tests:For each queries, a single number denotes the total weight. Sample Input 4 3 1 1 1 1 1 2 2 3 3 4 ? 2 1 ! 1 0 ? 2 1 3 3 1 2 3 1 2 1 3 ? 1 0 ? 1 1 ? 1 2 Sample Output 3 2 1 6 6 Author Xiaoxu Guo (ftiasch) Source 2014 Multi-University Training Contest 5 /* ***Author :kuangbinCreated Time :2014/9/25 23:04:05File Name :E:\2014ACM\专题学习\树分治\HDU4918.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int MAXD = 40;int cc[MAXNMAXD];int cc_tail; //记得初始化cc_tail = cc//0-based BinaryIndexTreestruct BIT{ int c; int n; void init(int _n){ n = _n; c = cc_tail; cc_tail = cc_tail + n; memset(c,0,sizeof(int)n); } void add(int i,int val){ while(i &lt; n){ c[i] += val; i += ~i &amp; i+1; } } int sum(int i){ i = min(i,n-1); int s = 0; while(i &gt;= 0){ s += c[i]; i -= ~i &amp; i+1; } return s; }}bits[MAXN&lt;&lt;1];struct Edge{ int to,next;}edge[MAXN*2];int head[MAXN],tot;void init(){ tot = 0; memset(head,-1,sizeof(head));}inline void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}int size[MAXN],vis[MAXN],fa[MAXN],que[MAXN];int TT;inline int getroot(int u,int &amp;tot){ int Min = MAXN, root = 0; int l,r; que[l = r = 1] = u; fa[u] = 0; for(;l &lt;= r;l++) for(int i = head[que[l]];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == fa[que[l]] || vis[v] == TT)continue; que[++r] = v; fa[v] = que[l]; } tot = r; for(l–;l;l–){ int x = que[l], Max = 0; size[x] = 1; for(int i = head[x];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == fa[x] || vis[v] == TT)continue; Max = max(Max,size[v]); size[x] += size[v]; } Max = max(Max,r - size[x]); if(Max &lt; Min){ Min = Max, root = x; } } return root;}struct Node{ int root,subtree,dis; Node(int _root = 0, int _subtree = 0,int _dis = 0){ root = _root; subtree = _subtree; dis = _dis; }};vectorvec[MAXN];int id[MAXN];int dist[MAXN];int val[MAXN];int cnt;inline void go(int u,int root,int subtree){ int l,r; que[l = r = 1] = u; fa[u] = 0; dist[u] = 1; for(; l &lt;= r;l++){ u = que[l]; vec[u].push_back(Node(id[root],subtree,dist[u])); for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == fa[u] || vis[v] == TT)continue; que[++r] = v; fa[v] = u; dist[v] = dist[u] + 1; } } bits[subtree].init(r+1); for(int i = 1;i &lt;= r;i++){ u = que[i]; bits[id[root]].add(dist[u],val[u]); bits[subtree].add(dist[u],val[u]); }}void solve(int u){ int tot; int root = getroot(u,tot); vis[root] = TT; id[root] = cnt++; vec[root].push_back(Node(id[root],-1,0)); bits[id[root]].init(tot); bits[id[root]].add(0,val[root]); for(int i = head[root];i != -1;i = edge[i].next){ int v = edge[i].to; if(vis[v] == TT)continue; go(v,root,cnt); cnt++; } for(int i = head[root];i != -1;i = edge[i].next){ int v = edge[i].to; if(vis[v] == TT)continue; solve(v); }}int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; memset(vis,0,sizeof(vis)); TT = 0; while(scanf(“%d%d”,&amp;n,&amp;m) == 2){ init(); TT++; cc_tail = cc; cnt = 0; for(int i = 1;i &lt;= n;i++)vec[i].clear(); for(int i = 1;i &lt;= n;i++)scanf(“%d”,&amp;val[i]); int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } solve(1); char op[10]; int d; while(m–){ scanf(“%s%d%d”,op,&amp;u,&amp;d); if(op[0] == ‘!’){ int dv = d - val[u]; int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++){ Node tmp = vec[u][i]; bits[tmp.root].add(tmp.dis,dv); if(tmp.subtree != -1) bits[tmp.subtree].add(tmp.dis,dv); } val[u] += dv; } else { int ans = 0; int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++){ Node tmp = vec[u][i]; ans += bits[tmp.root].sum(d-tmp.dis); if(tmp.subtree != -1) ans -= bits[tmp.subtree].sum(d-tmp.dis); } printf(“%d\n”,ans); } } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>数据结构</category>
        <category>树分治</category>
        <category>树状数组</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>树分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4641 K-string （SAM）]]></title>
    <url>%2F2014%2F09%2F23%2Fhdu4641%2F</url>
    <content type="text"><![CDATA[HDU4641 因为需要一个在线的算法！ 明显可以用后缀自动机搞。 每个一个字符，就统计下每个点出现的次数，从而更新答案。 后面自动机沿着 fa 指针往前跳，可以找到所有后缀，累加值。 K-stringTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 102400/131072 K (Java/Others) Total Submission(s): 535 Accepted Submission(s): 175 Problem Description Given a string S. K-string is the sub-string of S and it appear in the S at least K times.It means there are at least K different pairs (i,j) so that Si,Si+1… Sj equal to this K-string. Given m operator or query:1.add a letter to the end of S; 2.query how many different K-string currently.For each query ,count the number of different K-string currently. Input The input consists of multiple test cases. Each test case begins with a line containing three integers n, m and K(1&lt;=n,K&lt;=50000,1&lt;=m&lt;=200000), denoting the length of string S, the number of operator or question and the least number of occurrences of K-string in the S. The second line consists string S,which only contains lowercase letters. The next m lines describe the operator or query.The description of the operator looks as two space-separated integers t c (t = 1; c is lowercase letter).The description of the query looks as one integer t (t = 2). Output For each query print an integer — the number of different K-string currently. Sample Input 3 5 2 abc 2 1 a 2 1 a 2 Sample Output 0 1 1 Source 2013 Multi-University Training Contest 4 写起来还是很简单的，主要是要加深对SAM的理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/* ***************Author :kuangbinCreated Time :2014/9/23 22:37:26File Name :E:\2014ACM\专题学习\后缀自动机\HDU4641.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 250010;const int CHAR = 26;struct SAM_Node&#123; SAM_Node *fa,*next[CHAR]; int len; int cnt; void clear()&#123; fa = 0; memset(next,0,sizeof(next)); cnt = 0; &#125;&#125;pool[MAXN*2];SAM_Node *root,*tail;SAM_Node* newnode(int len)&#123; SAM_Node* cur = tail++; cur-&gt;clear(); cur-&gt;len = len; return cur;&#125;void SAM_init()&#123; tail = pool; root = newnode(0);&#125;SAM_Node* extend(SAM_Node* last,int x)&#123; SAM_Node *p = last, *np = newnode(p-&gt;len+1); while(p &amp;&amp; !p-&gt;next[x]) p-&gt;next[x] = np, p = p-&gt;fa; if(!p)np-&gt;fa = root; else&#123; SAM_Node* q = p-&gt;next[x]; if(q-&gt;len == p-&gt;len+1)np-&gt;fa = q; else &#123; SAM_Node* nq = newnode(p-&gt;len+1); memcpy(nq-&gt;next,q-&gt;next,sizeof(q-&gt;next)); nq-&gt;fa = q-&gt;fa; nq-&gt;cnt = q-&gt;cnt; q-&gt;fa = np-&gt;fa = nq; while(p &amp;&amp; p-&gt;next[x] == q) p-&gt;next[x] = nq, p = p-&gt;fa; &#125; &#125; return np;&#125;int K;SAM_Node *last;long long ans;void calc()&#123; SAM_Node *p = last; while(p &amp;&amp; p-&gt;cnt &lt; K)&#123; p-&gt;cnt++; if(p-&gt;cnt &gt;= K)&#123; if(p-&gt;fa) ans += p-&gt;len - p-&gt;fa-&gt;len; &#125; p = p-&gt;fa; &#125;&#125;char str[MAXN];int main()&#123; int n,m; while(scanf("%d%d%d",&amp;n,&amp;m,&amp;K) == 3)&#123; SAM_init(); last = root; ans = 0; scanf("%s",str); int len = strlen(str); for(int i = 0;i &lt; len;i++)&#123; last = extend(last,str[i]-'a'); calc(); &#125; int op; while(m--)&#123; scanf("%d",&amp;op); if(op == 2)printf("%I64d\n",ans); else &#123; scanf("%s",str); last = extend(last,str[0]-'a'); calc(); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5016 Mart Master II （树分治）]]></title>
    <url>%2F2014%2F09%2F23%2Fhdu5016%2F</url>
    <content type="text"><![CDATA[HDU5016 树分治。 题意就是要找一个点，使得可以占领的点最多。 Mart Master IITime Limit: 12000/6000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 156 Accepted Submission(s): 58 Problem Description Trader Dogy lives in city S, which consists of n districts. There are n - 1 bidirectional roads in city S, each connects a pair of districts. Indeed, city S is connected, i.e. people can travel between every pair of districts by roads. In some districts there are marts founded by Dogy’s competitors. when people go to marts, they’ll choose the nearest one. In cases there are more than one nearest marts, they’ll choose the one with minimal city number. Dogy’s money could support him to build only one new marts, he wants to attract as many people as possible, that is, to build his marts in some way that maximize the number of people who will choose his mart as favorite. Could you help him? Input There are multiple test cases. Please process till EOF. In each test case: First line: an integer n indicating the number of districts. Next n - 1 lines: each contains three numbers bi, ei and wi, (1 ≤ bi,ei ≤ n,1 ≤ wi ≤ 10000), indicates that there’s one road connecting city bi and ei, and its length is wi. Last line : n(1 ≤ n ≤ 105) numbers, each number is either 0 or 1, i-th number is 1 indicates that the i-th district has mart in the beginning and vice versa. Output For each test case, output one number, denotes the number of people you can attract, taking district as a unit. Sample Input 5 1 2 1 2 3 1 3 4 1 4 5 1 1 0 0 0 1 5 1 2 1 2 3 1 3 4 1 4 5 1 1 0 0 0 0 1 1 1 0 Sample Output 2 4 0 1 Source 2014 ACM/ICPC Asia Regional Xi’an Online 找到树根。 在一颗子树的，进行分治处理。 然后不在一颗子树的， 要经过树根。 就是 dis[A] + dis[B] &lt; WW[B]. 这样A就是可以统治B的。 /* ***Author :kuangbinCreated Time :2014/9/23 11:40:11File Name :E:\2014ACM\专题学习\树分治\HDU5016.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int INF = 0x3f3f3f3f;struct Edge{ int to,next,w;}edge[MAXN*2];int head[MAXN],tot;void init(){ tot = 0; memset(head,-1,sizeof(head));}inline void addedge(int u,int v,int w){ edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;}int size[MAXN],vis[MAXN],fa[MAXN],que[MAXN];int TT;//时间戳//找重心inline int getroot(int u){ int Min = MAXN, root = 0; int l,r; que[l = r = 1] = u; fa[u] = 0; for(;l &lt;= r;l++) for(int i = head[que[l]]; i != -1;i = edge[i].next){ int v = edge[i].to; if(v == fa[que[l]] || vis[v] == TT)continue; que[++r] = v; fa[v] = que[l]; } for(l–;l;l–){ int x = que[l], Max = 0; size[x] = 1; for(int i = head[x];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == fa[x] || vis[v] == TT)continue; Max = max(Max,size[v]); size[x] += size[v]; } Max = max(Max,r - size[x]); if(Max &lt; Min){ Min = Max; root = x; } } return root;} int ans[MAXN];pair&lt;int,int&gt;pp[MAXN];pair&lt;int,int&gt;np[MAXN];int dis[MAXN];int type[MAXN];inline void go(int u,int pre,int w,int tt){ int l,r; que[l = r = 1] = u; fa[u] = pre; dis[u] = w; for(;l &lt;= r;l++) for(int i = head[que[l]];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == fa[que[l]] || vis[v] == TT)continue; que[++r] = v; fa[v] = que[l]; dis[v] = dis[que[l]] + edge[i].w; } int cnt = 0; for(int i = 1;i &lt;= r;i++){ int x = que[i]; pp[cnt++] = make_pair(np[x].first-dis[x],np[x].second); } sort(pp,pp+cnt); for(int i = 1;i &lt;= r;i++){ int x = que[i]; if(type[x])continue; int id = lower_bound(pp,pp+cnt,make_pair(dis[x],x)) - pp; ans[x] += (cnt-id)*tt; }}void solve(int u){ int root = getroot(u); vis[root] = TT; go(root,0,0,1); for(int i = head[root];i != -1;i = edge[i].next){ int v = edge[i].to; if(vis[v] == TT)continue; go(v,root,edge[i].w,-1); } for(int i = head[root];i != -1;i = edge[i].next){ int v = edge[i].to; if(vis[v] == TT)continue; solve(v); }}bool ff[MAXN];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; memset(vis,0,sizeof(vis)); TT = 0; while(scanf(“%d”,&amp;n) == 1){ init(); int u,v,w; for(int i = 1;i &lt; n;i++){ scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w); addedge(u,v,w); addedge(v,u,w); } for(int i = 1;i &lt;= n;i++)scanf(“%d”,&amp;type[i]); queueq; for(int i = 1;i &lt;= n;i++){ if(type[i]){ np[i] = make_pair(0,i); ff[i] = true; q.push(i); } else{ np[i] = make_pair(INF,0); ff[i] = false; } } while(!q.empty()){ u = q.front(); q.pop(); ff[u] = false; for(int i = head[u];i != -1;i = edge[i].next){ v = edge[i].to; pair&lt;int,int&gt;tmp = make_pair(np[u].first+edge[i].w,np[u].second); if(tmp &lt; np[v]){ np[v] = tmp; if(!ff[v]){ ff[v] = true; q.push(v); } } } } TT++; for(int i = 1;i &lt;= n;i++)ans[i] = 0; solve(1); int ret = 0; for(int i = 1;i &lt;= n;i++)ret = max(ret,ans[i]); printf(“%d\n”,ret); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>树分治</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5039 Hilarity （链分治）]]></title>
    <url>%2F2014%2F09%2F22%2Fhdu5039%2F</url>
    <content type="text"><![CDATA[HDU5039 水题当成神题做了。 明显这题直接用线段树去搞就可以的。 但是比赛时候想出来的用树链剖分的写法，把代码修正下就过了。 关于做法，可以参考QTREE4的树链剖分做法。 可以看漆子超论文 里面关于QTREE4的树链剖分做法还是比较详细的。 其实就是把树分成一条一条链。 然后每条链使用线段树去维护，因为需要修改单点，查询。 修改的时候，最多变化logn条链。 这题的话， 维护单挑链的值，一个是 l0表示到左端点经过偶数条1边的点数，l1表示左端点经过奇数条1边的点数。 r0,r1类似。 然后sum是需要求的点数。 这种做法虽然比较烦，但是思想还是很好的。 HilarityTime Limit: 12000/6000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 165 Accepted Submission(s): 32 Problem Description After June 1st, elementary students of Ted Land are still celebrating “The Sacred Day of Elementary Students”. They go to the streets and do some elementary students stuff. So we call them “elementary students”. There are N cities in Ted Land. But for simplicity, the mayor Matt only built N - 1 roads so that all cities can reach each other. Some of the roads are occupied by the “elementary students”. They will put an celebration hat on everyone who goes through the road without one. But if someone goes through the road with a celebration hat on his head, “elementary students” will steal the hat for no reason. Since Matt doesn’t have a celebration hat, he wants to know how many different paths in his land that he can end up with a hat. Two paths are considered to be different if and only if they have different start city or end city. As the counsellor of the mayor Matt, you have to answer this question for him. The celebration elementary students are not stable: sometimes a new crowd of elementary students go to an empty road; sometimes the elementary students on a road will go back home and remain the road empty. Matt will send you the monitor about the change of elementary students on road and ask you the question above. You will be fired if you answer wrong. Input The first line of the input contains an integer T, denoting the number of testcases. Then T test cases follow. For each test case, the first line contains N (1&lt;=N&lt;=30000) describing the number of cities. Then N lines follow. The ith line of these contains the name of the ith city, it’s a string containing only letters and will not be longer than 10. The following N - 1 lines indicate the N - 1 edges between cities. Each of these lines will contain two strings for the cities’ name and a integer for the initial status of the edge (0 for empty, 1 for crowded). Then an integer M (1&lt;=M&lt;=60000) describes the number of queries. There are two kinds of query: ● “M i” means the status changing of the ith (starting from 1) road (0 to 1, 1 to 0); ● “Q” means that Matt asks you the number of different paths. Output For each test case, first output one line “Case #x:”, where x is the case number (starting from 1). Then for each “Q” in input, output a line with the answer. Sample Input 1 5 a b c d e a b 1 b c 0 c d 1 d e 1 7 Q M 1 Q M 3 Q M 4 Q Sample Output Case #1: 12 8 8 0 Source 2014 ACM/ICPC Asia Regional Beijing Online #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;const int MAXN = 30010;const int INF = 0x3f3f3f3f;struct Edge{ int to,next; int f;}edge[MAXN2];int head[MAXN],tot;void init(){ tot = 0; memset(head,-1,sizeof(head));}void addedge(int u,int v,int f){ edge[tot].to = v; edge[tot].next = head[u]; edge[tot].f = f; head[u] = tot++;}long long ans;int num0[MAXN],num1[MAXN];long long tnum[MAXN];struct Node{ int l0,l1; int r0,r1; int cc; long long sum; Node gao(int u){ l0 = r0 = num0[u]; l1 = r1 = num1[u]; sum = tnum[u]; cc = 0; return this; }};int pos[MAXN];int val[MAXN];int fa[MAXN];int cnt[MAXN];int col[MAXN];int link[MAXN];int CHANGEU;struct chain{ vectoruu; vectornde; int n; void init(){ n = uu.size(); nde.resize(n &lt;&lt; 2); for(int i = 0;i &lt; n;i++)pos[uu[i]] = i; build(0,n-1,1); } void up(int l,int r,int p){ int mid = (l+r)&gt;&gt;1; nde[p].cc = nde[p&lt;&lt;1].cc ^ nde[(p&lt;&lt;1)|1].cc ^ val[uu[mid]]; nde[p].l0 = nde[p&lt;&lt;1].l0; nde[p].l1 = nde[p&lt;&lt;1].l1; if(nde[p&lt;&lt;1].cc^val[uu[mid]]){ nde[p].l0 += nde[(p&lt;&lt;1)|1].l1; nde[p].l1 += nde[(p&lt;&lt;1)|1].l0; } else { nde[p].l0 += nde[(p&lt;&lt;1)|1].l0; nde[p].l1 += nde[(p&lt;&lt;1)|1].l1; } nde[p].r0 = nde[(p&lt;&lt;1)|1].r0; nde[p].r1 = nde[(p&lt;&lt;1)|1].r1; if(nde[(p&lt;&lt;1)|1].cc^val[uu[mid]]){ nde[p].r0 += nde[p&lt;&lt;1].r1; nde[p].r1 += nde[p&lt;&lt;1].r0; } else { nde[p].r0 += nde[p&lt;&lt;1].r0; nde[p].r1 += nde[p&lt;&lt;1].r1; } if(val[uu[mid]] == 0){ nde[p].sum = nde[p&lt;&lt;1].sum + nde[(p&lt;&lt;1)|1].sum + (long long)nde[p&lt;&lt;1].r0nde[(p&lt;&lt;1)|1].l1 + (long long)nde[p&lt;&lt;1].r1nde[(p&lt;&lt;1)|1].l0; } else { nde[p].sum = nde[p&lt;&lt;1].sum + nde[(p&lt;&lt;1)|1].sum + (long long)nde[p&lt;&lt;1].r0nde[(p&lt;&lt;1)|1].l0 + (long long)nde[p&lt;&lt;1].r1nde[(p&lt;&lt;1)|1].l1; } } void build(int l,int r,int p){ if(l == r){ nde[p].gao(uu[l]); return; } int mid = (l+r)/2; build(l,mid,p&lt;&lt;1); build(mid+1,r,(p&lt;&lt;1)|1); up(l,r,p); } void update(int k,int l,int r,int p){ if(l == r){ nde[p].gao(uu[k]); return; } int mid = (l+r)/2; if(k &lt;= mid)update(k,l,mid,p&lt;&lt;1); else update(k,mid+1,r,(p&lt;&lt;1)|1); up(l,r,p); } int change(int y){ int x = uu.back(); int p = fa[x]; if(p){ if(x == CHANGEU)val[x] ^= 1; if(val[x]){ tnum[p] -= (long long)nde[1].r0(num0[p]-nde[1].r1); tnum[p] -= (long long)nde[1].r1(num1[p]-nde[1].r0); num0[p] -= nde[1].r1; num1[p] -= nde[1].r0; } else { tnum[p] -= (long long)nde[1].r1(num0[p]-nde[1].r0); tnum[p] -= (long long)nde[1].r0(num1[p]-nde[1].r1); num0[p] -= nde[1].r0; num1[p] -= nde[1].r1; } if(x == CHANGEU)val[x] ^= 1; } ans -= nde[1].sum; update(pos[y],0,n-1,1); if(p){ if(val[x]){ tnum[p] += (long long)nde[1].r0num0[p]; tnum[p] += (long long)nde[1].r1num1[p]; num0[p] += nde[1].r1; num1[p] += nde[1].r0; } else { tnum[p] += (long long)nde[1].r0num1[p]; tnum[p] += (long long)nde[1].r1num0[p]; num0[p] += nde[1].r0; num1[p] += nde[1].r1; } } ans += nde[1].sum; return p; }}ch[MAXN];void dfs1(int u,int pre){ chain &amp;c = ch[u]; c.uu.clear(); int v, x = 0; cnt[u] = 1; for(int i = head[u];i != -1;i = edge[i].next){ v = edge[i].to; if(v == pre)continue; dfs1(v,u); link[i/2] = v; val[v] = edge[i].f; cnt[u] += cnt[v]; fa[v] = u; if(cnt[v] &gt; cnt[x]) x = v; } if(!x)col[u] = u; else col[u] = col[x]; ch[col[u]].uu.push_back(u); num0[u] = 1; num1[u] = 0; tnum[u] = 0; }void dfs2(int x){ x = col[x]; chain &amp;c = ch[x]; int n = c.uu.size(); int u,v; for(int i = 1;i &lt; n;i++){ u = c.uu[i]; for(int j = head[u];j != -1;j = edge[j].next){ v = edge[j].to; if(v == c.uu[i-1] || fa[u] == v)continue; dfs2(v); if(val[v]){ tnum[u] += (long long)num0[u]*ch[col[v]].nde[1].r0 + (long long)num1[u]*ch[col[v]].nde[1].r1; num0[u] += ch[col[v]].nde[1].r1; num1[u] += ch[col[v]].nde[1].r0; } else { tnum[u] += (long long)num1[u]*ch[col[v]].nde[1].r0 + (long long)num0[u]*ch[col[v]].nde[1].r1; num0[u] += ch[col[v]].nde[1].r0; num1[u] += ch[col[v]].nde[1].r1; } } } c.init(); ans += c.nde[1].sum;}char str[100];char str1[100],str2[100];int main(){ int T; int iCase = 0; scanf(“%d”,&amp;T); int n; while(T–){ ans = 0; iCase++; scanf(“%d”,&amp;n); map&lt;string,int&gt;mp; init(); for(int i = 1;i &lt;= n;i++){ scanf(“%s”,str); mp[str] = i; } int u,v,f; for(int i = 1;i &lt; n;i++){ scanf(“%s%s%d”,str1,str2,&amp;f); addedge(mp[str1],mp[str2],f); addedge(mp[str2],mp[str1],f); } int Q; char op[10]; scanf(“%d”,&amp;Q); printf(“Case #%d:\n”,iCase); val[1] = 0; fa[1] = 0; dfs1(1,1); dfs2(1); while(Q–){ scanf(“%s”,op); if(op[0] == ‘Q’){ printf(“%I64d\n”,ans*2); } else { int id ; scanf(“%d”,&amp;id); id–; u = link[id]; val[u] ^= 1; CHANGEU = u; while(u) u = ch[col[u]].change(u); } } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>树分治</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5029 Relief grain （树链剖分+线段树）]]></title>
    <url>%2F2014%2F09%2F21%2Fhdu5029%2F</url>
    <content type="text"><![CDATA[HDU5029 题意很简单。 做法就是进行树链剖分，这样就可以把树形转线性。 然后对区间[l,r] 加z, 可以在l加一个z, 在r+1减掉一个 z. 最后按照fp数组进行扫描一遍，用线段树进行更新，找最大值。 水题！ Relief grainTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 100000/100000 K (Java/Others) Total Submission(s): 237 Accepted Submission(s): 41 Problem Description The soil is cracking up because of the drought and the rabbit kingdom is facing a serious famine. The RRC(Rabbit Red Cross) organizes the distribution of relief grain in the disaster area. We can regard the kingdom as a tree with n nodes and each node stands for a village. The distribution of the relief grain is divided into m phases. For each phases, the RRC will choose a path of the tree and distribute some relief grain of a certain type for every village located in the path. There are many types of grains. The RRC wants to figure out which type of grain is distributed the most times in every village. Input The input consists of at most 25 test cases. For each test case, the first line contains two integer n and m indicating the number of villages and the number of phases. The following n-1 lines describe the tree. Each of the lines contains two integer x and y indicating that there is an edge between the x-th village and the y-th village. The following m lines describe the phases. Each line contains three integer x, y and z indicating that there is a distribution in the path from x-th village to y-th village with grain of type z. (1 &lt;= n &lt;= 100000, 0 &lt;= m &lt;= 100000, 1 &lt;= x &lt;= n, 1 &lt;= y &lt;= n, 1 &lt;= z &lt;= 100000) The input ends by n = 0 and m = 0. Output For each test case, output n integers. The i-th integer denotes the type that is distributed the most times in the i-th village. If there are multiple types which have the same times of distribution, output the minimal one. If there is no relief grain in a village, just output 0. Sample Input 2 4 1 2 1 1 1 1 2 2 2 2 2 2 2 1 5 3 1 2 3 1 3 4 5 3 2 3 3 1 5 2 3 3 3 0 0 Sample Output 1 2 2 3 3 0 2 Hint For the first test case, the relief grain in the 1st village is {1, 2}, and the relief grain in the 2nd village is {1, 2, 2}. /* ***Author :kuangbinCreated Time :2014/9/21 8:39:49File Name :HDU5029.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;struct Edge{ int to,next;}edge[MAXN2];int head[MAXN],tot;int top[MAXN];int fa[MAXN];int deep[MAXN];int num[MAXN];int p[MAXN];int fp[MAXN];int son[MAXN];int pos;void init(){ tot = 0; memset(head,-1,sizeof(head)); pos = 1; memset(son,-1,sizeof(son));}void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}void dfs1(int u,int pre,int d){ deep[u] = d; fa[u] = pre; num[u] = 1; for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v != pre){ dfs1(v,u,d+1); num[u] += num[v]; if(son[u] == -1 || num[v] &gt; num[son[u]]) son[u] = v; } }}void getpos(int u,int sp){ top[u] = sp; p[u] = pos++; fp[p[u]] = u; if(son[u] == -1)return; getpos(son[u],sp); for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v != son[u] &amp;&amp; v != fa[u]) getpos(v,v); }}vectoravec[MAXN],dvec[MAXN];void change(int u,int v,int z){ int f1 = top[u],f2 = top[v]; int tmp = 0; while(f1 != f2){ if(deep[f1] &lt; deep[f2]){ swap(f1,f2); swap(u,v); } avec[p[f1]].push_back(z); dvec[p[u]+1].push_back(z); u = fa[f1]; f1 = top[u]; } if(deep[u] &gt; deep[v])swap(u,v); avec[p[u]].push_back(z); dvec[p[v]+1].push_back(z);}struct Node{ int l,r; int Max,id; void output(){ printf(“l %d r %d Max %d id %d\n”,l,r,Max,id); }}segTree[MAXN&lt;&lt;2];void debug(int i){ segTree[i].output(); if(segTree[i].l == segTree[i].r)return; debug(i&lt;&lt;1); debug((i&lt;&lt;1)|1);}void push_up(int i){ if(segTree[i&lt;&lt;1].Max &lt; segTree[(i&lt;&lt;1)|1].Max){ segTree[i].Max = segTree[(i&lt;&lt;1)|1].Max; segTree[i].id = segTree[(i&lt;&lt;1)|1].id; } else{ segTree[i].Max = segTree[i&lt;&lt;1].Max; segTree[i].id = segTree[i&lt;&lt;1].id; }}void build(int i,int l,int r){ segTree[i].l = l; segTree[i].r = r; if(l == r){ segTree[i].id = l; segTree[i].Max = 0; return; } int mid = (l+r)/2; build(i&lt;&lt;1,l,mid); build((i&lt;&lt;1)|1,mid+1,r); push_up(i);}void update(int i,int k,int val){ if(segTree[i].l == k &amp;&amp; segTree[i].r == k){ segTree[i].Max += val; return; } int mid = (segTree[i].l+segTree[i].r)/2; if(k &lt;= mid)update(i&lt;&lt;1,k,val); else update((i&lt;&lt;1)|1,k,val); push_up(i);}int ans[MAXN];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2){ if(n == 0 &amp;&amp; m == 0)break; init(); int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } dfs1(1,0,0); getpos(1,1); for(int i = 1;i &lt;= 100000;i++){ avec[i].clear(); dvec[i].clear(); } int z; while(m–){ scanf(“%d%d%d”,&amp;u,&amp;v,&amp;z); change(u,v,z); } build(1,1,100000); for(int i = 1;i &lt;= n;i++){ //debug(1); //printf(“%d %d\n”,avec[i].size(),dvec[i].size()); for(int j = 0;j &lt; avec[i].size();j++){ update(1,avec[i][j],1); //printf(“%d \n”,avec[i][j]); } for(int j = 0;j &lt; dvec[i].size();j++){ update(1,dvec[i][j],-1); //printf(“%d **\n”,dvec[i][j]); } u = fp[i]; //printf(“i %d %d\n”,i,fp[i]); if(segTree[1].Max == 0)ans[u] = 0; else ans[u] = segTree[1].id; } for(int i = 1;i &lt;= n;i++) printf(“%d\n”,ans[i]); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>树链剖分</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5015 233 Matrix （矩阵乘法）]]></title>
    <url>%2F2014%2F09%2F15%2Fhdu5015%2F</url>
    <content type="text"><![CDATA[HDU5015这题属于很水的矩形题了。 矩阵也很容易构造！ 233 MatrixTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 453 Accepted Submission(s): 298 Problem Description In our daily life we often use 233 to express our feelings. Actually, we may say 2333, 23333, or 233333 … in the same meaning. And here is the question: Suppose we have a matrix called 233 matrix. In the first line, it would be 233, 2333, 23333… (it means a0,1 = 233,a0,2 = 2333,a0,3 = 23333…) Besides, in 233 matrix, we got ai,j = ai-1,j +ai,j-1( i,j ≠ 0). Now you have known a1,0,a2,0,…,an,0, could you tell me an,m in the 233 matrix? Input There are multiple test cases. Please process till EOF. For each case, the first line contains two postive integers n,m(n ≤ 10,m ≤ 109). The second line contains n integers, a1,0,a2,0,…,an,0(0 ≤ ai,0 &lt; 231). Output For each case, output an,m mod 10000007. Sample Input 1 1 1 2 2 0 0 3 7 23 47 16 Sample Output 234 2799 72937 Hint Source 2014 ACM/ICPC Asia Regional Xi’an Online 需要构造一个 n+2 维的矩形。 就是要增加一维去维护2333这样的序列。 可以发现 2333 = 233*10 + 3 所以增加了一维就 是1， 然后就可以全部转移了。 反正状态就是 一列 ，再增加一个233不停增加的，然后一个1，所以是 n+2维。 很水了。 #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;const int MOD = 1e7+7;struct Matrix{ int mat[15][15]; int n; void init(int _n){ n = _n; memset(mat,0,sizeof(mat)); } Matrix operator (const Matrix &amp;b)const{ Matrix ret; ret.init(n); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++){ ret.mat[i][j] = 0; for(int k = 0;k &lt; n;k++){ ret.mat[i][j] += (long long)mat[i][k]b.mat[k][j]%MOD; if(ret.mat[i][j] &gt;= MOD) ret.mat[i][j] -= MOD; } } return ret; }};Matrix pow_M(Matrix a,long long n){ Matrix ret; Matrix tmp = a; ret.init(a.n); for(int i = 0;i &lt; a.n;i++)ret.mat[i][i] = 1; while(n){ if(n&amp;1)ret = rettmp; tmp = tmptmp; n &gt;&gt;= 1; } return ret;} int a[20];Matrix A;int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) == 2){ for(int i = 0;i &lt; n;i++){scanf(&quot;%d&quot;,&amp;a\[i\]);a\[i\]%=MOD;} A.init(n+2); for(int j = 0;j &lt; n;j++){ for(int i = 0;i &lt;= j;i++) A.mat\[i\]\[j\] = 1; A.mat\[n\]\[j\] = 1; } A.mat\[n\]\[n\] = 10; A.mat\[n+1\]\[n\] = 3; A.mat\[n+1\]\[n+1\] = 1; A = pow_M(A,m); long long ans = 0; for(int i = 0;i &lt; n;i++){ ans += (long long)a\[i\]*A.mat\[i\]\[n-1\]%MOD; ans %= MOD; } ans += (long long)233*A.mat\[n\]\[n-1\]; ans%=MOD; ans += (long long)A.mat\[n+1\]\[n-1\]; ans%=MOD; printf(&quot;%d\\n&quot;,(int)ans); } return 0; }]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>矩阵乘法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5014 Number Sequence]]></title>
    <url>%2F2014%2F09%2F15%2Fhdu5014%2F</url>
    <content type="text"><![CDATA[HDU5014贪心YY下就可以了。 最后肯定是两两配对的。 从大到小去找配对的。 异或以下就可以了。 比如要找x配对的。 因为是x最高位以下的0变1,1变0， 这个值一定是比x小的。 注意最后需要long long. Number SequenceTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 629 Accepted Submission(s): 297 Special Judge Problem Description There is a special number sequence which has n+1 integers. For each number in sequence, we have two rules: ● ai ∈ [0,n] ● ai ≠ aj( i ≠ j ) For sequence a and sequence b, the integrating degree t is defined as follows(“⊕” denotes exclusive or): t = (a0 ⊕ b0) + (a1 ⊕ b1) +···+ (an ⊕ bn) (sequence B should also satisfy the rules described above) Now give you a number n and the sequence a. You should calculate the maximum integrating degree t and print the sequence b. Input There are multiple test cases. Please process till EOF. For each case, the first line contains an integer n(1 ≤ n ≤ 105), The second line contains a0,a1,a2,…,an. Output For each case, output two lines.The first line contains the maximum integrating degree t. The second line contains n+1 integers b0,b1,b2,…,bn. There is exactly one space between bi and bi+1(0 ≤ i ≤ n - 1). Don’t ouput any spaces after bn. Sample Input 4 2 0 1 4 3 Sample Output 20 1 0 2 3 4 Source 2014 ACM/ICPC Asia Regional Xi’an Online /* ***Author :kuangbinCreated Time :2014/9/15 22:00:04File Name :E:\2014ACM\2014网络赛\2014西安\HDU5014.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;int a[MAXN];int b[MAXN];bool vis[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ for(int i = 0;i &lt;= n;i++)scanf(“%d”,&amp;a[i]); memset(vis,false,sizeof(vis)); for(int i = n;i &gt;= 0;i–) if(!vis[i]){ vis[i] = true; if(i == 0){ b[0] = 0; continue; } int x = (1&lt;&lt;20); while((i&amp;x) == 0)x &gt;&gt;= 1; //printf(“i %d %d\n”,i,x); x = 2*x-1; x = x^i; //printf(“%d\n”,x); b[i] = x; b[x] = i; vis[x] = true; } long long ans = 0; for(int i = 0;i &lt;= n;i++)ans += (i^b[i]); printf(“%I64d\n”,ans); for(int i = 0;i &lt;= n;i++){ printf(“%d”,b[a[i]]); if(i == n)printf(“\n”); else printf(“ “); } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5012 Dice （搜索）]]></title>
    <url>%2F2014%2F09%2F15%2Fhdu5012%2F</url>
    <content type="text"><![CDATA[HDU5012 求最小步数，暴力bfs就可以了。 范围小，直接map进行映射。 随便搞啊 DiceTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 444 Accepted Submission(s): 263 Problem Description There are 2 special dices on the table. On each face of the dice, a distinct number was written. Consider a1.a2,a3,a4,a5,a6 to be numbers written on top face, bottom face, left face, right face, front face and back face of dice A. Similarly, consider b1.b2,b3,b4,b5,b6 to be numbers on specific faces of dice B. It’s guaranteed that all numbers written on dices are integers no smaller than 1 and no more than 6 while ai ≠ aj and bi ≠ bj for all i ≠ j. Specially, sum of numbers on opposite faces may not be 7. At the beginning, the two dices may face different(which means there exist some i, ai ≠ bi). Ddy wants to make the two dices look the same from all directions(which means for all i, ai = bi) only by the following four rotation operations.(Please read the picture for more information) Now Ddy wants to calculate the minimal steps that he has to take to achieve his goal. Input There are multiple test cases. Please process till EOF. For each case, the first line consists of six integers a1,a2,a3,a4,a5,a6, representing the numbers on dice A. The second line consists of six integers b1,b2,b3,b4,b5,b6, representing the numbers on dice B. Output For each test case, print a line with a number representing the answer. If there’s no way to make two dices exactly the same, output -1. Sample Input 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 5 6 4 3 1 2 3 4 5 6 1 4 2 5 3 6 Sample Output 0 3 -1 Source 2014 ACM/ICPC Asia Regional Xi’an Online /* ***Author :kuangbinCreated Time :2014/9/15 21:27:02File Name :E:\2014ACM\2014网络赛\2014西安\HDU5012.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; string left(string ss){ string ret; ret.resize(6); int a[] = {3,2,0,1,4,5}; for(int i = 0;i &lt; 6;i++) ret[i] = ss[a[i]]; return ret;}string right(string ss){ string ret; ret.resize(6); int a[] = {2,3,1,0,4,5}; for(int i = 0;i &lt; 6;i++) ret[i] = ss[a[i]]; return ret;}string front(string ss){ string ret; ret.resize(6); int a[] = {5,4,2,3,0,1}; for(int i = 0;i &lt; 6;i++) ret[i] = ss[a[i]]; return ret;}string back(string ss){ string ret; ret.resize(6); int a[] = {4,5,2,3,1,0}; for(int i = 0;i &lt; 6;i++) ret[i] = ss[a[i]]; return ret;}int solve(string start,string end){ map&lt;string,int&gt;mp; mp[start] = 0; queueq; q.push(start); while(!q.empty()){ string tmp = q.front(); q.pop(); if(tmp == end)return mp[tmp]; string nn; nn = left(tmp); if(mp.find(nn) == mp.end()){ mp[nn] = mp[tmp] + 1; q.push(nn); } nn = right(tmp); if(mp.find(nn) == mp.end()){ mp[nn] = mp[tmp] + 1; q.push(nn); } nn = front(tmp); if(mp.find(nn) == mp.end()){ mp[nn] = mp[tmp] + 1; q.push(nn); } nn = back(tmp); if(mp.find(nn) == mp.end()){ mp[nn] = mp[tmp] + 1; q.push(nn); } } return -1;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int a; while(scanf(“%d”,&amp;a) == 1){ string str1 = “”; str1 += (char)(a+’0’); for(int i = 1;i &lt; 6;i++) { scanf(“%d”,&amp;a); str1 += (char)(a+’0’); } string str2 = “”; for(int i = 0;i &lt; 6;i++){ scanf(“%d”,&amp;a); str2 += (char)(a+’0’); } printf(“%d\n”,solve(str1,str2)); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>搜索</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5011 Game （博弈水题）]]></title>
    <url>%2F2014%2F09%2F15%2Fhdu5011%2F</url>
    <content type="text"><![CDATA[HDU5011简单博弈。 GameTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 155 Accepted Submission(s): 120 Problem Description Here is a game for two players. The rule of the game is described below: ● In the beginning of the game, there are a lot of piles of beads. ● Players take turns to play. Each turn, player choose a pile i and remove some (at least one) beads from it. Then he could do nothing or split pile i into two piles with a beads and b beads.(a,b &gt; 0 and a + b equals to the number of beads of pile i after removing) ● If after a player’s turn, there is no beads left, the player is the winner. Suppose that the two players are all very clever and they will use optimal game strategies. Your job is to tell whether the player who plays first can win the game. Input There are multiple test cases. Please process till EOF. For each test case, the first line contains a postive integer n(n &lt; 105) means there are n piles of beads. The next line contains n postive integer, the i-th postive integer ai(ai &lt; 231) means there are ai beads in the i-th pile. Output For each test case, if the first player can win the game, ouput “Win” and if he can’t, ouput “Lose” Sample Input 1 1 2 1 1 3 1 2 3 Sample Output Win Lose Lose Source 2014 ACM/ICPC Asia Regional Xi’an Online 这题的常规做法就是，暴力打SG表。 找规律， 发现sg\[i\] = i; 然后就是所有数异或起来，为0就是输，否则赢。 当然如果你YY功力足够好，直接猜出异或，然后AC， 那也是可以的。 /* ***Author :kuangbinCreated Time :2014/9/15 0:15:56File Name :E:\2014ACM\2014网络赛\2014西安\HDU5011.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ int a,sum = 0; while(n–){ scanf(“%d”,&amp;a); sum ^= a; } if(sum)printf(“Win\n”); else printf(“Lose\n”); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>博弈</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5009 Paint Pearls （DP）]]></title>
    <url>%2F2014%2F09%2F15%2Fhdu5009%2F</url>
    <content type="text"><![CDATA[HDU5009 DP。 需要简单优化下就可以了。 Paint PearlsTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 715 Accepted Submission(s): 228Problem Description Lee has a string of n pearls. In the beginning, all the pearls have no color. He plans to color the pearls to make it more fascinating. He drew his ideal pattern of the string on a paper and asks for your help. In each operation, he selects some continuous pearls and all these pearls will be painted to their target colors. When he paints a string which has k different target colors, Lee will cost k2 points. Now, Lee wants to cost as few as possible to get his ideal string. You should tell him the minimal cost. Input There are multiple test cases. Please process till EOF. For each test case, the first line contains an integer n(1 ≤ n ≤ 5×104), indicating the number of pearls. The second line contains a1,a2,…,an (1 ≤ ai ≤ 109) indicating the target color of each pearl. Output For each test case, output the minimal cost in a line. Sample Input 3 1 3 3 10 3 4 2 4 4 2 4 3 2 2 Sample Output 2 7 Source 2014 ACM/ICPC Asia Regional Xi’an Online 注意到 n &lt;= 5*10^4 而且花费是 k^2 所以DP转移的时候， 转移不同的不要超过 sqrt(i)个。 为了找到不同的，可以搞个set去转移。 也可以搞个并查集去合并。 /* ***Author :kuangbinCreated Time :2014/9/14 23:23:59File Name :E:\2014ACM\2014网络赛\2014西安\HDU5009.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 50010;int a[MAXN];int F[MAXN];int find(int x){ if(F[x] == -1)return x; return F[x] = find(F[x]);}void bing(int x,int y){ int t1 = find(x), t2 = find(y); if(t1 != t2)F[t2] = t1;}int b[MAXN];int last[MAXN];int dp[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1){ int cnt = 0; for(int i = 1;i &lt;= n;i++){ scanf(“%d”,&amp;a[i]); b[cnt++] = a[i]; } sort(b,b+cnt); cnt = unique(b,b+cnt) - b; map&lt;int,int&gt;mp; for(int i = 0;i &lt; cnt;i++){ mp[b[i]] = i; last[i] = -1; } for(int i = 1;i &lt;= n;i++)a[i] = mp[a[i]]; dp[0] = 0; F[0] = -1; for(int i = 1;i &lt;= n;i++){ F[i] = -1; if(last[a[i]] != -1){ bing(last[a[i]]-1,last[a[i]]); } last[a[i]] = i; dp[i] = i; int num = 0; for(int j = i;j &gt; 0;j = find(j-1)){ num++; if(numnum &gt;= dp[i])break; int nxt = find(j-1); dp[i] = min(dp[i],dp[nxt]+numnum); } } printf(“%d\n”,dp[n]); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5008 Boring String Problem （SA）]]></title>
    <url>%2F2014%2F09%2F14%2Fhdu5008%2F</url>
    <content type="text"><![CDATA[HDU5008 后缀数组。 Boring String ProblemTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 255 Accepted Submission(s): 58 Problem Description In this problem, you are given a string s and q queries. For each query, you should answer that when all distinct substrings of string s were sorted lexicographically, which one is the k-th smallest. A substring si…j of the string s = a1a2 …an(1 ≤ i ≤ j ≤ n) is the string aiai+1 …aj. Two substrings sx…y and sz…w are cosidered to be distinct if sx…y ≠ Sz…w Input The input consists of multiple test cases.Please process till EOF. Each test case begins with a line containing a string s(|s| ≤ 105) with only lowercase letters. Next line contains a postive integer q(1 ≤ q ≤ 105), the number of questions. q queries are given in the next q lines. Every line contains an integer v. You should calculate the k by k = (l⊕r⊕v)+1(l, r is the output of previous question, at the beginning of each case l = r = 0, 0 &lt; k &lt; 263, “⊕” denotes exclusive or) Output For each test case, output consists of q lines, the i-th line contains two integers l, r which is the answer to the i-th query. (The answer l,r satisfies that sl…r is the k-th smallest and if there are several l,r available, ouput l,r which with the smallest l. If there is no l,r satisfied, output “0 0”. Note that s1…n is the whole string) Sample Input aaa 4 0 2 3 5 Sample Output 1 1 1 3 1 2 0 0 Source 2014 ACM/ICPC Asia Regional Xi’an Online 这题就是找出所有子串中的第k大。 而且要找出下标最小的。 这题相对而言简直弱爆了。 用后缀数组可以随便搞。 首先sa数组就已经按照字典序排好了。 对于每个sa 都会增加一定的子串。 增加的子串个数就是 n - sa\[i\] - height\[i\]. 然后二分就可以找到第k大的位置。 然后为了找到下标最小的。 二分确定一个区间，在这个区间求sa数组的最小值。 搞个rmq进行最大最小值查询。 记住 后缀的前缀就是子串！ #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;/ `suffix array``倍增算法 O(nlogn)*待排序数组长度为n,放在0~n-1中，在最后面补一个0*\da(str ,sa,rank,height, n , );//注意是n;`例如： `n = 8;`* num[] = { 1, 1, 2, 1, 1, 1, 1, 2, $ }; 注意num最后一位为0，其他大于0`rank[] = { 4, 6, 8, 1, 2, 3, 5, 7, 0 };rank[0~n-1]为有效值，rank[n]必定为0无效值` `sa[] = { 8, 3, 4, 5, 0, 6, 1, 7, 2 };sa[1~n]为有效值，sa[0]必定为n是无效值``height[]= { 0, 0, 3, 2, 3, 1, 2, 0, 1 };height[2~n]为有效值` /const int MAXN=100010;int t1[MAXN],t2[MAXN],c[MAXN];//求SA数组需要的中间变量，不需要赋值//待排序的字符串放在s数组中，从s\[0\]到s\[n-1\],长度为n,且最大值小于m,//除s\[n-1\]外的所有s\[i\]都大于0，r\[n-1\]=0//函数结束以后结果放在sa数组中bool cmp(int r,int a,int b,int l){ return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];}void da(int str[],int sa[],int rank[],int height[],int n,int m){ n++; int i, j, p, *x = t1, *y = t2; //第一轮基数排序，如果s的最大值很大，可改为快速排序 for(i = 0;i &lt; m;i++)c[i] = 0; for(i = 0;i &lt; n;i++)c[x[i] = str[i]]++; for(i = 1;i &lt; m;i++)c[i] += c[i-1]; for(i = n-1;i &gt;= 0;i–)sa[–c[x[i]]] = i; for(j = 1;j &lt;= n; j &lt;&lt;= 1){ p = 0; //直接利用sa数组排序第二关键字 for(i = n-j; i &lt; n; i++)y[p++] = i;//后面的j个数第二关键字为空的最小 for(i = 0; i &lt; n; i++)if(sa[i] &gt;= j)y[p++] = sa[i] - j; //这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for(i = 0; i &lt; m; i++)c[i] = 0; for(i = 0; i &lt; n; i++)c[x[y[i]]]++; for(i = 1; i &lt; m;i++)c[i] += c[i-1]; for(i = n-1; i &gt;= 0;i–)sa[–c[x[y[i]]]] = y[i]; //根据sa和x数组计算新的x数组 swap(x,y); p = 1; x[sa[0]] = 0; for(i = 1;i &lt; n;i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],j)?p-1:p++; if(p &gt;= n)break; m = p;//下次基数排序的最大值 } int k = 0; n–; for(i = 0;i &lt;= n;i++)rank[sa[i]] = i; for(i = 0;i &lt; n;i++){ if(k)k–; j = sa[rank[i]-1]; while(str[i+k] == str[j+k])k++; height[rank[i]] = k; }}int rank[MAXN],height[MAXN];int RMQ[MAXN];int mm[MAXN];int best[20][MAXN];void initRMQ(int n){ mm[0]=-1; for(int i=1;i&lt;=n;i++) mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1]; for(int i=1;i&lt;=n;i++)best[0][i]=i; for(int i=1;i&lt;=mm[n];i++) for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++){ int a=best[i-1][j]; int b=best[i-1][j+(1&lt;&lt;(i-1))]; if(RMQ[a]&lt;RMQ[b])best[i][j]=a; else best[i][j]=b; }}int askRMQ(int a,int b){ int t; t=mm[b-a+1]; b-=(1&lt;&lt;t)-1; a=best[t][a];b=best[t][b]; return RMQ[a]&lt;RMQ[b]?a:b;}int lcp(int a,int b){ a=rank[a];b=rank[b]; if(a&gt;b)swap(a,b); return height[askRMQ(a+1,b)];}char str[MAXN];int r[MAXN];int sa[MAXN];int dp[20][MAXN];void init(int n){ for(int i = 1;i &lt;= n;i++){ dp[0][i] = sa[i]; } for(int j = 1;j &lt;= mm[n];j++) for(int i = 1;i + (1&lt;&lt;j) - 1 &lt;= n;i++) dp[j][i] = min(dp[j-1][i],dp[j-1][i+(1&lt;&lt;(j-1))]);}int rmq(int x,int y){ int k = mm[y-x+1]; return min(dp[k][x],dp[k][y-(1&lt;&lt;k)+1]);} long long b[MAXN];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%s”,str) == 1){ int n = strlen(str); for(int i = 0;i &lt; n;i++)r[i] = str[i]; r[n] = 0; da(r,sa,rank,height,n,128); for(int i = 1;i &lt;= n;i++)RMQ[i] = height[i]; initRMQ(n); init(n); b[0] = 0; for(int i = 1;i &lt;= n;i++) b[i] = b[i-1] + n - sa[i] - height[i]; int m; scanf(“%d”,&amp;m); long long k; int lastl = 0, lastr = 0; while(m–){ scanf(“%I64d”,&amp;k);//提交记得修改======== k = (k^lastl^lastr) + 1; if(k &gt; b[n]){ printf(“0 0\n”); lastl = 0; lastr = 0; continue; } int id = lower_bound(b+1,b+n+1,k) - b; k -= b[id-1]; int len = height[id] + k; int ll = id; int rr = id; int l = id, r = n; while(l &lt;= r){ int mid = (l+r)/2; if(sa[id] == sa[mid] || lcp(sa[id],sa[mid]) &gt;= len){ rr = mid; l = mid+1; } else r = mid-1; } int ansl = rmq(ll,rr); int ansr = ansl + len - 1; ansl++; ansr++; printf(“%d %d\n”,ansl,ansr); lastl = ansl; lastr = ansr; } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>后缀数组</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5007 Post Robot （水题）]]></title>
    <url>%2F2014%2F09%2F14%2Fhdu5007%2F</url>
    <content type="text"><![CDATA[HDU5008 发个水题。 水题。题意啥就不说了，直接贴个代码 /* ***Author :kuangbinCreated Time :2014/9/14 22:47:59File Name :E:\2014ACM\2014网络赛\2014西安\HDU5007.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;char str[10010]; char ss[][10] = { “Apple”,”iPhone”,”iPod”,”iPad”,”Sony”}; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(gets(str)){ int len = strlen(str); for(int i = 0;i &lt; len;i++){ bool f1 = false; for(int j = 0;j &lt; 4;j++){ bool ff = true; int slen = strlen(ss[j]); if(i + slen &gt; len)continue; for(int k = 0;k &lt; slen;k++) if(str[i+k] != ss[j][k]) ff = false; if(ff)f1 = true; } if(f1)printf(“MAI MAI MAI!\n”); bool f2 = true; int slen = strlen(ss[4]); if(i + slen &gt; len)continue; for(int j = 0;j &lt; slen;j++) if(str[i+j] != ss[4][j]) f2 = false; if(f2)printf(“SONY DAFA IS GOOD!\n”); } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5002 Tree （LCT）]]></title>
    <url>%2F2014%2F09%2F14%2Fhdu-5002-tree-ef-bc-88lct-ef-bc-89%2F</url>
    <content type="text"><![CDATA[HDU5002LCT模板题。 都是基本的操作。 很水。 把push_up和push_down搞好可以了。 TreeTime Limit: 16000/8000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 78 Accepted Submission(s): 34 Problem Description You are given a tree with N nodes which are numbered by integers 1..N. Each node is associated with an integer as the weight. Your task is to deal with M operations of 4 types: 1.Delete an edge (x, y) from the tree, and then add a new edge (a, b). We ensure that it still constitutes a tree after adding the new edge. 2.Given two nodes a and b in the tree, change the weights of all the nodes on the path connecting node a and b (including node a and b) to a particular value x. 3.Given two nodes a and b in the tree, increase the weights of all the nodes on the path connecting node a and b (including node a and b) by a particular value d. 4.Given two nodes a and b in the tree, compute the second largest weight on the path connecting node a and b (including node a and b), and the number of times this weight occurs on the path. Note that here we need the strict second largest weight. For instance, the strict second largest weight of {3, 5, 2, 5, 3} is 3. Input The first line contains an integer T (T&lt;=3), which means there are T test cases in the input. For each test case, the first line contains two integers N and M (N, M&lt;=10^5). The second line contains N integers, and the i-th integer is the weight of the i-th node in the tree (their absolute values are not larger than 10^4). In next N-1 lines, there are two integers a and b (1&lt;=a, b&lt;=N), which means there exists an edge connecting node a and b. The next M lines describe the operations you have to deal with. In each line the first integer is c (1&lt;=c&lt;=4), which indicates the type of operation. If c = 1, there are four integers x, y, a, b (1&lt;= x, y, a, b &lt;=N) after c. If c = 2, there are three integers a, b, x (1&lt;= a, b&lt;=N, |x|&lt;=10^4) after c. If c = 3, there are three integers a, b, d (1&lt;= a, b&lt;=N, |d|&lt;=10^4) after c. If c = 4 (it is a query operation), there are two integers a, b (1&lt;= a, b&lt;=N) after c. All these parameters have the same meaning as described in problem description. Output For each test case, first output “Case #x:”” (x means case ID) in a separate line. For each query operation, output two values: the second largest weight and the number of times it occurs. If the weights of nodes on that path are all the same, just output “ALL SAME” (without quotes). Sample Input 2 3 2 1 1 2 1 2 1 3 4 1 2 4 2 3 7 7 5 3 2 1 7 3 6 1 2 1 3 3 4 3 5 4 6 4 7 4 2 6 3 4 5 -1 4 5 7 1 3 4 2 4 4 3 6 2 3 6 5 4 3 6 Sample Output Case #1: ALL SAME 1 2 Case #2: 3 2 1 1 3 2 ALL SAME 手敲了下LCT。 我的LCT还是挺快的，TAT /* ***Author :kuangbinCreated Time :2014/9/14 9:10:24File Name :E:\2014ACM\2014网络赛\2014鞍山\HDU5002.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 100010;struct Node null;struct Node{ Node \fa,*ch[2]; int val,size; int same,add; int rev; int mm,mmc; int sm,smc; inline void clear(int _val){ fa = ch[0] = ch[1] = null; val = _val; size = 1; same = -INF; add = 0; mm = _val; mmc = 1; sm = -INF; smc = 0; } inline void add_val(int _val,int num){ if(_val == -INF)return; if(_val &lt; sm)return; if(_val == sm)smc += num; else if(_val &lt; mm){ sm = _val; smc = num; } else if(_val == mm){ mmc += num; } else{ sm = mm; smc = mmc; mm = _val; mmc = num; } } inline void push_up(){ size = 1 + ch[0]-&gt;size + ch[1]-&gt;size; mm = sm = -INF; mmc = smc = 0; add_val(val,1); add_val(ch[0]-&gt;mm,ch[0]-&gt;mmc); add_val(ch[0]-&gt;sm,ch[0]-&gt;smc); add_val(ch[1]-&gt;mm,ch[1]-&gt;mmc); add_val(ch[1]-&gt;sm,ch[1]-&gt;smc); } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void flip(){ if(this == null)return; swap(ch[0],ch[1]); rev ^= 1; } inline void update_add(int w){ if(this == null)return; if(mm != -INF)mm += w; if(sm != -INF)sm += w; val += w; add += w; } inline void update_same(int w){ if(this == null)return; mm = w; mmc = size; sm = -INF; smc = 0; same = w; val = w; add = 0; } inline void push_down(){ if(same != -INF){ ch[0]-&gt;update_same(same); ch[1]-&gt;update_same(same); same = -INF; } if(add){ ch[0]-&gt;update_add(add); ch[1]-&gt;update_add(add); add = 0; } if(rev){ ch[0]-&gt;flip(); ch[1]-&gt;flip(); rev = 0; } } inline void go(){ if(!isroot())fa-&gt;go(); push_down(); } inline void rot(){ Node \f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ go(); while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay()-&gt;setc(q,1); p-&gt;push_up(); } return splay(); } inline Node find_root(){ Node x; for(x = access(); x-&gt;push_down(), x-&gt;ch[0] != null; x = x-&gt;ch[0]); return x; } void make_root(){ access()-&gt;flip(); } void cut(){ access(); ch[0]-&gt;fa = null; ch[0] = null; push_up(); } void cut(Node x){ if(this == x || find_root() != x-&gt;find_root())return; else{ x-&gt;make_root(); cut(); } } void link(Node x){ if(find_root() == x-&gt;find_root())return; else { make_root(); fa = x; } }};void SAME(Node *x,Node *y,int w){ x-&gt;access(); for(x = null; y != null; x = y, y = y-&gt;fa){ y-&gt;splay(); if(y-&gt;fa == null){ y-&gt;ch[1]-&gt;update_same(w); x-&gt;update_same(w); y-&gt;val = w; y-&gt;push_up(); return; } y-&gt;setc(x,1); y-&gt;push_up(); }}void ADD(Node *x,Node *y,int w){ x-&gt;access(); for(x = null; y != null; x = y, y = y-&gt;fa){ y-&gt;splay(); if(y-&gt;fa == null){ y-&gt;ch[1]-&gt;update_add(w); x-&gt;update_add(w); y-&gt;val += w; y-&gt;push_up(); return; } y-&gt;setc(x,1); y-&gt;push_up(); }}int MM,MMC;int SM,SMC;void ADD_VAL(int val,int num){ if(val == -INF)return; if(val &lt; SM)return; if(val == SM)SMC += num; else if(val &lt; MM){ SM = val; SMC = num; } else if(val == MM){ MMC += num; } else { SM = MM; SMC = MMC; MM = val; MMC = num; }}void ask(Node *x,Node *y){ x-&gt;access(); for(x=null; y != null; x = y, y = y-&gt;fa){ y-&gt;splay(); if(y-&gt;fa == null){ MM = SM = -INF; MMC = SMC = 0; ADD_VAL(y-&gt;val,1); ADD_VAL(y-&gt;ch[1]-&gt;mm,y-&gt;ch[1]-&gt;mmc); ADD_VAL(y-&gt;ch[1]-&gt;sm,y-&gt;ch[1]-&gt;smc); ADD_VAL(x-&gt;sm,x-&gt;smc); ADD_VAL(x-&gt;mm,x-&gt;mmc); return; } y-&gt;setc(x,1); y-&gt;push_up(); }}Node pool[MAXN],tail;Node node[MAXN];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; int n,m; scanf(“%d”,&amp;T); while(T–){ iCase++; printf(“Case #%d:\n”,iCase); scanf(“%d%d”,&amp;n,&amp;m); tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;size = null-&gt;rev = 0; null-&gt;same = -INF; null-&gt;add = 0; null-&gt;mm = null-&gt;sm = -INF; null-&gt;mmc = null-&gt;smc = 0; for(int i = 1;i &lt;= n;i++){ int v ; scanf(“%d”,&amp;v); node[i] = tail++; node[i]-&gt;clear(v); } int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); node[u]-&gt;link(node[v]); } int op; int x,y,a,b; while(m–){ scanf(“%d”,&amp;op); if(op == 1){ scanf(“%d%d%d%d”,&amp;x,&amp;y,&amp;a,&amp;b); node[x]-&gt;cut(node[y]); node[a]-&gt;link(node[b]); } else if(op == 2){ scanf(“%d%d%d”,&amp;a,&amp;b,&amp;x); SAME(node[a],node[b],x); } else if(op == 3){ scanf(“%d%d%d”,&amp;a,&amp;b,&amp;x); ADD(node[a],node[b],x); } else{ scanf(“%d%d”,&amp;a,&amp;b); ask(node[a],node[b]); if(SM == -INF) printf(“ALL SAME\n”); else printf(“%d %d\n”,SM,SMC); } } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>LCT</category>
        <category>Online Judge</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4347 The Closest M Points （KD树）]]></title>
    <url>%2F2014%2F09%2F12%2Fhdu4347%2F</url>
    <content type="text"><![CDATA[HDU4347 KD树模板题，求K近邻，暴力，加个优先队列。 The Closest M PointsTime Limit: 16000/8000 MS (Java/Others) Memory Limit: 98304/98304 K (Java/Others) Total Submission(s): 1963 Accepted Submission(s): 786 Problem Description The course of Software Design and Development Practice is objectionable. ZLC is facing a serious problem .There are many points in K-dimensional space .Given a point. ZLC need to find out the closest m points. Euclidean distance is used as the distance metric between two points. The Euclidean distance between points p and q is the length of the line segment connecting them.In Cartesian coordinates, if p = (p1, p2,…, pn) and q = (q1, q2,…, qn) are two points in Euclidean n-space, then the distance from p to q, or from q to p is given by: Can you help him solve this problem? Input In the first line of the text file .there are two non-negative integers n and K. They denote respectively: the number of points, 1 &lt;= n &lt;= 50000, and the number of Dimensions,1 &lt;= K &lt;= 5. In each of the following n lines there is written k integers, representing the coordinates of a point. This followed by a line with one positive integer t, representing the number of queries,1 &lt;= t &lt;=10000.each query contains two lines. The k integers in the first line represent the given point. In the second line, there is one integer m, the number of closest points you should find,1 &lt;= m &lt;=10. The absolute value of all the coordinates will not be more than 10000. There are multiple test cases. Process to end of file. Output For each query, output m+1 lines: The first line saying :”the closest m points are:” where m is the number of the points. The following m lines representing m points ,in accordance with the order from near to far It is guaranteed that the answer can only be formed in one ways. The distances from the given point to all the nearest m+1 points are different. That means input like this: 2 2 1 1 3 3 1 2 2 1 will not exist. Sample Input 3 2 1 1 1 3 3 4 2 2 3 2 2 3 1 Sample Output the closest 2 points are: 1 3 3 4 the closest 1 points are: 1 3 Author HIT Source 2012 Multi-University Training Contest 5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299/* ***************Author :kuangbinCreated Time :2014/9/6 18:26:05File Name :E:\2014ACM\专题学习\KD树\HDU4347.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 50010;const int DIM = 10;inline double sqr(double x)&#123;return x*x;&#125;namespace KDTree&#123; int K;//维数 struct Point&#123; int x[DIM]; double distance(const Point &amp;b)const&#123; double ret = 0; for(int i = 0;i &lt; K;i++) ret += sqr(x[i]-b.x[i]); return ret; &#125; void input()&#123; for(int i = 0;i &lt; K;i++)scanf("%d",&amp;x[i]); &#125; void output()&#123; for(int i = 0;i &lt; K;i++) printf("%d%c",x[i],i &lt; K-1?' ':'\n'); &#125; &#125;; struct qnode&#123; Point p; double dis; qnode()&#123;&#125; qnode(Point _p,double _dis)&#123; p = _p; dis = _dis; &#125; bool operator &lt;(const qnode &amp;b)const&#123; return dis &lt; b.dis; &#125; &#125;; priority_queue&lt;qnode&gt;q; struct cmpx&#123; int div; cmpx(const int &amp;_div)&#123;div = _div;&#125; bool operator()(const Point &amp;a,const Point &amp;b)&#123; for(int i = 0;i &lt; K;i++) if(a.x[(div+i)%K] != b.x[(div+i)%K]) return a.x[(div+i)%K] &lt; b.x[(div+i)%K]; return true; &#125; &#125;; bool cmp(const Point &amp;a,const Point &amp;b,int div)&#123; cmpx cp = cmpx(div); return cp(a,b); &#125; struct Node&#123; Point e; Node *lc,*rc; int div; &#125;pool[MAXN],*tail,*root; void init()&#123; tail = pool; &#125; Node* build(Point *a,int l,int r,int div)&#123; if(l &gt;= r)return NULL; Node *p = tail++; p-&gt;div = div; int mid = (l+r)/2; nth_element(a+l,a+mid,a+r,cmpx(div)); p-&gt;e = a[mid]; p-&gt;lc = build(a,l,mid,(div+1)%K); p-&gt;rc = build(a,mid+1,r,(div+1)%K); return p; &#125; void search(Point p,Node *x,int div,int m)&#123; if(!x)return; if(cmp(p,x-&gt;e,div))&#123; search(p,x-&gt;lc,(div+1)%K,m); if(q.size() &lt; m)&#123; q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); search(p,x-&gt;rc,(div+1)%K,m); &#125; else &#123; if(p.distance(x-&gt;e) &lt; q.top().dis)&#123; q.pop(); q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); &#125; if(sqr(x-&gt;e.x[div]-p.x[div]) &lt; q.top().dis) search(p,x-&gt;rc,(div+1)%K,m); &#125; &#125; else &#123; search(p,x-&gt;rc,(div+1)%K,m); if(q.size() &lt; m)&#123; q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); search(p,x-&gt;lc,(div+1)%K,m); &#125; else &#123; if(p.distance(x-&gt;e) &lt; q.top().dis)&#123; q.pop(); q.push(qnode(x-&gt;e,p.distance(x-&gt;e))); &#125; if(sqr(x-&gt;e.x[div]-p.x[div]) &lt; q.top().dis) search(p,x-&gt;lc,(div+1)%K,m); &#125; &#125; &#125; void search(Point p,int m)&#123; while(!q.empty())q.pop(); search(p,root,0,m); &#125;&#125;;KDTree::Point p[MAXN];int main()&#123; int n,k; while(scanf("%d%d",&amp;n,&amp;k) == 2)&#123; KDTree::K = k; for(int i = 0;i &lt; n;i++)p[i].input(); KDTree::init(); KDTree::root = KDTree::build(p,0,n,0); int Q; scanf("%d",&amp;Q); KDTree::Point o; while(Q--)&#123; o.input(); int m; scanf("%d",&amp;m); KDTree::search(o,m); printf("the closest %d points are:\n",m); int cnt = 0; while(!KDTree::q.empty())&#123; p[cnt++] = KDTree::q.top().p; KDTree::q.pop(); &#125; for(int i = 0;i &lt; m;i++)p[m-1-i].output(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>数据结构</category>
        <category>KD树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>KD树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4796 Winter's Coming （插头DP）]]></title>
    <url>%2F2014%2F09%2F08%2Fhdu4796%2F</url>
    <content type="text"><![CDATA[AC 了。 一个地方写错，导致产生了多余的环！！！！！ 13年长沙的插头DP题。 //写了一下插头DP， WA到死，然后这题有天坑！！！！ //留个坑吧！ 记录下自己写的插头DP代码！ 当年写得很熟悉的插头DP现在都快忘记了。 已经AC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415/* ***************Author :kuangbinCreated Time :2014/9/8 19:22:58File Name :tmp.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXD = 15;const int STATE = 1000010;const int HASH = 10007;int N,M;int maze[24][MAXD];//-1禁止，-2左边，-3右边int code[MAXD];int ch[MAXD];struct HASHMAP&#123; int head[HASH],next[STATE],size; long long state[STATE]; int f[STATE]; void init()&#123; size = 0; memset(head,-1,sizeof(head)); &#125; void push(long long st,int ans)&#123; int h = st%HASH; for(int i = head[h];i != -1;i = next[i]) if(state[i] == st)&#123; f[i] = min(f[i],ans); return; &#125; state[size] = st; f[size] = ans; next[size] = head[h]; head[h] = size++; &#125;&#125;hm[2];void decode(int *code,int m,long long st)&#123; for(int i = m;i &gt;= 0;i--)&#123; code[i] = st&amp;7; st &gt;&gt;= 3; &#125;&#125;long long encode(int *code,int m)&#123; int cnt = 1; memset(ch,-1,sizeof(ch)); ch[0] = 0; long long st = 0; for(int i = 0;i &lt;= m;i++)&#123; if(ch[code[i]] == -1)ch[code[i]] = cnt++; code[i] = ch[code[i]]; st &lt;&lt;= 3; st |= code[i]; &#125; return st;&#125;void dpblank(int i,int j,int cur)&#123; int k,left,up; for(k = 0;k &lt; hm[cur].size;k++)&#123; decode(code,M,hm[cur].state[k]); left = code[j-1]; up = code[j]; if(left &amp;&amp; up)&#123; if(left == up)&#123; continue;//这种情况不能合并，否则会形成多余的环 code[j-1] = code[j] = 0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; else &#123; code[j-1] = code[j] = 0; for(int t = 0;t &lt;= M;t++) if(code[t] == up) code[t] = left; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; &#125; else if(left || up)&#123; int t ; if(left) t = left; else t = up; if(i == N)&#123; int cc = 0; for(int p = 0;p &lt; j-1;p++) if(code[p]) cc++; if(cc == 0)&#123; code[j] = 0; code[j-1] = t; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; &#125; else if(maze[i+1][j] &gt;= 0)&#123; code[j] = 0; code[j-1] = t; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; if(maze[i][j+1] &gt;= 0)&#123; code[j-1] = 0; code[j] = t; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; &#125; else &#123; code[j-1] = code[j] = 0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]); if(i == N)&#123; int cc = 0; for(int p = 0;p &lt; j-1;p++) if(code[p]) cc++; if(cc == 0 &amp;&amp; maze[i][j+1] &gt;= 0)&#123; code[j] = code[j-1] = 13; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; &#125; else if(maze[i+1][j] &gt;= 0 &amp;&amp; maze[i][j+1] &gt;= 0)&#123; code[j] = code[j-1] = 13; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]+maze[i][j]); &#125; &#125; &#125;&#125;void dpblock(int i,int j,int cur)&#123; int k = 0; for(int k = 0;k &lt; hm[cur].size;k++)&#123; decode(code,M,hm[cur].state[k]); if(code[j] || code[j-1])continue; int cc = 0; for(int p = 0;p &lt; j-1;p++) if(code[p]) cc++; if(maze[i][j] == -2 &amp;&amp; cc%2 == 0)&#123; code[j-1] = code[j] = 0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]); &#125; else if(maze[i][j] == -3 &amp;&amp; cc%2 == 1)&#123; code[j-1] = code[j] = 0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]); &#125; else if(maze[i][j] == -1)&#123; code[j-1] = code[j] = 0; hm[cur^1].push(encode(code,j==M?M-1:M),hm[cur].f[k]); &#125; &#125;&#125;char str[20];void init()&#123; memset(maze,-1,sizeof(maze)); for(int i = 1;i &lt;= N;i++)&#123; scanf("%s",str); for(int j = 1;j &lt;= M;j++)&#123; if(str[j-1] == '#')maze[i][j] = -1; else if(str[j-1] == 'W')maze[i][j] = -2; else if(str[j-1] == 'L')maze[i][j] = -3; else maze[i][j] = str[j-1] - '0'; &#125; &#125;&#125;const int INF = 0x3f3f3f3f;void solve()&#123; int i,j,cur = 0; hm[cur].init(); for(i = 1;i &lt;= M;i++)&#123; if(maze[1][i] &lt; 0)continue; for(j = 0;j &lt;= M;j++)&#123; if(j == i)code[j] = 1; else code[j] = 0; &#125; hm[cur].push(encode(code,M),0); &#125; for(i = 1;i &lt;= N;i++) for(j = 1;j &lt;= M;j++)&#123; hm[cur^1].init(); if(maze[i][j] &gt;= 0)dpblank(i,j,cur); else dpblock(i,j,cur); cur ^= 1; &#125; int ans = INF; for(i = 0;i &lt; hm[cur].size;i++)&#123; decode(code,M,hm[cur].state[i]); int cc = 0; for(j = 1;j &lt;= M;j++) if(code[j]) cc++; if(cc == 1)ans = min(ans,hm[cur].f[i]); &#125; if(ans == INF)ans = -1; printf("%d\n",ans);&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d%d",&amp;N,&amp;M) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>插头DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>插头DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3813 Alternating Sum （胡搞）]]></title>
    <url>%2F2014%2F09%2F08%2Fzoj3813%2F</url>
    <content type="text"><![CDATA[ZOJ3813 推一下公式，然后分类讨论一下。 Alternating Sum Time Limit: 2 Seconds Memory Limit: 65536 KB There is a digit string S with infinite length. In addition, S is periodic and it can be formed by concatenating infinite repetitions of a base string P. For example, if P = 3423537, then S = 3423537342353734235373423537… Let’s define the alternating sum on substrings of S. Assume Sl..r is a substring of S from index l to index r (all indexes are 1-based), then the alternating sum of Sl..r is: G(l, r) = Sl - Sl+1 + Sl+2 - … + (-1)r-lSr For example, S2..10 = 423537342, then G(2, 10) = 4 - 2 + 3 - 5 + 3 - 7 + 3 - 4 + 2 = -3. Now, you are given the base string P and you have to do many operations. There are only two kinds of operations: 1 x d: set Px to d, d is a single digit. 2 l r: find the sum of G(i, j) that l &lt;= i &lt;= j &lt;= r. For each second operation, you should output the sum modulo 109 + 7. InputThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case: The first line contains a digit string P (1 &lt;= length(P) &lt;= 100000). The second line contains an integer Q (1 &lt;= Q &lt;= 100000) indicating the number of operations. Each of the following Q lines is an operation in such format: 1 x d (1 &lt;= x &lt;= length(P), 0 &lt;= d &lt;= 9) 2 l r (1 &lt;= l &lt;= r &lt;= 1018) OutputFor each “2 l r” operation, output an integer, indicating the sum modulo 109 + 7. Sample Input232424242 1 12 1 41 3 72 3 432424262 1 11 3 72 2 41 3 42 7 102 1 30 Sample Output320143820870 如果是对于1操作，直接修改就是了，注意把要维护的东西更新一下。 对于2操作。 比如要查询 \[l,r\] 很容易发现，答案其实是 \\(a\_l*(r-l+1)+a\_(l+2)*(r-l+1-2)+a_(l+4)*(r-l+1-4)+........\\) 其实也就是说是从l出发的奇数项是有值的。 而且前面的系数刚好是等差数列。 那么我们需要维护的是， 奇数和偶数项的 \\(a\_i*(n+1-i)\\)的前缀和。 奇数和偶数项的\\(a\_i\\)的前缀和。 明显树状数组已经足矣。 为何这样维护是可以的呢？ 因为刚才说的要求的 \[l,r\]区间的，是可以分段的。 首先是首尾的两段，还有中间的很多段。（当然有可能只有一段或者两段） 所以首先找到 l,r所属于的块，也就是 (i+(n-1))/n 对于需要求的第一段，形式明显是要求 \\(a\_i*(r-l+1)+a\_(i+2)*(r-l+1-2)+......\\) 这里加的是 \[i,n\]这一段的了。 这个其实是我们维护了的后缀和。 因为我们可以很快求出 \\a\_i*(n+1-i)+a\_(i+2)*(n+1-i-2)+....\\) 要求的只需要加了 \\(a\_i+a\_(i+2)+....\\)的倍数就可以了。 尾部和 r 同一段的求的方法类似。 至于中间部分。 只需要对 n分奇数和偶数去讨论。 如果n是偶数。 那么一段一段是周期的。 可以用等差数列求和。 如果n是奇数，然么两段两段是周期的，一样可以用等差数列去求和。 最近写代码能力急剧下降！ 尤其是在比赛后期，思路完全乱掉了，经常犯SB错误，sad #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;const int MAXN = 100010;const int MOD = 1e9+7;void Add(long long &amp;a,long long b){ a += b; if(a &gt;= MOD)a -= MOD;}int lowbit(int x){ return x&amp;(-x);}struct BIT{ long long c[MAXN]; int n; void init(int _n){ n = _n; memset(c,0,sizeof(c)); } long long sum(int i){ long long s = 0; while(i &gt; 0){ Add(s,c[i]); i -= lowbit(i); } return s; } void add(int i,long long val){ while(i &lt;= n){ Add(c[i],val); i += lowbit(i); } }}bt0,bt1,bt2,bt3;int a[MAXN];char str[MAXN];int n;long long getid(long long x){ return (x + n-1)/n;}int getpos(long long x){ return (x-1)%n + 1;}long long SUM(int pos1,int pos2,long long loc){ long long ans = 0; long long sum; if(pos1%2 != pos2%2)pos2–; if(pos1%2 == 1){ ans = bt0.sum(pos2) - bt0.sum(pos1-1); sum = bt2.sum(pos2) - bt2.sum(pos1-1); } else { ans = bt1.sum(pos2) - bt1.sum(pos1-1); sum = bt3.sum(pos2) - bt3.sum(pos1-1); } ans = ans + (loc - (n+1-pos1))%MODsum%MOD; ans = (ans%MOD+MOD)%MOD; return ans;}long long inv(long long a,long long m){ if(a == 1)return 1; return inv(m%a,m)(m-m/a)%m;}int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out1.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); while(T–){ scanf(“%s”,str); n = strlen(str); for(int i = 0;i &lt; n;i++) a[i+1] = str[i] - ‘0’; bt0.init(n); bt1.init(n); bt2.init(n); bt3.init(n); for(int i = 1;i &lt;= n;i++){ if(i%2 == 1){ bt0.add(i,a[i](n+1-i)); bt2.add(i,a[i]); } else{ bt1.add(i,a[i](n+1-i)); bt3.add(i,a[i]); } } int op; int x,d; long long l,r; int m; scanf(“%d”,&amp;m); while(m–){ scanf(“%d”,&amp;op); if(op == 1){ scanf(“%d%d”,&amp;x,&amp;d); if(x%2 == 1){ bt0.add(x,-a[x](n+1-x)); bt0.add(x,d(n+1-x)); bt2.add(x,-a[x]); bt2.add(x,d); } else { bt1.add(x,-a[x](n+1-x)); bt1.add(x,d(n+1-x)); bt3.add(x,-a[x]); bt3.add(x,d); } a[x] = d; } else { scanf(“%lld%lld”,&amp;l,&amp;r); long long id1 = getid(l); long long id2 = getid(r); int pos1 = getpos(l); int pos2 = getpos(r); if(id1 == id2){ long long ans = SUM(pos1,pos2,r-l+1); printf(“%lld\n”,ans); } else { long long ans = 0; int pos11 = pos1; int pos12 = n; if(pos11%2 != pos12%2)pos12–; ans += SUM(pos11,pos12,r-l+1); ans = (ans%MOD+MOD)%MOD; int pos21 = 1; int pos22 = pos2; if( ((id2-1)n + 1 - l)%2 != 0 )pos21++; if(pos22%2 != pos21%2)pos22–; if(pos21 &lt;= pos22){ ans += SUM(pos21,pos22,r - ((id2-1)n + pos21) + 1); ans = (ans%MOD+MOD)%MOD; } if(id1 &lt; id2-1){ if(n % 2 == 0){ int pos11 = 1; int pos12 = n; if( (id1n+1-l)%2 != 0 )pos11++; if(pos12 % 2 != pos11%2)pos12–; if(pos11 &lt;= pos12){ long long tmp1 = SUM(pos11,pos12,0); long long sou = (r - (id1n + pos11) + 1); sou = (sou%MOD+MOD)%MOD; long long nn = id2 - id1 - 1; nn %= MOD; long long ttt = nn*sou%MOD + nn*(nn-1)%MOD*inv(2,MOD)%MOD*(-n)%MOD; ttt = (ttt%MOD+MOD)%MOD; long long s1; if(pos11%2 == 1)s1 = bt2.sum(pos12) - bt2.sum(pos11-1); else s1 = bt3.sum(pos12) - bt3.sum(pos11-1); long long tttt = tmp1*nn%MOD + s1*ttt%MOD; tttt = (tttt%MOD+MOD)%MOD; ans = (ans + tttt)%MOD; } } else { long long idcnt = id2 - id1 - 1; if((idcnt/2) &gt; 0){ int pos11 = 1; int pos12 = n; if((id1n+1-l)%2 != 0)pos11++; if(pos12%2 != pos11%2)pos12–; int pos21 = 1; int pos22 = n; if(((id1+1)n+1-l)%2 != 0)pos21++; if(pos22%2 != pos21%2)pos22–; long long tmp1 = SUM(pos11,pos12,0); long long tmp2 = SUM(pos21,pos22,-( pos21 + n - pos11 )); long long tmp = tmp1 + tmp2; tmp = (tmp%MOD+MOD)%MOD; long long sou = (r - (id1*n + pos11) + 1); sou = (sou%MOD+MOD)%MOD; long long nn = idcnt/2; nn %= MOD; long long ttt = nn\*sou%MOD + nn\*(nn-1)%MOD\*inv(2,MOD)%MOD\*(-2*n)%MOD; ttt = (ttt%MOD+MOD)%MOD; long long s1,s2; if(pos11%2 == 1)s1 = bt2.sum(pos12) - bt2.sum(pos11-1); else s1 = bt3.sum(pos12) - bt3.sum(pos11-1); if(pos21%2 == 1)s2 = bt2.sum(pos22) - bt2.sum(pos21-1); else s2 = bt3.sum(pos22) - bt3.sum(pos21-1); s1 = (s1 + s2)%MOD; long long tttt = (tmp\*nn%MOD+s1\*ttt%MOD)%MOD; tttt = (tttt%MOD + MOD)%MOD; ans = (ans + tttt)%MOD; } if(idcnt%2 != 0){ int pos1 = 1; int pos2 = n; if( ((id2-2)*n + 1-l)%2 != 0 )pos1++; if(pos2%2 != pos1%2)pos2--; if(pos2 &gt;= pos1){ ans += SUM(pos1,pos2,r - ((id2-2)*n + pos1) + 1); ans = (ans%MOD+MOD)%MOD; } } } } printf(&quot;%lld\\n&quot;,ans); } } } } return 0; }]]></content>
      <categories>
        <category>Online Judge</category>
        <category>ZJU</category>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4742 Pinball Game 3D （KD树）]]></title>
    <url>%2F2014%2F09%2F05%2Fhdu4742-kd%2F</url>
    <content type="text"><![CDATA[HDU4742用cdq分治搞了这题以后，再用KD树搞一发，KD树也挺裸的了，就是求一个范围里面的最小值。 Pinball Game 3DTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 633 Accepted Submission(s): 256 Problem Description RD is a smart boy and excel in pinball game. However, playing common 2D pinball game for a great number of times results in accumulating tedium. Recently, RD has found a new type of pinball game, a 3D pinball game. The 3D pinball game space can be regarded as a three dimensional coordinate system containing N balls. A ball can be considered as a point. At the beginning, RD made a shot and hit a ball. The ball hit by RD will move and may hit another ball and the “another ball” may move and hit another another ball, etc. But once a ball hit another ball, it will disappear. RD is skilled in this kind of game, so he is able to control every ball’s moving direction. But there is a limitation: if ball A’s coordinate is (x1,y1,z1) and ball B’s coordinate is (x2,y2,z2), then A can hit B only if x1 &lt;= x2 and y1 &lt;= y2 and z1 &lt;= z2. Now, you should help RD to calculate the maximum number of balls that can be hit and the number of different shooting schemes that can achieve that number. Two schemes are different if the sets of hit balls are not the same. The order doesn’t matter. Input The first line contains one integer T indicating the number of cases. In each case, the first line contains one integer N indicating the number of balls. The next N lines each contains three non-negative integer (x, y, z), indicating the coordinate of a ball. The data satisfies T &lt;= 3, N &lt;= 105, 0 &lt;= x, y, z &lt;= 230, no two balls have the same coordinate in one case. Output Print two integers for each case in a line, indicating the maximum number of balls that can be hit and the number of different shooting schemes. As the number of schemes can be quite large, you should output this number mod 230. Sample Input 2 3 2 0 0 0 1 0 0 1 1 5 3 0 0 0 1 0 0 0 1 0 2 2 3 3 3 Sample Output 2 1 3 2 Hint In the first case, RD can shoot the second ball at first and hit the third ball indirectly. In the second case, RD can shoot the second or the third ball initially and hit the fourth ball as well as the fifth ball. Two schemes are both the best. 直接上代码了！！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243/* ***************Author :kuangbinCreated Time :2014/9/4 23:32:36File Name :E:\2014ACM\专题学习\KD树\HDU4742.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int MOD = 1&lt;&lt;30;const int INF = 0x7fffffff;//这个一定要够大struct Node&#123; pair&lt;int,int&gt;e,sub,cur; bool div; Node *lc,*rc;&#125;;Node pool[MAXN],*tail;Node *root;bool cmpX(const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b)&#123;return a.first &lt; b.first || (a.first == b.first &amp;&amp; a.second &lt; b.second);&#125;bool cmpY(const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b)&#123;return a.second &lt; b.second || (a.second == b.second &amp;&amp; a.first &lt; b.first);&#125;bool cmp(const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b,bool div)&#123;return div?cmpY(a,b):cmpX(a,b);&#125;Node* build(pair&lt;int,int&gt; *a,int l,int r,bool div)&#123; if(l &gt;= r)return NULL; Node *p = tail++; p-&gt;div = div; int mid = (l+r)/2; nth_element(a+l,a+mid,a+r,div?cmpY:cmpX); p-&gt;e = a[mid]; p-&gt;cur = p-&gt;sub = make_pair(0,0); p-&gt;lc = build(a,l,mid,!div); p-&gt;rc = build(a,mid+1,r,!div); return p;&#125;inline void update(pair&lt;int,int&gt; &amp;a,pair&lt;int,int&gt; b)&#123; if(a.first &lt; b.first)a = b; else if(a.first == b.first)&#123; a.second += b.second; if(a.second &gt;= MOD)a.second -= MOD; &#125;&#125;void add(Node *p,pair&lt;int,int&gt; e,pair&lt;int,int&gt; v)&#123; update(p-&gt;sub,v); if(e == p-&gt;e)&#123; update(p-&gt;cur,v); return; &#125; else &#123; if(cmp(p-&gt;e,e,p-&gt;div))add(p-&gt;rc,e,v); else add(p-&gt;lc,e,v); &#125;&#125;pair&lt;int,int&gt;ans;//查询最大值void get(Node *p,pair&lt;int,int&gt;e,int maxx,int maxy)&#123; if(!p)return; if(p-&gt;sub.first &lt; ans.first)return; if(maxx &lt;= e.first &amp;&amp; maxy &lt;= e.second) update(ans,p-&gt;sub); else &#123; if(p-&gt;e.first &lt;= e.first &amp;&amp; p-&gt;e.second &lt;= e.second)update(ans,p-&gt;cur); if(p-&gt;div)&#123; if(p-&gt;e.second &lt;= e.second)get(p-&gt;rc,e,maxx,maxy); get(p-&gt;lc,e,maxx,min(maxy,p-&gt;e.second)); &#125; else &#123; if(p-&gt;e.first &lt;= e.first)get(p-&gt;rc,e,maxx,maxy); get(p-&gt;lc,e,min(maxx,p-&gt;e.first),maxy); &#125; &#125;&#125;struct TNode&#123; int x,y,z; void input()&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); &#125; bool operator &lt; (const TNode &amp;b)const&#123; if(x != b.x)return x &lt; b.x; else if(y != b.y)return y &lt; b.y; else return z &lt; b.z; &#125;&#125;node[MAXN];pair&lt;int,int&gt;p[MAXN];pair&lt;int,int&gt;dp[MAXN];int main()&#123; int T; int n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); int cnt = 0; for(int i = 0;i &lt; n;i++)&#123; node[i].input(); p[cnt++] = make_pair(node[i].y,node[i].z); &#125; sort(node,node+n); sort(p,p+cnt); cnt = unique(p,p+cnt)-p; tail = pool; root = build(p,0,cnt,0); for(int i = 0;i &lt; n;i++)dp[i] = make_pair(1,1); for(int i = 0;i &lt; n;i++)&#123; ans = make_pair(0,0); get(root,make_pair(node[i].y,node[i].z),INF,INF); ans.first++; update(dp[i],ans); add(root,make_pair(node[i].y,node[i].z),dp[i]); &#125; printf("%d %d\n",root-&gt;sub.first,root-&gt;sub.second); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>数据结构</category>
        <category>KD树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数据结构</tag>
        <tag>KD树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4742 Pinball Game 3D （cdq分治）]]></title>
    <url>%2F2014%2F09%2F04%2Fhdu4742-cdq%2F</url>
    <content type="text"><![CDATA[HDU4742 经典题，可以用树套树，也可以用cdq分治，还是cdq分治写起来比较方便！ Pinball Game 3DTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 630 Accepted Submission(s): 254 Problem Description RD is a smart boy and excel in pinball game. However, playing common 2D pinball game for a great number of times results in accumulating tedium.Recently, RD has found a new type of pinball game, a 3D pinball game. The 3D pinball game space can be regarded as a three dimensional coordinate system containing N balls. A ball can be considered as a point. At the beginning, RD made a shot and hit a ball. The ball hit by RD will move and may hit another ball and the “another ball” may move and hit another another ball, etc. But once a ball hit another ball, it will disappear. RD is skilled in this kind of game, so he is able to control every ball’s moving direction. But there is a limitation: if ball A’s coordinate is (x1,y1,z1) and ball B’s coordinate is (x2,y2,z2), then A can hit B only if x1 &lt;= x2 and y1 &lt;= y2 and z1 &lt;= z2. Now, you should help RD to calculate the maximum number of balls that can be hit and the number of different shooting schemes that can achieve that number. Two schemes are different if the sets of hit balls are not the same. The order doesn’t matter. Input The first line contains one integer T indicating the number of cases. In each case, the first line contains one integer N indicating the number of balls. The next N lines each contains three non-negative integer (x, y, z), indicating the coordinate of a ball. The data satisfies T &lt;= 3, N &lt;= 105, 0 &lt;= x, y, z &lt;= 230, no two balls have the same coordinate in one case. Output Print two integers for each case in a line, indicating the maximum number of balls that can be hit and the number of different shooting schemes. As the number of schemes can be quite large, you should output this number mod 230. Sample Input 2 3 2 0 0 0 1 0 0 1 1 5 3 0 0 0 1 0 0 0 1 0 2 2 3 3 3 Sample Output 2 1 3 2 Hint In the first case, RD can shoot the second ball at first and hit the third ball indirectly. In the second case, RD can shoot the second or the third ball initially and hit the fourth ball as well as the fifth ball. Two schemes are both the best. Source 2013 ACM/ICPC Asia Regional Hangzhou Online 就是三维的LIS。 按照x排序可以减少一维，然后使用cdq分治的方法，用左边的去更新右边的，按照y的顺序加入。 要对z进行离散化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/* ***************Author :kuangbinCreated Time :2014/9/4 21:53:53File Name :E:\2014ACM\专题学习\CDQ分治\HDU4742.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int MOD = (1&lt;&lt;30);void update(pair&lt;int,int&gt;&amp;p1,pair&lt;int,int&gt;p2)&#123; if(p1.first &lt; p2.first)p1 = p2; else if(p1.first == p2.first)&#123; p1.second += p2.second; if(p1.second &gt;= MOD)p1.second -= MOD; &#125;&#125;pair&lt;int,int&gt;dp[MAXN];pair&lt;int,int&gt;c[MAXN];int n;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int i,pair&lt;int,int&gt;val)&#123; while(i &lt;= n)&#123; update(c[i],val); i += lowbit(i); &#125;&#125;pair&lt;int,int&gt; sum(int i)&#123; pair&lt;int,int&gt;res = make_pair(0,0); while(i &gt; 0)&#123; update(res,c[i]); i -= lowbit(i); &#125; return res;&#125;void CLR(int i)&#123; while(i &lt;= n)&#123; c[i] = make_pair(0,0); i += lowbit(i); &#125;&#125;struct Point&#123; int x,y,z; int id; void input()&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); &#125;&#125;p[MAXN];bool cmpx(Point a,Point b)&#123; if(a.x != b.x)return a.x &lt; b.x; else if(a.y != b.y)return a.y &lt; b.y; else return a.z &lt; b.z;&#125;bool cmpy(Point a,Point b)&#123; if(a.y != b.y)return a.y &lt; b.y; else return a.z &lt; b.z;&#125;int zz[MAXN];void solve(int l,int r)&#123; if(l == r)return; int mid = (l+r)/2; solve(l,mid); sort(p+l,p+mid+1,cmpy); sort(p+mid+1,p+r+1,cmpy); int j = l; for(int i = mid+1;i &lt;= r;i++)&#123; while(j &lt;= mid &amp;&amp; p[j].y &lt;= p[i].y) &#123; add(p[j].z,dp[p[j].id]); j++; &#125; pair&lt;int,int&gt; res = sum(p[i].z); res.first++; update(dp[p[i].id],res); &#125; for(int i = l;i &lt;= mid;i++)CLR(p[i].z); sort(p+mid+1,p+r+1,cmpx); solve(mid+1,r);&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); int cnt = 0; for(int i = 1;i &lt;= n;i++)&#123; p[i].input(); zz[++cnt] = p[i].z; &#125; sort(zz+1,zz+cnt+1); cnt = unique(zz+1,zz+cnt+1)-zz-1; for(int i = 1;i &lt;= n;i++) p[i].z = lower_bound(zz+1,zz+cnt+1,p[i].z)-zz; sort(p+1,p+n+1,cmpx); for(int i = 1;i &lt;= n;i++) p[i].id = i; for(int i = 1;i &lt;= n;i++)&#123; c[i] = make_pair(0,0); dp[i] = make_pair(1,1); &#125; solve(1,n); pair&lt;int,int&gt;ans = make_pair(0,0); for(int i = 1;i &lt;= n;i++) update(ans,dp[i]); printf("%d %d\n",ans.first,ans.second); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>cdq分治</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTREE系列1~7 的 LCT解法]]></title>
    <url>%2F2014%2F08%2F29%2Fqtree-lct%2F</url>
    <content type="text"><![CDATA[早就想把QTREE序列搞完的，一直拖到现在才搞。 使用LCT把QTREE序列都搞了一遍。先贴个题目链接：QTREE1 QTREE2 QTREE3 QTREE4 QTREE5 QTREE6 QTREE7 QTREE6和QTREE7是岛娘的经典之作，简直不能更经典。 QTREE1，QTRE2，QTREE3都是比较水的了，搞路径的都比较简单，QTREE4和QTREE5是子树的比较赞。 QTREE1题意： 给定一棵n个结点的树，树的边上有权。有两种操作： 1.修改一条边上的权值。 2.查询两个结点x和y之间的最短路径中经过的最大的边的权值。 其中\(n&lt;=10^4\) 很水了，LCT直接搞就是了，维护最大值。 有点卡常数，SPOJ太慢了！SPOJ太慢了！SPOJ太慢了！SPOJ太慢了！ 反正代码没怎么优化，有的时候还加了输入挂，各种优化加上去就难看了。 /* ***Author :kuangbinCreated Time :2014/8/26 17:58:27File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;// http://www.spoj.com/problems/QTREE/const int MAXN = 10010;struct Node null;struct Node{ Node \fa,*ch[2]; int Max,key; inline void push_up(){ if(this == null)return; Max = max(key,max(ch[0]-&gt;Max,ch[1]-&gt;Max)); } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot() { return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node \f = fa,*ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay()-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;Max = null-&gt;key = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;fa = node[i]-&gt;ch[0] = node[i]-&gt;ch[1] = null; node[i]-&gt;Max = node[i]-&gt;key = 0; }}struct Edge{ int to,next; int w,id;}edge[MAXN2];int head[MAXN],tot;inline int addedge(int u,int v,int w,int id){ edge[tot].to = v; edge[tot].w = w; edge[tot].id = id; edge[tot].next = head[u]; head[u] = tot++;}Node ee[MAXN];bool vis[MAXN];void bfs(int n){ for(int i = 1;i &lt;= n;i++)vis[i] = false; queueq; q.push(1); vis[1] = true; while(!q.empty()){ int u = q.front(); q.pop(); for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(vis[v])continue; vis[v] = true; q.push(v); ee[edge[i].id] = node[v]; node[v]-&gt;key = edge[i].w; node[v]-&gt;push_up(); node[v]-&gt;fa = node[u]; } }}inline int ask(Node *x,Node *y){ x-&gt;access(); for(x = null; y != null; x = y, y = y-&gt;fa){ y-&gt;splay(); if(y-&gt;fa == null)return max(y-&gt;ch[1]-&gt;Max,x-&gt;Max); y-&gt;setc(x,1); y-&gt;push_up(); }}int main(){ int T; scanf(“%d”,&amp;T); int n; while(T–){ scanf(“%d”,&amp;n); for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; init(n); int u,v,w; for(int i = 1;i &lt; n;i++){ scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w); addedge(u,v,w,i); addedge(v,u,w,i); } bfs(n); char op[20]; int x,y; while(scanf(“%s”,op) == 1){ if(strcmp(op,”DONE”) == 0)break; scanf(“%d%d”,&amp;x,&amp;y); if(op[0] == ‘Q’){ printf(“%d\n”,ask(node[x],node[y])); } else { ee[x]-&gt;splay()-&gt;key = y; ee[x]-&gt;push_up(); } } } return 0;} QTREE2题意： 给定一棵n个结点的树，树的边上有权。有两种操作： 1.查询两个结点x和y之间的最短路径长度。 2.查询从x到y的最短路径的第K条边的长度。 其中 \(n&lt;=10^4\) 连修改操作都没有，简直随便搞！ /* ***Author :kuangbinCreated Time :2014/8/26 21:42:19File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE2.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;// http://www.spoj.com/problems/QTREE2/const int MAXN = 10010;struct Node null;struct Node{ Node \fa,*ch[2]; int sum,val; int size; int id; void clear(){ fa = ch[0] = ch[1] = null; sum = val = 0; size = 1; } inline void push_up(){ if(this == null)return; sum = val + ch[0]-&gt;sum + ch[1]-&gt;sum; size = ch[0]-&gt;size + ch[1]-&gt;size + 1; } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node \f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay()-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;size = null-&gt;sum = null-&gt;val = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;id = i; node[i]-&gt;clear(); }}struct Edge{ int to,next; int w;}edge[MAXN2];int head[MAXN],tot;inline void addedge(int u,int v,int w){ edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;}void dfs(int u,int pre){ for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == pre)continue; dfs(v,u); node[v]-&gt;val = edge[i].w; node[v]-&gt;push_up(); node[v]-&gt;fa = node[u]; }}//查询x-&gt;y的距离inline int query_sum(Node \x,Node *y){ x-&gt;access(); for(x = null; y != null; x = y, y = y-&gt;fa){ y-&gt;splay(); if(y-&gt;fa == null) return y-&gt;ch[1]-&gt;sum + x-&gt;sum; y-&gt;setc(x,1); y-&gt;push_up(); }}//在splay中得到第k个点Node get_kth(Node r,int k){ Node x = r; while(x-&gt;ch[0]-&gt;size+1 != k){ if(k &lt; x-&gt;ch[0]-&gt;size+1)x = x-&gt;ch[0]; else { k -= x-&gt;ch[0]-&gt;size+1; x = x-&gt;ch[1]; } } return x;}//查询x-&gt;y路径上的第k个点inline int query_kth(Node \x,Node *y,int k){ x-&gt;access(); for(x = null; y != null; x = y, y = y-&gt;fa){ y-&gt;splay(); if(y-&gt;fa == null){ if(y-&gt;ch[1]-&gt;size+1 == k)return y-&gt;id; else if(y-&gt;ch[1]-&gt;size+1 &gt; k) return get_kth(y-&gt;ch[1],y-&gt;ch[1]-&gt;size+1-k)-&gt;id; else return get_kth(x,k-(y-&gt;ch[1]-&gt;size+1))-&gt;id; } y-&gt;setc(x,1); y-&gt;push_up(); }}int main(){ int T,n; scanf(“%d”,&amp;T); while(T–){ scanf(“%d”,&amp;n); for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; init(n); int u,v,w; for(int i = 1;i &lt; n;i++){ scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w); addedge(u,v,w); addedge(v,u,w); } dfs(1,1); char op[20]; while(scanf(“%s”,op) == 1){ if(strcmp(op,”DONE”) == 0)break; if(op[0] == ‘D’){ scanf(“%d%d”,&amp;u,&amp;v); printf(“%d\n”,query_sum(node[u],node[v])); } else { int k; scanf(“%d%d%d”,&amp;u,&amp;v,&amp;k); printf(“%d\n”,query_kth(node[u],node[v],k)); } } } return 0;} QTREE3题意： 给定一棵n个结点的树，树的每个结点有黑白两色，初始时都是白的。两种操作： 1.对一个结点执行反色操作（白变黑，黑变白） 2.查询从1号结点到i号结点的路径上的第一个黑色结点编号。 其中\(n&lt;=10^5\). 查询数目不超过\(10^5\). LCT维护路径上的白点和黑点数目，然后就可以解决了。 水题！ /* ***Author :kuangbinCreated Time :2014/8/27 17:34:19File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE3.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;//http://www.spoj.com/problems/QTREE3/const int MAXN = 100010;struct Node null;struct Node{ Node \fa,*ch[2]; int val,sum; int id; void clear(){ fa = ch[0] = ch[1] = null; val = sum = 0; } inline void push_up(){ if(this == null)return; sum = val + ch[0]-&gt;sum + ch[1]-&gt;sum; } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node \f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this ,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay()-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;val = null-&gt;sum = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;clear(); node[i]-&gt;id = i; }}struct Edge{ int to,next;}edge[MAXN2];int head[MAXN],tot;inline void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}void dfs(int u,int pre){ for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == pre)continue; dfs(v,u); node[v]-&gt;fa = node[u]; }}void change(int u){ node[u]-&gt;splay()-&gt;val ^= 1; node[u]-&gt;push_up();}int ask(int v){ node[v]-&gt;access(); node[v]-&gt;splay(); if(node[v]-&gt;sum == 0)return -1; Node x = node[v]; while(x != null){ if(x-&gt;ch[0]-&gt;sum == 0 &amp;&amp; x-&gt;val == 1)return x-&gt;id; if(x-&gt;ch[0]-&gt;sum)x = x-&gt;ch[0]; else x = x-&gt;ch[1]; }} int main(){ int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2){ for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; init(n); int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } dfs(1,1); while(m–){ scanf(“%d%d”,&amp;u,&amp;v); if(u == 0)change(v); else printf(“%d\n”,ask(v)); } } return 0;} QTREE4题意： 给定一棵n个结点的树，树的边上有权，每个结点有黑白两色，初始时所有的结点都是白的。有两种操作： 1.对一个结点执行反色操作（白变黑，黑变白） 2.查询树中距离最远的两个白点的距离。 其中\(n&lt;=10^5\)，查询数目不超过\(10^5\). 做法比较多，有树链剖分，树分治等。 LCT搞起来代码比较短。 经典的要子树的操作，每个点要加set,维护虚边的信息。 关键是写push_up()操作。 也是会卡常数。要谨慎。 /* ***Author :kuangbinCreated Time :2014/8/27 23:29:59File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE4.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;//http://www.spoj.com/problems/QTREE4/const int MAXN = 100010;const int INF = 0x3f3f3f3f;struct Node null;struct Node{ Node \fa,*ch[2]; multisetst0,st1;//st0是链，st1是路径 int dd,d0;//d0是该点对应边的长度，dd是重链长度 int w0;//白点值为0，黑点值为-INF int ls,rs,ms; inline void clear(){ fa = ch[0] = ch[1] = null; st0.clear(); st1.clear(); st0.insert(-INF); st0.insert(-INF); st1.insert(-INF); w0 = 0; dd = d0 = 0; ls = rs = ms = -INF; } inline void push_up(){ if(this == null)return; dd = d0 + ch[0]-&gt;dd + ch[1]-&gt;dd; int m0 = max(w0,st0.rbegin()), ml = max(m0,ch[0]-&gt;rs+d0), mr = max(m0,ch[1]-&gt;ls); ls = max(ch[0]-&gt;ls,ch[0]-&gt;dd + d0 + mr); rs = max(ch[1]-&gt;rs,ch[1]-&gt;dd + ml); multiset::reverse_iterator it = st0.rbegin(); ++it; int t0 = max((\st0.rbegin()) + (*it) , st1.rbegin()); if(w0 == 0) t0 = max(t0,max(0,st0.rbegin())); ms = max(max(max(ml+ch[1]-&gt;ls,mr+d0+ch[0]-&gt;rs),max(ch[0]-&gt;ms,ch[1]-&gt;ms)),t0); } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node \f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay(); if(p-&gt;ch[1] != null){ p-&gt;st0.insert(p-&gt;ch[1]-&gt;ls); p-&gt;st1.insert(p-&gt;ch[1]-&gt;ms); } if(q != null){ p-&gt;st0.erase(p-&gt;st0.find(q-&gt;ls)); p-&gt;st1.erase(p-&gt;st1.find(q-&gt;ms)); } p-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];inline void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;st0.clear(); null-&gt;st1.clear(); null-&gt;ls = null-&gt;rs = null-&gt;ms = -INF; null-&gt;w0 = -INF; null-&gt;d0 = null-&gt;dd = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;clear(); }}struct Edge{ int to,next,w;}edge[MAXN2];int head[MAXN],tot;inline void addedge(int u,int v,int w){ edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;}inline void dfs(int u,int pre){ for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == pre)continue; node[v]-&gt;fa = node[u]; node[v]-&gt;d0 = edge[i].w; dfs(v,u); node[u]-&gt;st0.insert(node[v]-&gt;ls); node[u]-&gt;st1.insert(node[v]-&gt;ms); } node[u]-&gt;push_up();}//适用于正负整数template inline bool scan_d(T &amp;ret) { char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!=’-‘&amp;&amp;(c&lt;’0’||c&gt;’9’)) c=getchar(); sgn=(c==’-‘)?-1:1; ret=(c==’-‘)?0:(c-‘0’); while(c=getchar(),c&gt;=’0’&amp;&amp;c&lt;=’9’) ret=ret10+(c-‘0’); ret*=sgn; return 1;}int main(){ int n; while(scanf(“%d”,&amp;n) == 1){ for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; init(n); int u,v,w; for(int i = 1;i &lt; n;i++){ scan_d(u); scan_d(v);scan_d(w); addedge(u,v,w); addedge(v,u,w); } dfs(1,1); int ans = node[1]-&gt;ms; int Q; char op[10]; scanf(“%d”,&amp;Q); while(Q–){ scanf(“%s”,op); if(op[0] == ‘C’){ scan_d(u); node[u]-&gt;access(); node[u]-&gt;splay(); if(node[u]-&gt;w0 == 0)node[u]-&gt;w0 = -INF; else node[u]-&gt;w0 = 0; node[u]-&gt;push_up(); ans = node[u]-&gt;ms; } else{ if(ans &lt; 0)puts(“They have disappeared.”); else printf(“%d\n”,ans); } } } return 0;} QTREE5题意： 给定一棵n个结点的树，边权均为1。每个结点有黑白两色，初始时所有结点都是黑的。两种查询操作： 1.对一个结点执行反色操作（白变黑，黑变白） 2.查询距离某个特定结点i最远的白点的距离。 其中\(&lt;=10^5\)，查询数目不超过\(10^5\). 比QTREE4简单，会QTREE4了这题简直很水。 /* ***Author :kuangbinCreated Time :2014/8/28 20:57:35File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE5.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;//http://www.spoj.com/problems/QTREE5/const int MAXN = 100010;const int INF = 0x3f3f3f3f;struct Node null;struct Node{ Node \fa,*ch[2]; multisetst; int dd,d0; int w0; int ls,rs; inline void clear(){ fa = ch[0] = ch[1] = null; st.clear(); st.insert(INF); w0 = INF; dd = d0 = 0; ls = rs = INF; } inline void push_up(){ if(this == null)return; dd = d0 + ch[0]-&gt;dd + ch[1]-&gt;dd; int m0 = min(w0,st.begin()), ml = min(m0,ch[0]-&gt;rs+d0), mr = min(m0,ch[1]-&gt;ls); ls = min(ch[0]-&gt;ls,ch[0]-&gt;dd + d0 + mr); rs = min(ch[1]-&gt;rs,ch[1]-&gt;dd + ml); } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node *f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay(); if(p-&gt;ch[1] != null){ p-&gt;st.insert(p-&gt;ch[1]-&gt;ls); } if(q != null){ p-&gt;st.erase(p-&gt;st.find(q-&gt;ls)); } p-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];inline void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;st.clear(); null-&gt;ls = null-&gt;rs = INF; null-&gt;w0 = INF; null-&gt;dd = null-&gt;d0 = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;clear(); }}struct Edge{ int to,next;}edge[MAXN*2];int head[MAXN],tot;inline void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}inline void dfs(int u,int pre){ for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == pre)continue; node[v]-&gt;fa = node[u]; node[v]-&gt;d0 = 1; dfs(v,u); node[u]-&gt;st.insert(node[v]-&gt;ls); } node[u]-&gt;push_up();}int main(){ int n; while(scanf(“%d”,&amp;n) == 1){ init(n); for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } dfs(1,1); int Q; scanf(“%d”,&amp;Q); int op; while(Q–){ scanf(“%d%d”,&amp;op,&amp;v); if(op == 0){ node[v]-&gt;access(); node[v]-&gt;splay(); if(node[v]-&gt;w0 == 0)node[v]-&gt;w0 = INF; else node[v]-&gt;w0 = 0; node[v]-&gt;push_up(); } else { node[v]-&gt;access(); node[v]-&gt;splay(); if(node[v]-&gt;rs &lt; INF)printf(“%d\n”,node[v]-&gt;rs); else printf(“-1\n”); } } } return 0;} QTREE6题意： 给定一棵n个结点的树，每个结点有黑白两色，初始时所有结点都是黑的。你被要求支持： 1.对一个结点执行反色操作（白变黑，黑变白） 2.询问有多少个点与u相连。两个结点u,v相连当且仅当u,v路径上所有点的颜色相同。 其中\(n&lt;=10^5\)，查询数目不超过\(10^5\). 维护和左右端点相连的点的个数ls,rs。 还有左右端点的颜色，自己的颜色，子树的两种颜色的总个数。 对于虚边维护两种颜色的总和就可以了。 /* ***Author :kuangbinCreated Time :2014/8/28 21:44:01File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE6.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;//http://www.spoj.com/problems/QTREE6/const int MAXN = 100010;struct Node null;struct Node{ Node \fa,*ch[2]; int co;//0 is black, 1 is white int lco,rco; int ls,rs; int s[2]; int sum[2];//the sum of black and white inline void clear(){ fa = ch[0] = ch[1] = null; co = lco = rco = 0; ls = rs = 1; s[0] = s[1] = 0; sum[0] = 1; sum[1] = 0; } inline void push_up(){ if(this == null)return; if(ch[0] != null)lco = ch[0]-&gt;lco; else lco = co; if(ch[1] != null)rco = ch[1]-&gt;rco; else rco = co; sum[0] = ch[0]-&gt;sum[0] + ch[1]-&gt;sum[0] + (co == 0); sum[1] = ch[0]-&gt;sum[1] + ch[1]-&gt;sum[1] + (co == 1); int ml = 1 + s[co] + (co==ch[0]-&gt;rco?ch[0]-&gt;rs:0); int mr = 1 + s[co] + (co==ch[1]-&gt;lco?ch[1]-&gt;ls:0); ls = ch[0]-&gt;ls; if(lco == co &amp;&amp; ch[0]-&gt;sum[!co] == 0)ls += mr; rs = ch[1]-&gt;rs; if(rco == co &amp;&amp; ch[1]-&gt;sum[!co] == 0)rs += ml; } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node \f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay(); if(p-&gt;ch[1] != null) p-&gt;s[p-&gt;ch[1]-&gt;lco] += p-&gt;ch[1]-&gt;ls; if(q != null) p-&gt;s[q-&gt;lco] -= q-&gt;ls; p-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;s[0] = null-&gt;s[1] = 0; null-&gt;ls = null-&gt;rs = 0; null-&gt;sum[0] = null-&gt;sum[1] = 0; null-&gt;co = null-&gt;lco = null-&gt;rco = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;clear(); }}struct Edge{ int to,next;}edge[MAXN*2];int head[MAXN],tot;inline void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}void dfs(int u,int pre){ for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == pre)continue; node[v]-&gt;fa = node[u]; dfs(v,u); node[u]-&gt;s[node[v]-&gt;lco] += node[v]-&gt;ls; } node[u]-&gt;push_up();}int main(){ int n; while(scanf(“%d”,&amp;n) == 1){ init(n); for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } dfs(1,1); int Q; int op; scanf(“%d”,&amp;Q); while(Q–){ scanf(“%d%d”,&amp;op,&amp;u); if(op == 0){ node[u]-&gt;access(); node[u]-&gt;splay(); printf(“%d\n”,node[u]-&gt;rs); } else{ node[u]-&gt;access(); node[u]-&gt;splay(); node[u]-&gt;co ^= 1; node[u]-&gt;push_up(); } } return 0; } return 0;} QTREE7题意： 给定一棵n个结点的树，每个结点有黑白两色和权值。三种操作： 1.对一个结点执行反色操作（白变黑，黑变白） 2.询问与u相连的点中点权的最大值。两个结点u,v相连当且仅当u,v路径上所有点的颜色相同。 3.改变一个点的点权。 其中\(n&lt;=10^5\)，查询数目不超过\(10^5\). 会了QTREE6，这题就简单了，增加set维护虚边。 /* ***Author :kuangbinCreated Time :2014/8/29 9:09:44File Name :E:\2014ACM\专题学习\数据结构\LCT\QTREE\SPOJQTREE7.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;//http://www.spoj.com/problems/QTREE7/const int MAXN = 100010;const int INF = 0x3f3f3f3f;struct Node null;struct Node{ Node \fa,*ch[2]; int co; int lco,rco; int ls,rs; int w0; multisetst[2]; int sum[2]; inline void clear(int _co = 0, int _w0 = 0){ fa = ch[0] = ch[1] = null; co = lco = rco = _co; w0 = _w0; ls = rs = _w0; st[0].clear(); st[1].clear(); st[0].insert(-INF); st[1].insert(-INF); sum[0] = sum[1] = 0; sum[_co]++; } inline void push_up(){ if(this == null)return; if(ch[0] != null)lco = ch[0]-&gt;lco; else lco = co; if(ch[1] != null)rco = ch[1]-&gt;rco; else rco = co; sum[0] = ch[0]-&gt;sum[0] + ch[1]-&gt;sum[0] + (co == 0); sum[1] = ch[0]-&gt;sum[1] + ch[1]-&gt;sum[1] + (co == 1); int ml = max(w0,max(st[co].rbegin(),co==ch[0]-&gt;rco?ch[0]-&gt;rs:-INF)); int mr = max(w0,max(st[co].rbegin(),co==ch[1]-&gt;lco?ch[1]-&gt;ls:-INF)); ls = ch[0]-&gt;ls; if(lco == co &amp;&amp; ch[0]-&gt;sum[!co] == 0)ls = max(ls,mr); rs = ch[1]-&gt;rs; if(rco == co &amp;&amp; ch[1]-&gt;sum[!co] == 0)rs = max(rs,ml); } inline void setc(Node p,int d){ ch[d] = p; p-&gt;fa = this; } inline bool d(){ return fa-&gt;ch[1] == this; } inline bool isroot(){ return fa == null || fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this; } inline void rot(){ Node \f = fa, *ff = fa-&gt;fa; int c = d(), cc = fa-&gt;d(); f-&gt;setc(ch[!c],c); this-&gt;setc(f,!c); if(ff-&gt;ch[cc] == f)ff-&gt;setc(this,cc); else this-&gt;fa = ff; f-&gt;push_up(); } inline Node splay(){ while(!isroot()){ if(!fa-&gt;isroot()) d()==fa-&gt;d() ? fa-&gt;rot() : rot(); rot(); } push_up(); return this; } inline Node access(){ for(Node *p = this,*q = null; p != null; q = p, p = p-&gt;fa){ p-&gt;splay(); if(p-&gt;ch[1] != null) p-&gt;st[p-&gt;ch[1]-&gt;lco].insert(p-&gt;ch[1]-&gt;ls); if(q != null) p-&gt;st[q-&gt;lco].erase(p-&gt;st[q-&gt;lco].find(q-&gt;ls)); p-&gt;setc(q,1); p-&gt;push_up(); } return splay(); }};Node pool[MAXN],tail;Node node[MAXN];int color[MAXN],val[MAXN];void init(int n){ tail = pool; null = tail++; null-&gt;fa = null-&gt;ch[0] = null-&gt;ch[1] = null; null-&gt;st[0].clear(); null-&gt;st[1].clear(); null-&gt;ls = null-&gt;rs = -INF; null-&gt;sum[0] = null-&gt;sum[1] = 0; null-&gt;co = null-&gt;lco = null-&gt;rco = 0; for(int i = 1;i &lt;= n;i++){ node[i] = tail++; node[i]-&gt;clear(color[i],val[i]); }}struct Edge{ int to,next;}edge[MAXN*2];int head[MAXN],tot;inline void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}void dfs(int u,int pre){ for(int i = head[u];i != -1;i = edge[i].next){ int v = edge[i].to; if(v == pre)continue; node[v]-&gt;fa = node[u]; dfs(v,u); node[u]-&gt;st[node[v]-&gt;lco].insert(node[v]-&gt;ls); } node[u]-&gt;push_up();}int main(){ int n; while(scanf(“%d”,&amp;n) == 1){ for(int i = 1;i &lt;= n;i++)head[i] = -1; tot = 0; int u,v; for(int i = 1;i &lt; n;i++){ scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } for(int i = 1;i &lt;= n;i++)scanf(“%d”,&amp;color[i]); for(int i = 1;i &lt;= n;i++)scanf(“%d”,&amp;val[i]); init(n); dfs(1,1); int Q; int w,op; scanf(“%d”,&amp;Q); while(Q–){ scanf(“%d”,&amp;op); if(op == 0){ scanf(“%d”,&amp;u); node[u]-&gt;access(); node[u]-&gt;splay(); printf(“%d\n”,node[u]-&gt;rs); } else if(op == 1){ scanf(“%d”,&amp;u); node[u]-&gt;access(); node[u]-&gt;splay(); node[u]-&gt;co ^= 1; node[u]-&gt;push_up(); } else { scanf(“%d%d”,&amp;u,&amp;w); node[u]-&gt;access(); node[u]-&gt;splay(); node[u]-&gt;w0 = w; node[u]-&gt;push_up(); } } } return 0;}]]></content>
      <categories>
        <category>LCT</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3803 Function （DP）]]></title>
    <url>%2F2014%2F08%2F25%2Fzoj3803%2F</url>
    <content type="text"><![CDATA[ZOJ3803简单DP，写个DP能写成这样，我是多么的弱！！！！ Function Time Limit: 2 Seconds Memory Limit: 65536 KB Let x is a binary number with n digits (AnAn-1An-2…A2A1). And we can encode it as G(x) = x ⊕ ⌊x / 2⌋ or as C(x) = (2n - x) mod 2n, where “⊕” is bitwise XOR operation and “⌊x⌋” indicates the largest integer which is not greater than x. For some reasons, Alice encodes her password P into G(P), and additionally, she encodes P into C(P). And she writes G(P) and C(P) in a paper. However, something terrible happened. A bug ate some parts of the paper, so some digits are unreadable now. Alice is so worried that she want you to determine the values of these digits using the readable digits. InputThere are multiple test cases. For every test case, it has 2 lines of same number of digits describe G(P) and C(P). In every line, it only contains ‘1’, ‘0’ and ‘?’. Unreadable digits are denoted with symbol ‘?’. The length of every line in the input is up to 105. OutputIf it is impossible to restore G(P) and C(P), you should output “IMPOSSIBLE” (without quotes). If G(P) is unique, you should output “UNIQUE” (without quotes) in the first line. Then output restored G(P) and C(P) in the same format. If there are two or more possible G(P) that can be restored using the readable digits. You should output “AMBIGUOUS” (without quotes) and the number of possible G(P). The number may be very large, so the answer should modulo 109 + 7. Sample Input1110010111??01??111?100? Sample OutputUNIQUE11100101AMBIGUOUS 3IMPOSSIBLE HintIn the second sample case, the three possible situations are:1.G(1001) = 1101, C(1001) = 01112.G(1010) = 1111, C(1010) = 01103.G(1011) = 1110, C(1011) = 0101 很明显的一个DP。 因为只需要知道当前位是什么，以及前面是不是全0 就可以转移了。 因为G(x)就是相邻两位取异或，C(x) 就是最后一个1位是不变的，后面的都是取反。 比赛做的时候各种if else 乱搞，把转移的所有情况手动列出，太挫了，然后记录路径的时候输出又写错了，调试半天。这个状态简单太差，以现在的状态去比赛，简直就是受虐，sad。 以后把代码实现都想得很明白了再写代码了！！！！！ 代码： #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;const int MAXN = 100010;const int MOD = 1e9+7;int dp1[MAXN][2][2];//dp1[i][j][k]: 前i位，j为0表示前面全0，j为1表示不全为0，k是当前位状态int pre1[MAXN][2][2];//记录路径int pre2[MAXN][2][2];void Add1(int &amp;a,int b){//0是无解，1是唯一解，2是多解 if(a == 0)a = b; else if(a == 1){ if(b == 1)a = 2; else if(b == 2)a = 2; }}char str1[MAXN],str2[MAXN];void Add2(int &amp;a,int b){//取模加法 a += b; if(a &gt;= MOD)a -= MOD;}int a[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%s%s”,str1,str2) == 2){ int n = strlen(str1); reverse(str1,str1+n);//反转 reverse(str2,str2+n); memset(dp1,0,sizeof(dp1)); if(str2[0] == ‘0’)dp1[0][0][0] = 1;//最低位 else if(str2[0] == ‘1’)dp1[0][1][1] = 1; else { dp1[0][0][0] = 1; dp1[0][1][1] = 1; } for(int i = 0;i &lt; n-1;i++) for(int j = 0;j &lt; 2;j++)//前面是否全0 for(int k = 0;k &lt; 2;k++){//当前位 if(dp1[i][j][k] == 0)continue; for(int nk = 0;nk &lt; 2;nk++){//下一位 if(str1[i] == ‘0’ &amp;&amp; nk != k)continue;//k和nk异或为0 if(str1[i] == ‘1’ &amp;&amp; nk == k)continue;//k和nk异或为1 if(str2[i+1] != ‘?’){ if(j == 0 &amp;&amp; nk != str2[i+1]-‘0’)continue;//要相同 if(j == 1 &amp;&amp; nk == str2[i+1]-‘0’)continue;//要相反 } int nj = j|k|nk; Add1(dp1[i+1][nj][nk],dp1[i][j][k]); pre1[i+1][nj][nk] = j; pre2[i+1][nj][nk] = k; } } int ans1 = 0; int tj = -1; int tk = -1; for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(str1[n-1] == ‘0’ &amp;&amp; k == 1)continue; if(str1[n-1] == ‘1’ &amp;&amp; k == 0)continue; if(dp1[n-1][j][k] == 0)continue; Add1(ans1,dp1[n-1][j][k]); if(dp1[n-1][j][k]){ tj = j; tk = k; } } if(ans1 == 0){ printf(“IMPOSSIBLE\n”); continue; } if(ans1 == 1){ printf(“UNIQUE\n”); for(int i = n-1;i &gt;= 0;i–){ a[i] = tk; int nj = pre1[i][tj][tk]; int nk = pre2[i][tj][tk]; tj = nj; tk = nk; } for(int i = n-1;i &gt;= 0;i–){ if(i == n-1)printf(“%d”,a[i]); else printf(“%d”,a[i]^a[i+1]); } printf(“\n”); int tmp1 = 0; while(tmp1 &lt; n &amp;&amp; a[tmp1] == 0 )tmp1++; for(int i = n-1;i &gt;= 0;i–){ if(i &gt; tmp1)printf(“%d”,!a[i]); else printf(“%d”,a[i]); } printf(“\n”); continue; } memset(dp1,0,sizeof(dp1)); if(str2\[0\] == &apos;0&apos;)dp1\[0\]\[0\]\[0\] = 1; else if(str2\[0\] == &apos;1&apos;)dp1\[0\]\[1\]\[1\] = 1; else { dp1\[0\]\[0\]\[0\] = 1; dp1\[0\]\[1\]\[1\] = 1; } for(int i = 0;i &lt; n-1;i++) for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(dp1\[i\]\[j\]\[k\] == 0)continue; for(int nk = 0;nk &lt; 2;nk++){ if(str1\[i\] == &apos;0&apos; &amp;&amp; nk != k)continue; if(str1\[i\] == &apos;1&apos; &amp;&amp; nk == k)continue; if(str2\[i+1\] != &apos;?&apos;){ if(j == 0 &amp;&amp; nk != str2\[i+1\]-&apos;0&apos;)continue; if(j == 1 &amp;&amp; nk == str2\[i+1\]-&apos;0&apos;)continue; } int nj = j|k|nk; Add2(dp1\[i+1\]\[nj\]\[nk\],dp1\[i\]\[j\]\[k\]); } } ans1 = 0; for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(str1\[n-1\] == &apos;0&apos; &amp;&amp; k == 1)continue; if(str1\[n-1\] == &apos;1&apos; &amp;&amp; k == 0)continue; if(dp1\[n-1\]\[j\]\[k\] == 0)continue; Add2(ans1,dp1\[n-1\]\[j\]\[k\]); } printf(&quot;AMBIGUOUS %d\\n&quot;,ans1); } return 0; } 写的if else 乱搞的挫代码。。。。 贴出来纪念我逗比的人生吧！ #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;const int MAXN = 100010;const int MOD = 1e9+7;int dp1[MAXN][2][2];int pre1[MAXN][2][2];int pre2[MAXN][2][2];void Add1(int &amp;a,int b){ if(a == 0)a = b; else if(a == 1){ if(b == 1)a = 2; else if(b == 2)a = 2; }}char str1[MAXN],str2[MAXN];char str[MAXN];void Add2(int &amp;a,int b){ a += b; if(a &gt;= MOD)a -= MOD;}int a[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%s%s”,str1,str2) == 2){ int n = strlen(str1); reverse(str1,str1+n); reverse(str2,str2+n); memset(dp1,0,sizeof(dp1)); if(str2[0] == ‘0’)dp1[0][0][0] = 1; else if(str2[0] == ‘1’)dp1[0][1][1] = 1; else { dp1[0][0][0] = 1; dp1[0][1][1] = 1; } for(int i = 0;i &lt; n-1;i++) for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(dp1[i][j][k] == 0)continue; if(str1[i] == ‘0’){ if(str2[i+1] == ‘0’){ if(j == 0){ if(k == 0){ Add1(dp1[i+1][j][k],dp1[i][j][k]);//0-&gt;0 if(dp1[i][j][k]){ pre1[i+1][j][k] = j; pre2[i+1][j][k] = k; } } } else { if(k == 1){ Add1(dp1[i+1][1][k],dp1[i][j][k]);//1-&gt;1 if(dp1[i][j][k]){ pre1[i+1][1][k] = j; pre2[i+1][1][k] = k; } } } } else if(str2[i+1] == ‘1’){ if(j == 0){ if(k == 1){ Add1(dp1[i+1][1][k],dp1[i][j][k]);//1-&gt;1 if(dp1[i][j][k]){ pre1[i+1][1][k] = j; pre2[i+1][1][k] = k; } } } else { if(k == 0){ Add1(dp1[i+1][j][k],dp1[i][j][k]);//0-&gt;0 if(dp1[i][j][k]){ pre1[i+1][j][k] = j; pre2[i+1][j][k] = k; } } } } else { if(k == 0){ Add1(dp1[i+1][j][k],dp1[i][j][k]);//0-&gt;0 if(dp1[i][j][k]){ pre1[i+1][j][k] = j; pre2[i+1][j][k] = k; } } else{ Add1(dp1[i+1][1][k],dp1[i][j][k]);//1-&gt;1 if(dp1[i][j][k]){ pre1[i+1][1][k] = j; pre2[i+1][1][k] = k; } } } } else if(str1[i] == ‘1’){ if(str2[i+1] == ‘0’){ if(j == 0){ if(k == 1){ Add1(dp1[i+1][1][0],dp1[i][j][k]);//1-&gt;0 if(dp1[i][j][k]){ pre1[i+1][1][0] = j; pre2[i+1][1][0] = k; } } } else{ if(k == 0){ Add1(dp1[i+1][1][1],dp1[i][j][k]);//0-&gt;1 if(dp1[i][j][k]){ pre1[i+1][1][1] = j; pre2[i+1][1][1] = k; } } } } else if(str2[i+1] == ‘1’){ if(j == 0){ if(k == 0){ Add1(dp1[i+1][1][1],dp1[i][j][k]);//0-&gt;1 if(dp1[i][j][k]){ pre1[i+1][1][1] = j; pre2[i+1][1][1] = k; } } } else{ if(k == 1){ Add1(dp1[i+1][1][0],dp1[i][j][k]);//1-&gt;0 if(dp1[i][j][k]){ pre1[i+1][1][0] = j; pre2[i+1][1][0] = k; } } } } else { if(k == 1){ Add1(dp1[i+1][1][0],dp1[i][j][k]);//1-&gt;0 if(dp1[i][j][k]){ pre1[i+1][1][0] = j; pre2[i+1][1][0] = k; } } else{ Add1(dp1[i+1][1][1],dp1[i][j][k]);//0-&gt;1 if(dp1[i][j][k]){ pre1[i+1][1][1] = j; pre2[i+1][1][1] = k; } } } } else { if(str2[i+1] == ‘0’){ if(j == 0){ if(k == 0){ Add1(dp1[i+1][j][k],dp1[i][j][k]);//0-&gt;0 if(dp1[i][j][k]){ pre1[i+1][j][k] = j; pre2[i+1][j][k] = k; } } if(k == 1){ Add1(dp1[i+1][1][0],dp1[i][j][k]);//1-&gt;0 if(dp1[i][j][k]){ pre1[i+1][1][0] = j; pre2[i+1][1][0] = k; } } } else { if(k == 0){ Add1(dp1[i+1][1][1],dp1[i][j][k]);//0-&gt;1 if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[1\] = j; pre2\[i+1\]\[1\]\[1\] = k; } } if(k == 1){ Add1(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]);//1-&gt;1 if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[1\] = j; pre2\[i+1\]\[1\]\[1\] = k; } } } } else if(str2\[i+1\] == &apos;1&apos;){ if(j == 0){ if(k == 0){ Add1(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[1\] = j; pre2\[i+1\]\[1\]\[1\] = k; } } if(k == 1){ Add1(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[1\] = j; pre2\[i+1\]\[1\]\[1\] = k; } } } else { if(k == 0){ Add1(dp1\[i+1\]\[j\]\[k\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[j\]\[k\] = j; pre2\[i+1\]\[j\]\[k\] = k; } } if(k == 1){ Add1(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[0\] = j; pre2\[i+1\]\[1\]\[0\] = k; } } } } else { if(k == 0){ Add1(dp1\[i+1\]\[j\]\[0\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[j\]\[0\] = j; pre2\[i+1\]\[j\]\[0\] = k; } Add1(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[1\] = j; pre2\[i+1\]\[1\]\[1\] = k; } } else { Add1(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[0\] = j; pre2\[i+1\]\[1\]\[0\] = k; } Add1(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); if(dp1\[i\]\[j\]\[k\]){ pre1\[i+1\]\[1\]\[1\] = j; pre2\[i+1\]\[1\]\[1\] = k; } } } } } int ans1 = 0; int tj = -1; int tk = -1; for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(str1\[n-1\] == &apos;0&apos; &amp;&amp; k == 1)continue; if(str1\[n-1\] == &apos;1&apos; &amp;&amp; k == 0)continue; Add1(ans1,dp1\[n-1\]\[j\]\[k\]); if(dp1\[n-1\]\[j\]\[k\]){ tj = j; tk = k; } } if(ans1 == 0){ printf(&quot;IMPOSSIBLE\\n&quot;); continue; } if(ans1 == 1){ printf(&quot;UNIQUE\\n&quot;); for(int i = n-1;i &gt;= 0;i--){ a\[i\] = tk; int nj = pre1\[i\]\[tj\]\[tk\]; int nk = pre2\[i\]\[tj\]\[tk\]; tj = nj; tk = nk; } for(int i = n-1;i &gt;= 0;i--){ if(i == n-1)printf(&quot;%d&quot;,a\[i\]); else printf(&quot;%d&quot;,a\[i\]^a\[i+1\]); } cout&lt;&lt;endl; int tmp1 = 0; while(tmp1 &lt; n &amp;&amp; a\[tmp1\] == 0 )tmp1++; for(int i = n-1;i &gt;= 0;i--){ if(i &gt; tmp1)printf(&quot;%d&quot;,!a\[i\]); else printf(&quot;%d&quot;,a\[i\]); } cout&lt;&lt;endl; continue; } memset(dp1,0,sizeof(dp1)); if(str2\[0\] == &apos;0&apos;)dp1\[0\]\[0\]\[0\] = 1; else if(str2\[0\] == &apos;1&apos;)dp1\[0\]\[1\]\[1\] = 1; else { dp1\[0\]\[0\]\[0\] = 1; dp1\[0\]\[1\]\[1\] = 1; } for(int i = 0;i &lt; n-1;i++) for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(dp1\[i\]\[j\]\[k\] == 0)continue; if(str1\[i\] == &apos;0&apos;){ if(str2\[i+1\] == &apos;0&apos;){ if(j == 0){ if(k == 0)Add2(dp1\[i+1\]\[j\]\[k\],dp1\[i\]\[j\]\[k\]);//0-&gt;0 } else { if(k == 1)Add2(dp1\[i+1\]\[1\]\[k\],dp1\[i\]\[j\]\[k\]);//1-&gt;1 } } else if(str2\[i+1\] == &apos;1&apos;){ if(j == 0){ if(k == 1)Add2(dp1\[i+1\]\[1\]\[k\],dp1\[i\]\[j\]\[k\]);//1-&gt;1 } else { if(k == 0)Add2(dp1\[i+1\]\[j\]\[k\],dp1\[i\]\[j\]\[k\]);//0-&gt;0 } } else { if(k == 0)Add2(dp1\[i+1\]\[j\]\[k\],dp1\[i\]\[j\]\[k\]);//0-&gt;0 else Add2(dp1\[i+1\]\[1\]\[k\],dp1\[i\]\[j\]\[k\]);//1-&gt;1 } } else if(str1\[i\] == &apos;1&apos;){ if(str2\[i+1\] == &apos;0&apos;){ if(j == 0){ if(k == 1)Add2(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]);//1-&gt;0 } else{ if(k == 0)Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]);//0-&gt;1 } } else if(str2\[i+1\] == &apos;1&apos;){ if(j == 0){ if(k == 0)Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]);//0-&gt;1 } else{ if(k == 1)Add2(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]);//1-&gt;0 } } else { if(k == 1)Add2(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]);//1-&gt;0 else Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]);//0-&gt;1 } } else { if(str2\[i+1\] == &apos;0&apos;){ if(j == 0){ if(k == 0)Add2(dp1\[i+1\]\[j\]\[k\],dp1\[i\]\[j\]\[k\]); if(k == 1)Add2(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]); } else { if(k == 0)Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); if(k == 1)Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); } } else if(str2\[i+1\] == &apos;1&apos;){ if(j == 0){ if(k == 0)Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); if(k == 1)Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); } else { if(k == 0)Add2(dp1\[i+1\]\[j\]\[k\],dp1\[i\]\[j\]\[k\]); if(k == 1)Add2(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]); } } else { if(k == 0){ Add2(dp1\[i+1\]\[j\]\[0\],dp1\[i\]\[j\]\[k\]); Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); } else { Add2(dp1\[i+1\]\[1\]\[0\],dp1\[i\]\[j\]\[k\]); Add2(dp1\[i+1\]\[1\]\[1\],dp1\[i\]\[j\]\[k\]); } } } } ans1 = 0; tj = -1; tk = -1; for(int j = 0;j &lt; 2;j++) for(int k = 0;k &lt; 2;k++){ if(str1\[n-1\] == &apos;0&apos; &amp;&amp; k == 1)continue; if(str1\[n-1\] == &apos;1&apos; &amp;&amp; k == 0)continue; Add2(ans1,dp1\[n-1\]\[j\]\[k\]); } printf(&quot;AMBIGUOUS %d\\n&quot;,ans1); } return 0; }]]></content>
      <categories>
        <category>DP</category>
        <category>Online Judge</category>
        <category>ZJU</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4966 GGS-DDU （最小树形图）]]></title>
    <url>%2F2014%2F08%2F23%2Fhdu4966%2F</url>
    <content type="text"><![CDATA[HDU4966最小树形图， 模板题。 GGS-DDUTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 302 Accepted Submission(s): 156 Problem Description Do you think this is a strange problem name? That is because you don’t know its full name—‘Good Good Study and Day Day Up!”. Very famous sentence! Isn’t it? Now “GGS-DDU” is lzqxh’s target! He has N courses and every course is divided into a plurality of levels. Just like College English have Level 4 and Level 6. To simplify the problem, we suppose that the i-th course has Levels from level 0 to level a[i]. And at the beginning, lzqxh is at Level 0 of every course. Because his target is “GGS-DDU”, lzqxh wants to reach the highest Level of every course. Fortunately, there are M tutorial classes. The i-th tutoial class requires that students must reach at least Level L1[i] of course c[i] before class begins. And after finishing the i-th tutorial class, the students will reach Level L2[i] of course d[i]. The i-th tutoial class costs lzqxh money[i]. For example, there is a tutorial class only students who reach at least Level 5 of “Tiyu” can apply. And after finishing this class, the student’s “MeiShu” will reach Level 10 if his “MeiShu”‘s Level is lower than 10. (Don’t ask me why! Supernatural class!!!”) Now you task is to help lzqxh to compute the minimum cost! Input The input contains multiple test cases. The first line of each case consists of two integers, N (N&lt;=50) and M (M&lt;=2000). The following line contains N integers, representing a[1] to a[N]. The sum of a[1] to a[N] will not exceed 500. The next M lines, each have five integers, indicating c[i], L1[i], d[i], L2[i] and money[i] (1&lt;=c[i], d[i]&lt;=N, 0&lt;=L1[i]&lt;=a[c[i]], 0&lt;=L2[i]&lt;=a[d[i]], money[i]&lt;=1000) for the i-th tutorial class. The courses are numbered from 1 to N. The input is terminated by N = M = 0. Output Output the minimum cost for achieving lzqxh’s target in a line. If his target can’t be achieved, just output -1. Sample Input 3 4 3 3 1 1 0 2 3 10 2 1 1 2 10 1 2 3 1 10 3 1 1 3 10 0 0 Sample Output 40 Author SYSU Source 2014 Multi-University Training Contest 9 直接建图。套用最小树形图模板。 /* ***Author :kuangbinCreated Time :2014/8/19 13:01:24File Name :20140819\1007.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1010;const int MAXM = 400100; struct Edge{ int u,v,cost;};Edge edge[MAXM];int pre[MAXN],id[MAXN],visit[MAXN],in[MAXN];int gao(int root,int n,int m,Edge edge[]){ int res = 0,u,v; while(1) { for(int i = 0;i &lt; n;i++) in[i] = INF; for(int i = 0;i &lt; m;i++) if(edge[i].u != edge[i].v &amp;&amp; edge[i].cost &lt; in[edge[i].v]) { pre[edge[i].v] = edge[i].u; in[edge[i].v] = edge[i].cost; } for(int i = 0;i &lt; n;i++) if(i != root &amp;&amp; in[i] == INF) return -1; int tn = 0; memset(id,-1,sizeof(id)); memset(visit,-1,sizeof(visit)); in[root] = 0; for(int i = 0;i &lt; n;i++) { res += in[i]; v = i; while( visit[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root) { visit[v] = i; v = pre[v]; } if( v != root &amp;&amp; id[v] == -1 ) { for(int u = pre[v]; u != v ;u = pre[u]) id[u] = tn; id[v] = tn++; } } if(tn == 0)break; for(int i = 0;i &lt; n;i++) if(id[i] == -1) id[i] = tn++; for(int i = 0;i &lt; m;) { v = edge[i].v; edge[i].u = id[edge[i].u]; edge[i].v = id[edge[i].v]; if(edge[i].u != edge[i].v) edge[i++].cost -= in[v]; else swap(edge[i],edge[–m]); } n = tn; root = id[root]; } return res;}int g[MAXN][MAXN]; int a[100];int sum[100]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2 ){ if(n == 0 &amp;&amp; m == 0)break; sum[0] = 0; for(int i = 1;i &lt;= n;i++){ scanf(“%d”,&amp;a[i]); sum[i] = sum[i-1] + a[i]+1; } int start = sum[n]; int tot = sum[n] + 1; for(int i = 0;i &lt; tot;i++) for(int j = 0;j &lt; tot;j++) g[i][j] = INF; for(int i = 0;i &lt; n;i++) g[start][sum[i]] = 0; int c1,d1,l1,l2,mon; while(m–){ scanf(“%d%d%d%d%d”,&amp;c1,&amp;l1,&amp;d1,&amp;l2,&amp;mon); int u = sum[c1-1]+l1; int v = sum[d1-1]+l2; g[u][v] = min(g[u][v],mon); } for(int i = 1;i &lt;= n;i++){ for(int j = 1;j &lt;= a[i];j++) g[sum[i-1]+j][sum[i-1]+j-1] = 0; } int L = 0; for(int i = 0;i &lt; tot;i++) for(int j = 0;j &lt; tot;j++) if(g[i][j] &lt; INF){ edge[L].u = i; edge[L].v = j; edge[L++].cost = g[i][j]; } int ans = gao(start,tot,L,edge); printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>图论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
        <tag>最小树形图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4973 A simple simulation problem. （线段树）]]></title>
    <url>%2F2014%2F08%2F22%2Fhdu4973%2F</url>
    <content type="text"><![CDATA[HDU 4973 只需要使用线段树进行一些基本的区间操作就可以了。 很简单的题。 A simple simulation problem.Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 313 Accepted Submission(s): 128 Problem Description There are n types of cells in the lab, numbered from 1 to n. These cells are put in a queue, the i-th cell belongs to type i. Each time I can use mitogen to double the cells in the interval [l, r]. For instance, the original queue is {1 2 3 3 4 5}, after using a mitogen in the interval [2, 5] the queue will be {1 2 2 3 3 3 3 4 4 5}. After some operations this queue could become very long, and I can’t figure out maximum count of cells of same type. Could you help me? Input The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. For each case, the first line contains 2 integers (1 &lt;= n,m&lt;= 50000) indicating the number of cell types and the number of operations. For the following m lines, each line represents an operation. There are only two kinds of operations: Q and D. And the format is: “Q l r”, query the maximum number of cells of same type in the interval [l, r]; “D l r”, double the cells in the interval [l, r]; (0 &lt;= r – l &lt;= 10^8, 1 &lt;= l, r &lt;= the number of all the cells) Output For each case, output the case number as shown. Then for each query “Q l r”, print the maximum number of cells of same type in the interval [l, r]. Take the sample output for more details. Sample Input 1 5 5 D 5 5 Q 5 6 D 2 3 D 1 2 Q 1 7 Sample Output Case #1: 2 3 Source 2014 Multi-University Training Contest 10 代码： /* ***Author :kuangbinCreated Time :2014/8/21 13:16:18File Name :20140821\1003.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 50010;struct Node{ int l,r; long long Max; long long sum; long long lazy;}segTree[MAXN&lt;&lt;2];void push_up(int i){ if(segTree[i].l == segTree[i].r)return; segTree[i].sum = segTree[i&lt;&lt;1].sum + segTree[(i&lt;&lt;1)|1].sum; segTree[i].Max = max(segTree[i&lt;&lt;1].Max,segTree[(i&lt;&lt;1)|1].Max);}void push_down(int i){ if(segTree[i].l == segTree[i].r)return; if(segTree[i].lazy != 1){ segTree[i&lt;&lt;1].sum = segTree[i&lt;&lt;1].sumsegTree[i].lazy; segTree[i&lt;&lt;1].Max = segTree[i&lt;&lt;1].MaxsegTree[i].lazy; segTree[(i&lt;&lt;1)|1].sum = segTree[(i&lt;&lt;1)|1].sumsegTree[i].lazy; segTree[(i&lt;&lt;1)|1].Max = segTree[(i&lt;&lt;1)|1].MaxsegTree[i].lazy; segTree[i&lt;&lt;1].lazy = segTree[i].lazy; segTree[(i&lt;&lt;1)|1].lazy = segTree[i].lazy; segTree[i].lazy = 1; }}void build(int i,int l,int r){ segTree[i].l = l; segTree[i].r = r; segTree[i].lazy = 1; if(l == r){ segTree[i].sum = segTree[i].Max = 1; return; } int mid = (l+r)/2; build(i&lt;&lt;1,l,mid); build((i&lt;&lt;1)|1,mid+1,r); push_up(i);}void DOU(int i,int l,int r){ if(l &gt; r)return; if(segTree[i].l == l &amp;&amp; segTree[i].r == r){ segTree[i].sum = 2; segTree[i].Max = 2; segTree[i].lazy *= 2; return; } push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)DOU(i&lt;&lt;1,l,r); else if(l &gt; mid)DOU((i&lt;&lt;1)|1,l,r); else { DOU(i&lt;&lt;1,l,mid); DOU((i&lt;&lt;1)|1,mid+1,r); } push_up(i);}long long query_Max(int i,int l,int r){ if(l &gt; r)return 0; if(segTree[i].l == l &amp;&amp; segTree[i].r == r) return segTree[i].Max; push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)return query_Max(i&lt;&lt;1,l,r); else if(l &gt; mid)return query_Max((i&lt;&lt;1)|1,l,r); else return max(query_Max(i&lt;&lt;1,l,mid),query_Max((i&lt;&lt;1)|1,mid+1,r));}long long query_Sum(int i,int l,int r){ if(l &gt; r)return 0; if(segTree[i].l == l &amp;&amp; segTree[i].r == r) return segTree[i].sum; push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)return query_Sum(i&lt;&lt;1,l,r); else if(l &gt; mid)return query_Sum((i&lt;&lt;1)|1,l,r); else return query_Sum(i&lt;&lt;1,l,mid)+query_Sum((i&lt;&lt;1)|1,mid+1,r);}int get_id(long long k){ int i = 1; while(segTree[i].l != segTree[i].r){ push_down(i); if(segTree[i&lt;&lt;1].sum &gt;= k)i = i&lt;&lt;1; else { k -= segTree[i&lt;&lt;1].sum; i = (i&lt;&lt;1)|1; } } return segTree[i].l;}void ADD(int i,int id,long long val){ if(segTree[i].l == id &amp;&amp; segTree[i].r == id){ segTree[i].sum += val; segTree[i].Max += val; return; } push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(id &lt;= mid)ADD(i&lt;&lt;1,id,val); else ADD((i&lt;&lt;1)|1,id,val); push_up(i);}int n;void gao1(long long l,long long r){ int id1 = get_id(l); int id2 = get_id(r); if(id1 == id2){ ADD(1,id1,r-l+1); return; } ADD(1,id2,r-query_Sum(1,1,id2-1)); DOU(1,id1+1,id2-1); ADD(1,id1,query_Sum(1,1,id1)-l+1);}long long gao2(long long l,long long r){ int id1 = get_id(l); int id2 = get_id(r); if(id1 == id2){ return r-l+1; } long long ans = query_Max(1,id1+1,id2-1); ans = max(ans,query_Sum(1,1,id1)-l+1); ans = max(ans,r-query_Sum(1,1,id2-1)); return ans;} int main(){ //freopen(“1003.in”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; int m; scanf(“%d”,&amp;T); while(T–){ iCase++; printf(“Case #%d:\n”,iCase); scanf(“%d%d”,&amp;n,&amp;m); build(1,1,n); char op[10]; long long l,r; while(m–){ scanf(“%s%I64d%I64d”,op,&amp;l,&amp;r); if(op[0] == ‘D’)gao1(l,r); else printf(“%d\n”,(int)gao2(l,r)); } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>数据结构</category>
        <category>算法</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4979 A simple math problem. （Dancing Links）]]></title>
    <url>%2F2014%2F08%2F22%2Fhdu4979%2F</url>
    <content type="text"><![CDATA[HDU 4979 A simple math problem.Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 40 Accepted Submission(s): 9 Problem Description Dragon loves lottery, he will try his luck every week. One day, the lottery company brings out a new form of lottery called accumulated lottery. In a normal lottery, you pick 7 numbers from N numbers. You will get reward according to how many numbers you match. If you match all 7 numbers, you will get the top prize for 1 billion dollars!!! Unlike normal lottery, an M-accumulated lottery allows you to pick M numbers from N numbers. If M is big enough, this may significantly increase your possibility to win. (Of course it cost more…) Some people buy multiple accumulated lotteries to guarantee a higher possibility to get the top prize. Despite of this, it’s still not worthy to guarantee a top prize.Knowing this, Dragon changes his target to second tier prize. To get a second tier prize, you need to contain all of the R numbers with M numbers picked.Given N, M and R, Dragon wants to know how many M-accumulated lotteries he needs to buy, so that he can guarantee that he can get at least the second tier prize. Input The first line of input contains only one integer T, the number of test cases. For each case, there’s a single line contains N, M and R(1&lt;=R&lt;=M&lt;=N&lt;=8). Output Each output should occupy one line. Each line should start with “Case #i: “, with i implying the case number. For each case, just output the result with no other leading or tailing spaces. Sample Input 3 2 1 1 2 2 1 2 2 2 Sample Output Case #1: 2 Case #2: 1 Case #3: 1 Source 2014 Multi-University Training Contest 10 相等在 N个数的组合C(n,m) 中选择最少的个数，覆盖所有 C(n,k)的组合。可以用Dancing Links的可重复覆盖去搞。 这题比较恶心的就是要打表。 比赛的时候打表一直出不来 8 5 4 这组数据。 于是有了很多狂交80次来猜8 5 4 这个结果的故事。 除了8 5 4其余打表都很快的、。 8 5 4 好像要打好久。 8 5 4 结果其实是 20. AC程序： /* ***Author :kuangbinCreated Time :2014/8/21 17:10:33File Name :09_2.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int a[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,2,6,0,0,0,0,0,0,0,2,3,4,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,3,10,0,0,0,0,0,0,0,2,4,10,0,0,0,0,0,0,2,3,4,5,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,3,15,0,0,0,0,0,0,0,2,6,20,0,0,0,0,0,0,2,3,6,15,0,0,0,0,0,2,3,4,5,6,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,4,21,0,0,0,0,0,0,0,3,7,35,0,0,0,0,0,0,2,5,12,35,0,0,0,0,0,2,3,5,9,21,0,0,0,0,2,3,4,5,6,7,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,4,28,0,0,0,0,0,0,0,3,11,56,0,0,0,0,0,0,2,6,14,70,0,0,0,0,0,2,4,8,0,56,0,0,0,0,2,3,4,7,12,28,0,0,0,2,3,4,5,6,7,8,0,0,1,1,1,1,1,1,1,1, }; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; scanf(&quot;%d&quot;,&amp;T); while(T--){ iCase++; int n,m,r; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r); if(n == 8 &amp;&amp; m == 5 &amp;&amp; r == 4){ printf(&quot;Case #%d: 20\\n&quot;,iCase); continue; } printf(&quot;Case #%d: %d\\n&quot;,iCase,a\[n\*9\*9+m*9+r\]); } return 0; } 打表程序： /* ***Author :kuangbinCreated Time :2014/8/21 16:23:46File Name :09.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MaxM = 1515+10+1000;const int MaxN = 1515+10+1000;const int maxnode = MaxN * MaxM;const int INF = 0x3f3f3f3f;struct DLX{ int n,m,size; int U[maxnode],D[maxnode],R[maxnode],L[maxnode],Row[maxnode],Col[maxnode]; int H[MaxN],S[MaxM]; int ansd; void init(int _n,int _m) { n = _n; m = _m; for(int i = 0;i &lt;= m;i++) { S[i] = 0; U[i] = D[i] = i; L[i] = i-1; R[i] = i+1; } R[m] = 0; L[0] = m; size = m; for(int i = 1;i &lt;= n;i++)H[i] = -1; } void Link(int r,int c) { // printf(“%d %d\n”,r,c); ++S[Col[++size]=c]; Row[size] = r; D[size] = D[c]; U[D[c]] = size; U[size] = c; D[c] = size; if(H[r] &lt; 0)H[r] = L[size] = R[size] = size; else { R[size] = R[H[r]]; L[R[H[r]]] = size; L[size] = H[r]; R[H[r]] = size; } } void remove(int c) { for(int i = D[c];i != c;i = D[i]) L[R[i]] = L[i], R[L[i]] = R[i]; } void resume(int c) { for(int i = U[c];i != c;i = U[i]) L[R[i]] = R[L[i]] = i; } bool v[MaxM]; int f() { int ret = 0; for(int c = R[0]; c != 0;c = R[c])v[c] = true; for(int c = R[0]; c != 0;c = R[c]) if(v[c]) { ret++; v[c] = false; for(int i = D[c];i != c;i = D[i]) for(int j = R[i];j != i;j = R[j]) v[Col[j]] = false; } return ret; } void Dance(int d) { if(d + f() &gt;= ansd)return; if(R[0] == 0) { if(d &lt; ansd)ansd = d; return; } int c = R[0]; for(int i = R[0];i != 0;i = R[i]) if(S[i] &lt; S[c]) c = i; for(int i = D[c];i != c;i = D[i]) { remove(i); for(int j = R[i];j != i;j = R[j])remove(j); Dance(d+1); for(int j = L[i];j != i;j = L[j])resume(j); resume(i); } }};DLX g;int a[MaxN];int b[MaxM];long long C[20][20];void init2(){ C[0][0] = 1; for(int i = 1;i &lt; 20;i++){ C[i][0] = C[i][i] = 1; for(int j = 1;j &lt; i;j++) C[i][j] = C[i-1][j] + C[i-1][j-1]; }}int main(){ //freopen(“in.txt”,”r”,stdin); freopen(“out.txt”,”w”,stdout); init2(); int T; int n,m,r; int iCase = 0; scanf(“%d”,&amp;T); //while(T–){ for(n = 0;n &lt; 9;n++) for(m = 0;m &lt; 9;m++) for(r = 0;r &lt; 9;r++){ if(n == 0 || m == 0 || r == 0){ printf(&quot;0,&quot;); continue; } if( !(r &lt;= m &amp;&amp; m &lt;= n) ){ printf(&quot;0,&quot;); continue; } iCase++; // scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r); if(n == 8 &amp;&amp; m == 5 &amp;&amp; r == 4){ printf(&quot;0,&quot;); continue; } int cnt1 = 0; int cnt2 = 0; for(int i = 0;i &lt; (1&lt;&lt;n);i++){ int cc = 0; for(int j = 0;j &lt; n;j++) if(i&amp;(1&lt;&lt;j)) cc++; if(cc == m)a\[++cnt1\] = i; if(cc == r)b\[++cnt2\] = i; } g.init(cnt1,cnt2); for(int i = 1;i &lt;= cnt1;i++) for(int j = 1;j &lt;= cnt2;j++) if((a\[i\]|b\[j\]) == a\[i\]) g.Link(i,j); long long tmp = C\[n\]\[r\]; long long tmp2 = C\[m\]\[r\]; g.ansd = tmp; g.Dance(0); printf(&quot;%d,&quot;,g.ansd); //printf(&quot;Case #%d: %d\\n&quot;,iCase,g.ansd); } // } return 0;}]]></content>
      <categories>
        <category>Dancing Links</category>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>Dancing Links</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4975 A simple Gaussian elimination problem. （最大流+找环）]]></title>
    <url>%2F2014%2F08%2F22%2Fhdu4975%2F</url>
    <content type="text"><![CDATA[最大流+找环。HDU4975 题目很明显，就是求最大流，然后判断最大流是不是多解。 多解的判断，通过找环来确定。 A simple Gaussian elimination problem.Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 561 Accepted Submission(s): 185 Problem Description Dragon is studying math. One day, he drew a table with several rows and columns, randomly wrote numbers on each elements of the table. Then he counted the sum of each row and column. Since he thought the map will be useless after he got the sums, he destroyed the table after that.However Dragon’s mom came back and found what he had done. She would give dragon a feast if Dragon could reconstruct the table, otherwise keep Dragon hungry. Dragon is so young and so simple so that the original numbers in the table are one-digit number (e.g. 0-9). Could you help Dragon to do that? Input The first line of input contains only one integer, T(&lt;=30), the number of test cases. Following T blocks, each block describes one test case.There are three lines for each block. The first line contains two integers N(&lt;=500) and M(&lt;=500), showing the number of rows and columns. The second line contains N integer show the sum of each row. The third line contains M integer show the sum of each column. Output Each output should occupy one line. Each line should start with “Case #i: “, with i implying the case number. For each case, if we cannot get the original table, just output: “So naive!”, else if we can reconstruct the table by more than one ways, you should output one line contains only: “So young!”, otherwise (only one way to reconstruct the table) you should output: “So simple!”. Sample Input 3 1 1 5 5 2 2 0 10 0 10 2 2 2 2 2 2 Sample Output Case #1: So simple! Case #2: So naive! Case #3: So young! Source 2014 Multi-University Training Contest 10 但是找环。发现标程竟然是错的。 13 218931515 暴力搜找环会TLE。 这题可以和HDU 4888 互为参考下。 一种找环比较正确，而且快速的方法：和Tarjan的思路差不多。 就是从汇点开始去dfs, 记录哪些点是回不到end的。 然后就一遍dfs就可以解决了。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 2010;//点数的最大值const int MAXM = 1200010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge{ int to,next,cap,flow;}edge[MAXM];//注意是MAXMint tol;int head[MAXN];void init(){ tol = 2; memset(head,-1,sizeof(head));}void addedge(int u,int v,int w,int rw = 0){ edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;}int Q[MAXN];int dep[MAXN],cur[MAXN],sta[MAXN];bool bfs(int s,int t,int n){ int front = 0,tail = 0; memset(dep,-1,sizeof(dep[0])*(n+1)); dep[s] = 0; Q[tail++] = s; while(front &lt; tail){ int u = Q[front++]; for(int i = head[u]; i != -1;i = edge[i].next){ int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] == -1){ dep[v] = dep[u] + 1; if(v == t)return true; Q[tail++] = v; } } } return false;}int dinic(int s,int t,int n){ int maxflow = 0; while(bfs(s,t,n)){ for(int i = 0;i &lt; n;i++)cur[i] = head[i]; int u = s, tail = 0; while(cur[s] != -1){ if(u == t){ int tp = INF; for(int i = tail-1;i &gt;= 0;i–) tp = min(tp,edge[sta[i]].cap-edge[sta[i]].flow); maxflow += tp; for(int i = tail-1;i &gt;= 0;i–){ edge[sta[i]].flow += tp; edge[sta[i]^1].flow -= tp; if(edge[sta[i]].cap-edge[sta[i]].flow == 0) tail = i; } u = edge[sta[tail]^1].to; } else if(cur[u] != -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 == dep[edge[cur[u]].to]){ sta[tail++] = cur[u]; u = edge[cur[u]].to; } else { while(u != s &amp;&amp; cur[u] == -1) u = edge[sta[–tail]^1].to; cur[u] = edge[cur[u]].next; } } } return maxflow;}int a[510];int b[510];int id[510][510]; bool vis[MAXN],no[MAXN];int Stack[MAXN],top; bool dfs(int u,int pre,bool flag){ vis[u] = 1; Stack[top++] = u; for(int i = head[u];i != -1;i = edge[i].next) { int v = edge[i].to; if(edge[i].cap &lt;= edge[i].flow)continue; if(v == pre)continue; if(!vis[v]){ if(dfs(v,u,edge[i^1].flow &lt; edge[i^1].cap))return true; } else if(!no[v])return true; } if(!flag){ while(1){ int v = Stack[–top]; no[v] = true; if(v == u)break; } } return false;}int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m,K; int T; int iCase = 0; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d”,&amp;n,&amp;m); K = 9; init(); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) { id[i][j] = tol; addedge(i,j+n,K); } int sum1 = 0; for(int i = 1;i &lt;= n;i++) { scanf(“%d”,&amp;a[i]); sum1 += a[i]; addedge(0,i,a[i]); } int sum2 = 0; for(int i = 1;i &lt;= m;i++) { scanf(“%d”,&amp;b[i]); sum2 += b[i]; addedge(i+n,n+m+1,b[i]); } iCase++; printf(“Case #%d: “,iCase); if(sum1 != sum2) { printf(“So naive!\n”); continue; } int tmp = dinic(0,n+m+1,n+m+2); //printf(“maxflow : %d\n”,tmp); if(tmp != sum1) { printf(“So naive!\n”); continue; } memset(vis,false,sizeof(vis)); memset(no,false,sizeof(no)); top = 0; bool flag = dfs(n+m+1,n+m+1,0); if(flag) { printf(“So young!\n”); continue; } printf(“So simple!\n”); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>图论</category>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假の小结]]></title>
    <url>%2F2014%2F08%2F21%2F2014summer%2F</url>
    <content type="text"><![CDATA[7月、8月转瞬即逝。 缅怀逝去的时光，总结开启新的挑战。 慢慢地已经没有暑假的概念了。 每年都会回忆起过去的暑假自己在干嘛。两个月貌似什么事情都没有做成，每天都感觉匆匆而过。7月：前期主要在实验室里面，写了一篇论文，请老师改了几遍，然后改了又改投出去了，现在等结果中。然后期间水了一发上海的邀请赛，因为题目太逗，不能多说。之后中间的一段时间主要在刷题学算法，搞了几套区域赛的题目，感觉收获不小，把一些算法自己深入理解了一下。然后7月底去北京参加百度之星，仰慕群神，纯粹旅游了一发。8月：主要都是在刷题，做多校，总结多校题。说起多校，总会想起为何自己这么弱，屡屡被虐！ 通过多校暴露出了很多问题，很多题做不出来完全自己习惯不好！以后写题前一定先想清楚，把样例先模拟一遍再搞，否则会感觉自己阵脚大乱。有一次WA多次一直搞不出来，最后竟然发现题目编号从0开始，我写的从1开始，都是因为没有认真去模拟一遍样例。 此外提前算好复杂度，以前计算复杂度总忽略数据组数，后来很多时候发现很危险。很大的一个问题就是心态了，开局不顺的话，后面整场都废了，会导致后面全局都乱了。 WA和TLE以后首先要保证不乱，好好找原因。 卡题切记要换题AC。自己的状态起伏很大，感觉越来越不在状态了。很多时候自己无法静下心来好好想题，对外界干扰太大。 归根结底，还是自己太弱，早就应该退役去了！8月时候开始考驾照了，把科目一考完了，后面时间都要开始学车了，时间越来越紧张。期间，百度打电话来提供机会让我去实习，后面自己思考再三，还是拒绝了。 主要考虑到后面的半年时间太紧张，还有太多的时间要做。九月将有网络赛，十月要有区域赛，虽然感觉这些都和自己关系不大了，但是自己还是要认真做好该做的事情。 这是第四个暑假在准备ACM了，今年做的题明显没有以前多。 接触ACM已经三年半了，但是感觉什么都不会的状态。 今年两场区域赛结束也算彻底退役了，虽然自己是个早就应该退役的人了。 本来自己很注重团队的训练， 花了很多时间去练习限时组队训练， 后来岐哥教训的非常有道理，只有个人强了，团队才能强。 自己都还这么弱的时候，只能先管好自己。 ACM竞赛涉及内容确实太多，一个人想面面俱到确实花费时间太多了，三个人如果像一块拼图，可以完美覆盖当然是比较理想的。 后来想想自己还是不能去奢望队友可以去弥补你不会的，毕竟你自己都不会，怎么能要求别人弥补你的空缺呢。 慢慢也就淡定了， 很多东西不会就不会吧，学到一点会一点就足够了。接下来，先花点时间把自己的模板好好重构好，作为区域赛的参考吧！ 也将会是更新的最后一份模板了。然后要把一些事情好好理一理了，前面弄得太混乱。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3572: [Hnoi2014]世界树 （虚树，DP）]]></title>
    <url>%2F2014%2F08%2F19%2Fbzoj3572%2F</url>
    <content type="text"><![CDATA[BZOJ 3572 题意：一颗树，给了一些指定的点，树上的点离那个给点的点近就属于哪个点，距离相等属于编号小的。 问每个给定的点可以管辖多少个点。 参考链接：http://user.qzone.qq.com/251815992/blog/1407315782 http://lazycal.logdown.com/posts/202331-bzoj3572 虚树：包含了给定点，并收缩了不分叉边的连通子图。 3572: [Hnoi2014]世界树Time Limit: 20 Sec Memory Limit: 512 MB Submit: 226 Solved: 145 [Submit][Status] Description 世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。 世界树的形态可以用一个数学模型来描述：世界树中有n个种族，种族的编号分别从1到n，分别生活在编号为1到n的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为1。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地a和b之间有道路，b和c之间有道路，因为每条道路长度为1而且又不可能出现环，所卧a与c之间的距离为2。 出于对公平的考虑，第i年，世界树的国王需要授权m[i]个种族的聚居地为临时议事处。对于某个种族x（x为种族的编号），如果距离该种族最近的临时议事处为y（y为议事处所在聚居地的编号），则种族x将接受y议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则y为其中编号最小的临时议事处）。 现在国王想知道，在q年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。 Input第一行为一个正整数n，表示世界树中种族的个数。 接下来n-l行，每行两个正整数x，y，表示x聚居地与y聚居地之间有一条长度为1的双 向道路。接下来一行为一个正整数q，表示国王询问的年数。 接下来q块，每块两行： 第i块的第一行为1个正整数m[i]，表示第i年授权的临时议事处的个数。 第i块的第二行为m[i]个正整数h[l]、h[2]、…、h[m[i]]，表示被授权为临时议事处的聚居地编号（保证互不相同）。 Output输出包含q行，第i行为m\[i\]个整数，该行的第j(j=1，2…，，m\[i\])个数表示第i年被授权的聚居地h\[j\]的临时议事处管理的种族个数。 Sample Input10 21 32 43 54 61 73 83 94 10 1 5 2 61 5 27369 1 8 4 87103 5 29358 Sample Output19 31411 10 1135 41311 HINT N&lt;=300000, q&lt;=300000,m[1]+m[2]+…+m[q]&lt;=300000 Source这题可谓当年2013changchun区域赛的J题的加强版。 虚树上进行DP的方法非常经典。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365/* ***************Author :kuangbinCreated Time :2014/8/18 19:55:13File Name :E:\2014ACM\BZOJ\bzoj3572.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 300010;const int DEG = 20;struct Edge&#123; int to,next;&#125;edge[MAXN*2];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int fa[MAXN][DEG];int deg[MAXN];void BFS(int root)&#123; queue&lt;int&gt;q; deg[root] = 0; fa[root][0] = root; q.push(root); while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = 1;i &lt; DEG;i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[u][0])continue; deg[v] = deg[u] + 1; fa[v][0] = u; q.push(v); &#125; &#125;&#125;int LCA(int u,int v)&#123; if(deg[u] &gt; deg[v])swap(u,v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for(int det = hv-hu, i = 0; det;det&gt;&gt;=1,i++) if(det&amp;1) tv = fa[tv][i]; if(tu == tv)return tu; for(int i = DEG-1;i &gt;= 0;i--)&#123; if(fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int DFN[MAXN],Index;int size[MAXN];void dfs(int u)&#123; DFN[u] = ++Index; size[u] = 1; for(int i = head[u];i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(v == fa[u][0])continue; dfs(v); size[u] += size[v]; &#125;&#125;int find(int u,int d)&#123;//找到u往上的祖先中深度为d的点 for(int i = DEG-1;i &gt;= 0;i--) if(deg[fa[u][i]] &gt;= d) u = fa[u][i]; return u;&#125;int h[MAXN],th[MAXN];int st[MAXN],father[MAXN];int t[MAXN],val[MAXN];int ans[MAXN],w[MAXN];pair&lt;int,int&gt;g[MAXN];bool cmp(int i,int j)&#123; return DFN[i] &lt; DFN[j];&#125;void solve(int n)&#123; int m; int tot = 0; scanf("%d",&amp;m); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d",&amp;h[i]); th[i] = h[i];//备份 t[++tot] = h[i]; g[h[i]] = make_pair(0,h[i]); ans[h[i]] = 0; &#125; sort(h+1,h+m+1,cmp); int top = 0; for(int i = 1;i &lt;= m;i++)&#123; if(!top)father[st[++top] = h[i]] = 0; else &#123; int p = h[i], lca = LCA(h[i],st[top]); for(;deg[st[top]] &gt; deg[lca];--top) if(deg[st[top-1]] &lt;= deg[lca]) father[st[top]] = lca; if(st[top] != lca)&#123; t[++tot] = lca; g[lca] = make_pair(0x3f3f3f3f,0); father[lca] = st[top]; st[++top] = lca; &#125; father[p] = lca; st[++top] = p; &#125; &#125; sort(t+1,t+tot+1,cmp); for(int i = 1;i &lt;= tot;i++)&#123; int p = t[i]; val[p] = size[p]; if(i &gt; 1)w[p] = deg[p] - deg[father[p]]; &#125; for(int i = tot;i &gt; 1;i--)&#123; int p = t[i]; g[father[p]] = min(g[father[p]],make_pair(g[p].first+w[p],g[p].second)); &#125; for(int i = 2;i &lt;= tot;i++)&#123; int p = t[i]; g[p] = min(g[p],make_pair(g[father[p]].first+w[p],g[father[p]].second)); &#125; for(int i = 1;i &lt;= tot;i++)&#123; int p = t[i], f = father[p]; if(i == 1)ans[g[p].second] += n-size[p]; else &#123; int x = find(p,deg[f]+1), sum = size[x]-size[p]; val[f] -= size[x]; if(g[f].second == g[p].second)ans[g[p].second] += sum; else &#123; int mid = deg[p] - ((g[f].first + g[p].first + w[p])/2 - g[p].first); if((g[f].first + g[p].first + w[p])%2 == 0 &amp;&amp; g[p].second &gt; g[f].second)++mid; int y = size[find(p,mid)] - size[p]; ans[g[p].second] += y; ans[g[f].second] += sum-y; &#125; &#125; &#125; for(int i = 1;i &lt;= tot;i++) ans[g[t[i]].second] += val[t[i]]; for(int i = 1;i &lt;= m;i++)&#123; printf("%d ",ans[th[i]]); &#125; printf("\n");&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1)&#123; init(); int u,v; for(int i = 1;i &lt; n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; BFS(1); Index = 0; dfs(1); int Q; scanf("%d",&amp;Q); while(Q--)solve(n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4927 Series 1 （大数）]]></title>
    <url>%2F2014%2F08%2F07%2Fhdu4927%2F</url>
    <content type="text"><![CDATA[HDU 4927Series 1很简单，首先要推一下公式。 最终答案就是 a\[n\] * C(n-1,n-1) - a\[n-1\] * C\[n-1,n-2\] + a\[n-2\]\*C\[n-1,n-3\] - .................. a\[1\]\*C\[n-1,0\] 这个搞。 主要是奉献一发高精度模板。 /* ***Author :kuangbinCreated Time :2014/8/7 20:16:53File Name :E:\2014ACM\比赛\2014多校训练\2014多校6\HDU4927.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; /* * 完全大数模板 * 输出cin&gt;&gt;a * 输出a.print(); * 注意这个输入不能自动去掉前导0的，可以先读入到char数组，去掉前导0，再用构造函数。 */ #define MAXN 9999 #define MAXSIZE 1010 #define DLEN 4 class BigNum{private: int a[1000]; //可以控制大数的位数 int len;public: BigNum(){len=1;memset(a,0,sizeof(a));} //构造函数 BigNum(const int); //将一个int类型的变量转化成大数 BigNum(const char*); //将一个字符串类型的变量转化为大数 BigNum(const BigNum &amp;); //拷贝构造函数 BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream&amp; operator&gt;&gt;(istream&amp;,BigNum&amp;); //重载输入运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp;,BigNum&amp;); //重载输出运算符 BigNum operator+(const BigNum &amp;)const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum &amp;)const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum &amp;)const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int &amp;)const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int &amp;)const; //大数的n次方运算 int operator%(const int &amp;)const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum &amp;T)const; //大数和另一个大数的大小比较 bool operator&gt;(const int &amp;t)const; //大数和一个int类型的变量的大小比较 void print(); //输出大数 };BigNum::BigNum(const int b) //将一个int类型的变量转化为大数{ int c,d=b; len=0; memset(a,0,sizeof(a)); while(d&gt;MAXN) { c=d-(d/(MAXN+1))(MAXN+1); d=d/(MAXN+1); a[len++]=c; } a[len++]=d;}BigNum::BigNum(const char s) //将一个字符串类型的变量转化为大数{ int t,k,index,L,i; memset(a,0,sizeof(a)); L=strlen(s); len=L/DLEN; if(L%DLEN)len++; index=0; for(i=L-1;i&gt;=0;i-=DLEN) { t=0; k=i-DLEN+1; if(k&lt;0)k=0; for(int j=k;j&lt;=i;j++) t=t10+s[j]-‘0’; a[index++]=t; }}BigNum::BigNum(const BigNum &amp;T):len(T.len) //拷贝构造函数{ int i; memset(a,0,sizeof(a)); for(i=0;i&lt;len;i++) a[i]=T.a[i];}BigNum &amp; BigNum::operator=(const BigNum &amp;n) //重载赋值运算符，大数之间赋值运算{ int i; len=n.len; memset(a,0,sizeof(a)); for(i=0;i&lt;len;i++) a[i]=n.a[i]; return this;}istream&amp; operator&gt;&gt;(istream &amp;in,BigNum &amp;b){ char ch[MAXSIZE4]; int i=-1; in&gt;&gt;ch; int L=strlen(ch); int count=0,sum=0; for(i=L-1;i&gt;=0;) { sum=0; int t=1; for(int j=0;j&lt;4&amp;&amp;i&gt;=0;j++,i–,t=10) { sum+=(ch[i]-‘0’)t; } b.a[count]=sum; count++; } b.len=count++; return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out,BigNum&amp; b) //重载输出运算符{ int i; cout&lt;&lt;b.a[b.len-1]; for(i=b.len-2;i&gt;=0;i–) { printf(“%04d”,b.a[i]); } return out;}BigNum BigNum::operator+(const BigNum &amp;T)const //两个大数之间的相加运算{ BigNum t(this); int i,big; big=T.len&gt;len?T.len:len; for(i=0;i&lt;big;i++) { t.a[i]+=T.a[i]; if(t.a[i]&gt;MAXN) { t.a[i+1]++; t.a[i]-=MAXN+1; } } if(t.a[big]!=0) t.len=big+1; else t.len=big; return t;}BigNum BigNum::operator-(const BigNum &amp;T)const //两个大数之间的相减运算{ int i,j,big; bool flag; BigNum t1,t2; if(this&gt;T) { t1=this; t2=T; flag=0; } else { t1=T; t2=this; flag=1; } big=t1.len; for(i=0;i&lt;big;i++) { if(t1.a[i]&lt;t2.a[i]) { j=i+1; while(t1.a[j]==0) j++; t1.a[j–]–; while(j&gt;i) t1.a[j–]+=MAXN; t1.a[i]+=MAXN+1-t2.a[i]; } else t1.a[i]-=t2.a[i]; } t1.len=big; while(t1.a[t1.len-1]==0 &amp;&amp; t1.len&gt;1) { t1.len–; big–; } if(flag) t1.a[big-1]=0-t1.a[big-1]; return t1;}BigNum BigNum::operator(const BigNum &amp;T)const //两个大数之间的相乘{ BigNum ret; int i,j,up; int temp,temp1; for(i=0;i&lt;len;i++) { up=0; for(j=0;j&lt;T.len;j++) { temp=a[i]T.a[j]+ret.a[i+j]+up; if(temp&gt;MAXN) { temp1=temp-temp/(MAXN+1)(MAXN+1); up=temp/(MAXN+1); ret.a[i+j]=temp1; } else { up=0; ret.a[i+j]=temp; } } if(up!=0) ret.a[i+j]=up; } ret.len=i+j; while(ret.a[ret.len-1]==0 &amp;&amp; ret.len&gt;1)ret.len–; return ret;}BigNum BigNum::operator/(const int &amp;b)const //大数对一个整数进行相除运算{ BigNum ret; int i,down=0; for(i=len-1;i&gt;=0;i–) { ret.a[i]=(a[i]+down(MAXN+1))/b; down=a[i]+down(MAXN+1)-ret.a[i]b; } ret.len=len; while(ret.a[ret.len-1]==0 &amp;&amp; ret.len&gt;1) ret.len–; return ret;}int BigNum::operator%(const int &amp;b)const //大数对一个 int类型的变量进行取模{ int i,d=0; for(i=len-1;i&gt;=0;i–) d=((d(MAXN+1))%b+a[i])%b; return d;}BigNum BigNum::operator^(const int &amp;n)const //大数的n次方运算{ BigNum t,ret(1); int i; if(n&lt;0)exit(-1); if(n==0)return 1; if(n==1)return this; int m=n; while(m&gt;1) { t=this; for(i=1;(i&lt;&lt;1)&lt;=m;i&lt;&lt;=1) t=tt; m-=i; ret=rett; if(m==1)ret=ret(this); } return ret;}bool BigNum::operator&gt;(const BigNum &amp;T)const //大数和另一个大数的大小比较{ int ln; if(len&gt;T.len)return true; else if(len==T.len) { ln=len-1; while(a[ln]==T.a[ln]&amp;&amp;ln&gt;=0) ln–; if(ln&gt;=0 &amp;&amp; a[ln]&gt;T.a[ln]) return true; else return false; } else return false;}bool BigNum::operator&gt;(const int &amp;t)const //大数和一个int类型的变量的大小比较{ BigNum b(t); return *this&gt;b;}void BigNum::print() //输出大数{ int i; printf(“%d”,a[len-1]); for(i=len-2;i&gt;=0;i–) printf(“%04d”,a[i]); printf(“\n”);} int a[3010];BigNum C[3010]; int main(){ //freopen(“1007.in”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); int n; while(T–) { scanf(“%d”,&amp;n); for(int i = 0;i &lt; n;i++) scanf(“%d”,&amp;a[i]); C[0] = 1; for(int i = 1;i &lt; n;i++) C[i] = C[i-1](n-1-i+1)/i; BigNum ans1 = 0; BigNum ans2 = 0; for(int i = 0;i &lt; n;i++) { if((n-i)&amp;1)ans1 = ans1 + (C[i]a[i]); else ans2 = ans2 + (C[i]*a[i]); } (ans1-ans2).print(); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4921 Map （水题）]]></title>
    <url>%2F2014%2F08%2F07%2Fhdu4921%2F</url>
    <content type="text"><![CDATA[HDU 4921MapMapTime Limit: 3000/1500 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others) Total Submission(s): 92 Accepted Submission(s): 19 Problem Description There are N pieces of fragments, and we’re going to select some of them to form a map. Some fragments can be selected into the map directly (named 1-level fragments), while each of the rest follows exactly one fragment as its prior fragment. If B follows A and A is an i-level fragment, then B is defined as an (i + 1) - level fragment, and B can be selected only if A has been selected before. Besides, a fragment is followed by at most one other fragment. Each fragment is assigned with a reliability. The reliability of the whole map is sum up by two parts: 1.The sum of reliabilities of all selected fragments; 2.If there are xi i-level fragments in total and we select yi(yi > 1) fragments among them to form the map, the reliability would increase by ,where Sidenotes the sum of reliabilities of selected fragments in level i. Please figure out the expectation of reliability of the map under the condition that all valid selections are equiprobable. At least one fragment should be selected. Input There are several test cases. The number of test cases T (T&lt;=10) occurs in the first line of input. For each test case: The first line consists of two integers N, M (1&lt;=N&lt;=10000,0&lt;=M&lt;N), indicating the number of fragments and relationships respectively. The second line contains N integers, which describes the reliability of each fragment. The given reliability ranges from 1 to 100, inclusive. Each of the following M lines contains two integers A and B, which denotes B follows A(0&lt;=A,B&lt;=N-1). You may assume that the number of 1-level fragments are no more than 10, and levels will not exceed 1000. No fragment will follow itself directly or indirectly. Output For each test case, output the expectation with 3 decimal places. Sample Input 2 2 0 1 2 3 1 1 2 4 1 2 Sample Output 3.000 5.000 Hint In the first sample, there’re three ways of selections: {0,1}, {0},{1},which respectively generates 6, 1 and 2 of reliability. Hence, the expectation is 3. Source 2014 Multi-University Training Contest 6 大水题一个。 就按照题目说的就是暴力。 卧槽，做的时候没有看到下标从0开始的，一直搞不出来第二个样例，然后WA无数次。 一直没发现问题。 经岐哥提醒是下标从0开始的，然后秒过啊。 sad, 最近这状态是有多差啊，题都做不出来了。 按照题目意思是形成很多条链。 链最多是10条，深度最多1000. 直接暴力。 首先先求出总数，假设有k个链，每条链深度是 num\[k\]. 那么总数就是 num\[1\]\*num\[2\]\*........num\[k\] - 1了。 先累加第一种和。 只需要扫一遍每条链。 其实就是找出每个点出现的次数，是很好求的。 第二种也是很好求的，直接枚举，二进制去枚举2^k复杂度。 就是按照深度去找，枚举每个深度有几个是达到这个深度的，当然有的是达不到这个深度的。 #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std;const int MAXN = 100010;int to[MAXN];int rto[MAXN];bool f[MAXN]; int a[MAXN];int num[MAXN];int b[MAXN];int dep[MAXN];int two[20]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,m; scanf(“%d”,&amp;T); two[0] = 1; for(int i = 1;i &lt; 20;i++) two[i] = 2two[i-1]; while(T–) { scanf(“%d%d”,&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf(“%d”,&amp;a[i]); for(int i = 1;i &lt;= n;i++) { f[i] = true; num[i] = 0; to[i] = -1; rto[i] = -1; } int u,v; while(m–) { scanf(“%d%d”,&amp;u,&amp;v); u++; v++; to[u] = v; rto[v] = u; f[v] = false; } for(int i = 1;i &lt;= n;i++) if(to[i] == -1) { u = i; num[u] = 1; while(rto[u] != -1) { num[rto[u]] = num[u]+1; u = rto[u]; } } double tot = 1; for(int i = 1;i &lt;= n;i++) if(f[i]) tot = (num[i]+1); double ans = 0; int cc = 0; for(int i = 1;i &lt;= n;i++) if(f[i]) b[cc++] = i; for(int i = 0;i &lt; cc;i++) { u = b[i]; dep[u] = 1; double tt = 1.0/(num[u]+1); double s = 0; while(1) { s += a[u]; ans += s*tt*(tot/(tot-1));//累加第一种 if(to[u] == -1)break; dep[to[u]] = dep[u] + 1; num[to[u]] = num[u]; u = to[u]; } } int MD = 0;//最大深度 for(int i = 1;i &lt;= n;i++) MD = max(MD,dep[i]); for(int d = 1;d &lt;= MD;d++) { for(int i = 1;i &lt; two[cc];i++) { bool flag = true; double tt = 1; int cnt = 0; double ss = 0; for(int j = 0;j &lt; cc;j++) if(i &amp; two[j]) { cnt++; ss += a[b[j]]; if(dep[b[j]] != d) { flag = false; break; } tt = (num[b[j]]-d+1); } else { if(dep[b[j]] == d)tt = (dep[b[j]]); else tt = (dep[b[j]]+1); } int cnt2 = 0; for(int j = 0;j &lt; cc;j++) if(dep[b[j]] == d) cnt2++; if(!flag)continue; if(cnt &gt; 1)ans += ss\cnt/cnt2*(tt/(tot-1));//累加第二种 } for(int i = 0;i &lt; cc;i++) if( to[b[i]] != -1) b[i] = to[b[i]]; } printf(“%.3lf\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4912 Paths on the tree （LCA+贪心）]]></title>
    <url>%2F2014%2F08%2F05%2Fhdu4912%2F</url>
    <content type="text"><![CDATA[HDU 4912Paths on the treePaths on the treeTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 80 Accepted Submission(s): 25 Problem Description bobo has a tree, whose vertices are conveniently labeled by 1,2,…,n. There are m paths on the tree. bobo would like to pick some paths while any two paths do not share common vertices. Find the maximum number of paths bobo can pick. Input The input consists of several tests. For each tests: The first line contains n,m (1≤n,m≤105). Each of the following (n - 1) lines contain 2 integers ai,bi denoting an edge between vertices ai and bi (1≤ai,bi≤n). Each of the following m lines contain 2 integers ui,vi denoting a path between vertices ui and vi (1≤ui,vi≤n). Output For each tests: A single integer, the maximum number of paths. Sample Input 3 2 1 2 1 3 1 2 1 3 7 3 1 2 1 3 2 4 2 5 3 6 3 7 2 3 4 5 6 7 Sample Output 1 2 Author Xiaoxu Guo (ftiasch) Source 2014 Multi-University Training Contest 5 随便选择一个根。变成有根树。 然后每个路径，u - v 找出u - v的LCA。根据所有路径的LCA的深度进行选择。 每选择一个路径以后，把LCA下面的子树都进行标记。 如果u,v没有被标记，这个路径是可以的。 贪心的正确性很容易想明白。 /* ***Author :kuangbinCreated Time :2014/8/5 19:37:30File Name :E:\2014ACM\比赛\2014多校训练\2014多校5\HDU4912.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int DEG = 20;struct Edge{ int to,next;}edge[MAXN*2];int head[MAXN],tot;void init(){ tot = 0; memset(head,-1,sizeof(head));}void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}int fa[MAXN][DEG];int deg[MAXN];void BFS(int root){ queueq; deg[root] = 0; fa[root][0] = root; q.push(root); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = 1;i &lt; DEG;i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for(int i = head[u];i != -1;i = edge[i].next) { int v = edge[i].to; if(v == fa[u][0])continue; deg[v] = deg[u] + 1; fa[v][0] = u; q.push(v); } }}int LCA(int u,int v){ if(deg[u] &gt; deg[v])swap(u,v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for(int det = hv-hu,i=0;det;det&gt;&gt;=1,i++) if(det&amp;1) tv = fa[tv][i]; if(tu == tv)return tu; for(int i = DEG-1;i &gt;= 0;i–) { if(fa[tu][i] == fa[tv][i])continue; tu = fa[tu][i]; tv = fa[tv][i]; } return fa[tu][0];}bool vis[MAXN];void gao(int u){ if(vis[u])return; vis[u] = true; for(int i = head[u];i != -1;i = edge[i].next) { int v = edge[i].to; if(v == fa[u][0])continue; gao(v); }}struct Node{ int u,v; int lca;}node[MAXN];bool cmp(Node a,Node b){ return deg[a.lca] &gt; deg[b.lca];} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2) { init(); int u,v; for(int i = 1;i &lt; n;i++) { scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } BFS(1); for(int i = 0;i &lt; m;i++) { scanf(“%d%d”,&amp;node[i].u,&amp;node[i].v); if(deg[node[i].u] &gt; deg[node[i].v]) swap(node[i].u,node[i].v); node[i].lca = LCA(node[i].u,node[i].v); } sort(node,node+m,cmp); int ans = 0; memset(vis,false,sizeof(vis)); for(int i = 0;i &lt; m;i++) { if(vis[node[i].u] || vis[node[i].v])continue; ans++; gao(node[i].lca); } printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>图论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4913 Least common multiple （线段树）]]></title>
    <url>%2F2014%2F08%2F05%2Fhdu4913%2F</url>
    <content type="text"><![CDATA[HDU 4913Least common multipleLeast common multipleTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 61 Accepted Submission(s): 17 Problem Description bobo has an integer set S={x1,x2,…,xn}, where xi=2ai * 3bi.For each non-empty subsets of S, bobo added the LCM (least common multiple) of the subset up. Find the sum of LCM modulo (109+7). Input The input consists of several tests. For each tests:The first line contains n (1≤n≤105). Each of the following n lines contain 2 integers ai,bi (0≤ai,bi≤109). Output For each tests:A single integer, the value of the sum. Sample Input 2 0 1 1 0 3 1 2 2 1 1 2 Sample Output 11 174 Author Xiaoxu Guo (ftiasch) Source 2014 Multi-University Training Contest 5 题意很清楚，也很容易理解。LCM一定是2^i 3^j 的形式。这题的关键是转化的过程，将问题转化为线段树解决。 最近状态真是差，写个线段树卡半天，写个几何也RE到现在。 早日退役保平安。 最简单的思路就是 就是假如要求LCM等于 2^a*3^b 的，假如需要求LCM为2^a*3^b 的有多少个，肯定是先找出LCM的2次数&lt;=a,3次数&lt;=b的， 然后减掉LCM比这个值小的。 我的做法就是把这些数先按照a从小到大，再按照b从小到大排序。 然后for一遍。枚举到i的时候， 比如第i个数是 \( 2^{a_i}*3^{b_i} \) 那么前面插入的数，2的指数是小于等于 \( a_i \)的。 这个时候先统计再前i 个数里面，包含了第i个数的子集对应的答案。 既然包含了\(2^{a_i}\) 那么LCM一定是包含\( 2^{a_i} \)的。 这样求和的话，其实是可以把这一项提取出来的。 假如在3的指数里面，&lt;=j的数有num[j]个。那么需要累加的就是 \[2^{a_i}*3^{j}(2^{num[j]}-2^{num[j-1]}) \] 当然可以先把3的指数离散化一下，然后使用线段树进行维护。 需要的操作就是单点加值，区间乘以2，区间求和。 维护的就是 \( 3^{j} (2^{num[j]} - 2^{num[j-1]}) \) 当然还有一些细节，比如查询哪个区间，修改哪个区间啥的。 具体看代码吧。 /* ***Author :kuangbinCreated Time :2014/8/5 19:08:16File Name :E:\2014ACM\比赛\2014多校训练\2014多校5\HDU4913.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;const int MAXN = 100010;struct Node{ int x,y; void input() { scanf(“%d%d”,&amp;x,&amp;y); }}node[MAXN];bool cmp(Node a,Node b){ if(a.x != b.x)return a.x &lt; b.x; else return a.y &lt; b.y;}int tot;int c[MAXN];int lowbit(int x){ return x&amp;(-x);}void add(int i,int val){ while(i &lt;= tot) { c[i] += val; i += lowbit(i); }}int sum(int i){ int s = 0; while(i) { s += c[i]; i -= lowbit(i); } return s;} int b[MAXN]; long long pow_m(long long a,long long n){ long long ret = 1; long long tmp = a; while(n) { if(n&amp;1)ret = rettmp%MOD; tmp = tmptmp%MOD; n &gt;&gt;= 1; } return ret;} struct SEGNODE{ int l,r; int val; long long sum; long long lazy;}segTree[MAXN&lt;&lt;2];void push_up(int i){ segTree[i].sum = segTree[i&lt;&lt;1].sum + segTree[(i&lt;&lt;1)|1].sum; if(segTree[i].sum &gt;= MOD)segTree[i].sum -= MOD;}void Update(int i,int k ){ segTree[i].sum = segTree[i].sumk%MOD; segTree[i].lazy = segTree[i].lazyk%MOD;}void push_down(int i){ if(segTree[i].lazy != 1) { Update(i&lt;&lt;1,segTree[i].lazy); Update((i&lt;&lt;1)|1,segTree[i].lazy); segTree[i].lazy = 1; }}void build(int i,int l,int r){ segTree[i].l = l; segTree[i].r = r; segTree[i].sum = 0; segTree[i].lazy = 1; if(l == r) { segTree[i].val = pow_m(3,b[l]); return; } int mid = (l+r)/2; build(i&lt;&lt;1,l,mid); build((i&lt;&lt;1)|1,mid+1,r);}void ADD(int i,int k){ if(segTree[i].l == k &amp;&amp; segTree[i].r == k) { int tmp = sum(k); segTree[i].sum += pow_m(2,tmp)*segTree[i].val%MOD; if(segTree[i].sum &gt;= MOD)segTree[i].sum-=MOD; add(k,1); return; } int mid = (segTree[i].l + segTree[i].r)/2; push_down(i); if(k &lt;= mid)ADD(i&lt;&lt;1,k); else ADD((i&lt;&lt;1)|1,k); push_up(i);}void CHANGE(int i,int l,int r){ if(r &lt; l)return; if(segTree[i].l == l &amp;&amp; segTree[i].r == r) { Update(i,2); return; } int mid = (segTree[i].l + segTree[i].r)/2; push_down(i); if(r &lt;= mid)CHANGE(i&lt;&lt;1,l,r); else if(l &gt; mid)CHANGE((i&lt;&lt;1)|1,l,r); else { CHANGE(i&lt;&lt;1,l,mid); CHANGE((i&lt;&lt;1)|1,mid+1,r); } push_up(i);}long long sum(int i,int l,int r){ if(segTree[i].l == l &amp;&amp; segTree[i].r == r) return segTree[i].sum; int mid = (segTree[i].l+segTree[i].r)/2; push_down(i); if(r &lt;= mid)return sum(i&lt;&lt;1,l,r); else if(l &gt; mid)return sum((i&lt;&lt;1)|1,l,r); else { return (sum(i&lt;&lt;1,l,mid)+sum((i&lt;&lt;1)|1,mid+1,r))%MOD; }} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1) { for(int i = 0;i &lt; n;i++) { node[i].input(); b[i] = node[i].y; } sort(node,node+n,cmp); sort(b,b+n); tot = unique(b,b+n)-b; map&lt;int,int&gt;mp; for(int i = 0;i &lt; tot;i++)mp[b[i]] = i+1; for(int i = tot;i &gt; 0;i–) b[i] = b[i-1]; memset(c,0,sizeof(c)); long long ans = 0; build(1,1,tot); for(int i = 0;i &lt; n;i++) { int id = mp[node[i].y]; long long tmp = pow_m(2,node[i].x); tmp = tmp (sum(1,id,tot) + pow_m(3,node[i].y))%MOD; tmp = (tmp%MOD+MOD)%MOD; ans += tmp; if(ans &gt;= MOD)ans -= MOD; int nn = sum(id-1); ans += pow_m(2,node[i].x) (pow_m(2,nn) - 1)%MOD*pow_m(3,node[i].y)%MOD; if(ans &gt;= MOD)ans -= MOD; ADD(1,id); CHANGE(1,id+1,tot); } printf(“%d\n”,(int)ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SGU 110. Dungeon （三维几何）]]></title>
    <url>%2F2014%2F08%2F04%2Fsgu110%2F</url>
    <content type="text"><![CDATA[SGU 110 Dungeon 一些球体，给了一个光线，求光线反射的顺序。 110. Dungeon time limit per test: 0.25 sec. memory limit per test: 4096 KB The mission of space explorers found on planet M the vast dungeon. One of the dungeon halls is fill with the bright spheres. The explorers find out that the light rays reflect from the surface of the spheres according the ordinary law (the incidence angle is equal to the reflectance angle, the incidence ray, the reflected ray and the perpendicular to the sphere surface lay in the one plane). The ancient legend says that if the light ray will reflect from the spheres in the proper order, than the door to the room with very precious ancient knowledge will open. You are not to guess the right sequence; your task is much simpler. You are given the positions and the radii of the spheres, the place where the laser shot was made and the direction of light propagation. And you must find out the sequence in which the light will be reflected from the spheres. Input The first line of input contains the single integer n (1≤n≤50) - the amount of the spheres. The next n lines contain the coordinates and the radii of the spheres xi, yi, zi, ri (the integer numbers less or equal to 10000 by absolute value). The last line contains 6 real numbers - the coordinates of two points. The first one gives the coordinates of the place of laser shot, and the second gives the direction in which it was made (the second point is the point on the ray). The starting point of the ray lies strictly outside of any sphere. Output Your program must output the sequence of sphere numbers (spheres are numbers from 1 as they was given in input), from which the light ray was reflected. If the ray will reflect more the 10 times, than you must output first 10, then a space and the word ‘etc.’ (without quotes). Notice: if the light ray goes at a tangent to the sphere you must assume that the ray was reflected by the sphere. Sample Input 1 10 0 2 10 0 0 0 0 1 Sample Output 1 1 Sample Input 2 20 0 2 10 0 -2 10 0 0 0 0 100 Sample Output 2 1 2 1 2 1 2 1 2 1 2 etc. 按照点 和 方向向量去表示射线。 用参数方程去求解射线和球的交点，先找到一个最小的，然后进行反射。 /* ***Author :kuangbinCreated Time :2014/8/4 22:01:33File Name :E:\2014ACM\专题学习\计算几何\三维几何\SGU110.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const double eps = 1e-8;int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;}struct Point3{ double x,y,z; Point3(double _x = 0,double _y = 0,double _z = 0) { x = _x; y = _y; z = _z; } void input() { scanf(“%lf%lf%lf”,&amp;x,&amp;y,&amp;z); } double len() { return sqrt(x*x+y*y+zz); } double len2() { return x\x+y*y+zz; } double distance(const Point3 &amp;b)const { return sqrt((x-b.x)(x-b.x)+(y-b.y)(y-b.y)+(z-b.z)(z-b.z)); } Point3 operator -(const Point3 &amp;b)const { return Point3(x-b.x,y-b.y,z-b.z); } Point3 operator +(const Point3 &amp;b)const { return Point3(x+b.x,y+b.y,z+b.z); } Point3 operator (const double &amp;k)const { return Point3(x\k,y*k,zk); } Point3 operator /(const double &amp;k)const { return Point3(x/k,y/k,z/k); } double operator (const Point3 &amp;b)const { return x*b.x+y*b.y+zb.z; } Point3 operator ^(const Point3 &amp;b)const { return Point3(y\b.z-z*b.y,z*b.x+x*b.z,x*b.y-y*b.x); }};//球体struct Sphere{ Point3 o; double r; void input() { o.input(); scanf(“%lf”,&amp;r); }};//射线和球求交点bool Intersaction(Point3 st,Point3 dir,Sphere sp,double &amp;t){ double a = dir.x*dir.x + dir.y*dir.y + dir.zdir.z; double b = 2(st.x-sp.o.x)*dir.x + 2*(st.y-sp.o.y)*dir.y + 2*(st.z-sp.o.z)dir.z; double c = (st.x-sp.o.x)(st.x-sp.o.x) + (st.y-sp.o.y)(st.y-sp.o.y) + (st.z-sp.o.z)(st.z-sp.o.z) - sp.rsp.r; double deta = b\b - 4*ac; if(sgn(deta) &lt; 0)return false; double x1 = (-b-sqrt(deta))/(2a); double x2 = (-b+sqrt(deta))/(2a); if(x1 &gt; x2)swap(x1,x2); if(sgn(x1) &lt;= 0)return false; t = x1; return true;}Point3 Ref(Point3 st,Point3 p,Sphere sp){ Point3 tp = sp.o + ( ((p-sp.o)((p-sp.o)(st-sp.o)))/((p-sp.o).len2()) ); return Point3(2\tp.x-st.x,2*tp.y-st.y,2*tp.z-st.z)-p;}Sphere sp[100]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1) { for(int i = 0;i &lt; n;i++)sp[i].input(); Point3 now,dir; now.input(); dir.input(); dir = dir - now; int last = -1; for(int i = 0;i &lt; 11;i++) { int id = -1; double mint = 1e300; for(int j = 0;j &lt; n;j++) if(j != last) { double t; if(Intersaction(now,dir,sp[j],t)) if(mint &gt; t) { id = j; mint = t; } } if(id != -1) { if(i == 10) { printf(“ etc.\n”); break; } if(i &gt; 0)printf(“ “); Point3 pp = now + (dir*mint); Point3 tmp = Ref(now,pp,sp[id]); now = pp; dir = tmp; printf(“%d”,id+1); } else { printf(“\n”); break; } last = id; } } return 0;}]]></content>
      <categories>
        <category>Online Judge</category>
        <category>SGU</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>SGU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4908 BestCoder Sequence （水题）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4908%2F</url>
    <content type="text"><![CDATA[HDU 4908BestCoder SequenceBestCoder SequenceTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 113 Accepted Submission(s): 49 Problem Description Mr Potato is a coder. Mr Potato is the BestCoder. One night, an amazing sequence appeared in his dream. Length of this sequence is odd, the median number is M, and he named this sequence as Bestcoder Sequence. As the best coder, Mr potato has strong curiosity, he wonder the number of consecutive sub-sequences which are bestcoder sequences in a given permutation of 1 ~ N. Input Input contains multiple test cases. For each test case, there is a pair of integers N and M in the first line, and an permutation of 1 ~ N in the second line. [Technical Specification] 1. 1 &lt;= N &lt;= 40000 2. 1 &lt;= M &lt;= N Output For each case, you should output the number of consecutive sub-sequences which are the Bestcoder Sequences. Sample Input 1 1 1 5 3 4 5 3 2 1 Sample Output 1 3 Hint For the second case, {3},{5,3,2},{4,5,3,2,1} are Bestcoder Sequence. Source BestCoder Round #3 在一个1-N的全排列中。 找有多少个子串，这个子串的中位数是M, 这个串必须跨越M的位置。 然后需要大于M的个数等于小于M的个数。 一边统计，一边直接搞就可以了。 /* ***Author :kuangbinCreated Time :2014/8/3 19:07:52File Name :B.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 40010; int a[MAXN];int n,m;int num[MAXN*2];int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%d%d”,&amp;n,&amp;m) == 2) { int id = -1; for(int i = 1;i &lt;= n;i++) { scanf(“%d”,&amp;a[i]); if(a[i] == m) id = i; } memset(num,0,sizeof(num)); int s = 0; for(int i = id;i &gt;= 1;i–) { if(a[i] &gt; m)s++; else if(a[i] &lt; m)s–; num[s+40000]++; } int ans = 0; s = 0; for(int i = id;i &lt;= n;i++) { if(a[i] &lt; m)s++; else if(a[i] &gt; m)s–; ans += num[40000+s]; } printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4909 String]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4909%2F</url>
    <content type="text"><![CDATA[HDU 4909StringStringTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others) Total Submission(s): 54 Accepted Submission(s): 13 Problem Description You hava a non-empty string which consists of lowercase English letters and may contain at most one ‘?’. Let’s choose non-empty substring G from S (it can be G = S). A substring of a string is a continuous subsequence of the string. if G contains ‘?’ then ‘?’ can be deleted or replaced by one of lowercase english letters. After that if each letter occurs even number of times in G then G is a good substring. Find number of all good substrings. Input The input consists of an integer T, followed by T lines, each containing a non-empty string. The length of the string doesn’t exceed 20000. [Technical Specification] 1 &lt;= T &lt;= 100 Output For each test case, print a single integer which is the number of good substrings of a given string. Sample Input 3 abc?ca aabbcc aaaaa Sample Output 7 6 6 Hint Good substrings of “abc?ca”: “?”, “c?”, “?c”, “c?c”, “bc?c”, “c?ca”, “abc?ca” Source BestCoder Round #3 因为最多只有一个? 两段可以的话，字母出现次数的奇偶性只能相等或者差1\. 用map 去映射出现次数，然后查找。 一个坑点导致了TLE, 还是对map 不够熟悉啊。 如果直接ans += mp\[s\], 会新加入好多无用点，s如果不在会直接插入的。 应该if(mp.count(s))ans += mp\[s\]; /* ***Author :kuangbinCreated Time :2014/8/3 19:47:05File Name :C.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int num[30];char str[20010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); while(T–) { scanf(“%s”,str); map&lt;int,int&gt;mp1; map&lt;int,int&gt;mp2; bool has = false; int n = strlen(str); has = false; mp1[0]++; memset(num,0,sizeof(num)); int s = 0; int ans = 0; for(int i = 0;i &lt; n;i++) { if(str[i] != ‘?’) { s ^= (1&lt;&lt;(str[i]-‘a’)); } else { has = true; } if(!has) { if(mp1.count(s))ans += mp1[s]; mp1[s]++; } else { if(mp2.count(s))ans += mp2[s]; if(mp1.count(s))ans += mp1[s]; for(int j = 0;j &lt; 26;j++) if(mp1.count(s^(1&lt;&lt;j))) ans += mp1[s^(1&lt;&lt;j)]; mp2[s]++; } } printf(“%d\n”,ans); } return 0;} 可以使用数组进行优化，空间换时间。 /* ***Author :kuangbinCreated Time :2014/8/3 19:47:05File Name :C.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;char str[20010];short num1[1&lt;&lt;26];short num2[1&lt;&lt;26];int a[20010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); while(T–) { scanf(“%s”,str); bool has = false; int n = strlen(str); num1[0]++; int s = 0; int ans = 0; for(int i = 0;i &lt; n;i++) { if(str[i] != ‘?’) { s ^= (1&lt;&lt;(str[i]-‘a’)); } else { has = true; } a[i] = s; if(!has) { ans += num1[s]; num1[s]++; } else { ans += num1[s]; ans += num2[s]; for(int j = 0;j &lt; 26;j++) ans += num1[s^(1&lt;&lt;j)]; num2[s]++; } } for(int i = 0;i &lt; n;i++) { if(num1[a[i]])num1[a[i]] = 0; if(num2[a[i]])num2[a[i]] = 0; } num1[0] = 0; printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4910 Problem about GCD （数论）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4910%2F</url>
    <content type="text"><![CDATA[HDU 4910Problem about GCD求小于等于 N 的与N互质的所有数的乘积mod NProblem about GCDTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 26 Accepted Submission(s): 6 Problem Description Given integer m. Find multiplication of all 1&lt;=a&lt;=m such gcd(a, m)=1 (coprime with m) modulo m. Input Input contains multiple tests, one test per line. Last line contains -1, it should be skipped.[Technical Specification] m &lt;= 10^18 Output For each test please output result. One case per line. Less than 160 test cases. Sample Input 1 2 3 4 5 -1 Sample Output 0 1 2 3 4 Source BestCoder Round #3 很显然，需要找规律。 答案要么是N-1，要么是1.答案为N-1的情况是: 1 2 4 此外 如果 N!=4 &amp;&amp; N%4 == 0 答案是1 如果N为偶数，要求N/2 是 p^k的形式； 如果N为奇数，要求N是p^k的形式。 /* ***Author :kuangbinCreated Time :2014/8/3 19:24:03File Name :D.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; /* ************************************************* * Miller_Rabin 算法进行素数测试 * 速度快，可以判断一个 &lt; 2^63 的数是不是素数 * **/ const int S = 20; //随机算法判定次数，一般8~10就够了 // 计算ret = (a*b)%c a,b,c &lt; 2^63long long mult_mod(long long a,long long b,long long c){ a %= c; b %= c; long long ret = 0; long long tmp = a; while(b) { if(b &amp; 1) { ret += tmp; if(ret &gt; c)ret -= c;//直接取模慢很多 } tmp &lt;&lt;= 1; if(tmp &gt; c)tmp -= c; b &gt;&gt;= 1; } return ret;} // 计算 ret = (a^n)%modlong long pow_mod(long long a,long long n,long long mod){ long long ret = 1; long long temp = a%mod; while(n) { if(n &amp; 1)ret = mult_mod(ret,temp,mod); temp = mult_mod(temp,temp,mod); n &gt;&gt;= 1; } return ret;} // 通过 a^(n-1)=1(mod n)来判断n是不是素数// n-1 = x*2^t 中间使用二次判断// 是合数返回true, 不一定是合数返回falsebool check(long long a,long long n,long long x,long long t){ long long ret = pow_mod(a,x,n); long long last = ret; for(int i = 1;i &lt;= t;i++) { ret = mult_mod(ret,ret,n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n-1)return true;//合数 last = ret; } if(ret != 1)return true; else return false;}//**// Miller_Rabin算法// 是素数返回true,(可能是伪素数)// 不是素数返回false//**bool Miller_Rabin(long long n){ if( n &lt; 2)return false; if( n == 2)return true; if( (n&amp;1) == 0)return false;//偶数 long long x = n - 1; long long t = 0; while( (x&amp;1)==0 ){x &gt;&gt;= 1; t++;} srand(time(NULL));/* *************** */ for(int i = 0;i &lt; S;i++) { long long a = rand()%(n-1) + 1; if( check(a,n,x,t) ) return false; } return true; } //**// pollard_rho 算法进行质因素分解//////*long long factor[100];//质因素分解结果（刚返回时时无序的）int tol;//质因素的个数，编号0~tol-1 long long gcd(long long a,long long b){ long long t; while(b) { t = a; a = b; b = t%b; } if(a &gt;= 0)return a; else return -a;} //找出一个因子long long pollard_rho(long long x,long long c){ long long i = 1, k = 2; srand(time(NULL)); long long x0 = rand()%(x-1) + 1; long long y = x0; while(1) { i ++; x0 = (mult_mod(x0,x0,x) + c)%x; long long d = gcd(y - x0,x); if( d != 1 &amp;&amp; d != x)return d; if(y == x0)return x; if(i == k){y = x0; k += k;} }} //对 n进行素因子分解，存入factor. k设置为107左右即可void findfac(long long n,int k){ if(n == 1)return; if(Miller_Rabin(n)) { factor[tol++] = n; return; } long long p = n; int c = k; while( p &gt;= n) p = pollard_rho(p,c–);//值变化，防止死循环k findfac(p,k); findfac(n/p,k);} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); long long n; while(scanf(&quot;%I64d&quot;,&amp;n) == 1) { if(n == -1)break; if(n &lt;= 1) { printf(&quot;0\\n&quot;); continue; } if(n == 1 || n == 2 || n == 4) { printf(&quot;%I64d\\n&quot;,n-1); continue; } if(n != 4 &amp;&amp; n % 4 == 0) { printf(&quot;1\\n&quot;); continue; } tol = 0; if(n%2 == 0) { findfac(n/2,107); sort(factor,factor+tol); bool flag = true; for(int i = 1;i &lt; tol;i++) if(factor\[i-1\] != factor\[i\]) { flag = false; break; } if(flag)printf(&quot;%I64d\\n&quot;,n-1); else printf(&quot;1\\n&quot;); } else { findfac(n,107); sort(factor,factor+tol); bool flag = true; for(int i = 1;i &lt; tol;i++) if(factor\[i-1\] != factor\[i\]) { flag = false; break; } if(flag)printf(&quot;%I64d\\n&quot;,n-1); else printf(&quot;1\\n&quot;); } } return 0; }]]></content>
      <categories>
        <category>数学题</category>
        <category>数论</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4893 Wow! Such Sequence! （水题）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4893-2%2F</url>
    <content type="text"><![CDATA[HDU 4893Wow! Such Sequence!Wow! Such Sequence!Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2407 Accepted Submission(s): 711 Problem Description Recently, Doge got a funny birthday present from his new friend, Protein Tiger from St. Beeze College. No, not cactuses. It’s a mysterious blackbox.After some research, Doge found that the box is maintaining a sequence an of n numbers internally, initially all numbers are zero, and there are THREE “operations”: 1.Add d to the k-th number of the sequence. 2.Query the sum of ai where l ≤ i ≤ r. 3.Change ai to the nearest Fibonacci number, where l ≤ i ≤ r. 4.Play sound “Chee-rio!”, a bit useless. Let F0 = 1,F1 = 1,Fibonacci number Fn is defined as Fn = Fn - 1 + Fn - 2 for n ≥ 2. Nearest Fibonacci number of number x means the smallest Fn where |Fn - x| is also smallest. Doge doesn’t believe the machine could respond each request in less than 10ms. Help Doge figure out the reason. Input Input contains several test cases, please process till EOF. For each test case, there will be one line containing two integers n, m. Next m lines, each line indicates a query:1 k d - “add” 2 l r - “query sum” 3 l r - “change to nearest Fibonacci” 1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, |d| &lt; 231, all queries will be valid. Output For each Type 2 (“query sum”) operation, output one line containing an integer represent the answer of this query. Sample Input 1 1 2 1 1 5 4 1 1 7 1 3 17 3 2 4 2 1 5 Sample Output 0 22 Author Fudan University Source 2014 Multi-University Training Contest 3 水题。 理解题意就可以了， int WA了，改成long long AC /* ***Author :kuangbinCreated Time :2014/8/3 16:39:04File Name :E:\2014ACM\比赛\2014多校训练\2014多校3\HDU4891.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;char str[1010][10100]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) == 1) { gets(str[0]); for(int i = 0;i &lt; n;i++) gets(str[i]); long long ans = 1; int c0 = 0, c1 = 0; int cnt0 = 0, cnt1 = 0; for(int i = 0;i &lt; n;i++) { if(ans &gt; 100000)break; int len = strlen(str[i]); for(int j = 0;j &lt; len;j++) { if(str[i][j] == ‘$’) { if(c0 == 0)c0 = 1; else { ans = (cnt0+1); cnt0 = 0; c0 = 0; } } if(str[i][j] == ‘{‘) c1 = 1; if(str[i][j] == ‘}’) { c1 = 0; ans = (cnt1+1); cnt1 = 0; } if(c0 &gt; 0) { if(str[i][j] == ‘ ‘) cnt0++; else { ans *= (cnt0+1); cnt0 = 0; } } if(c1 &gt; 0 &amp;&amp; str[i][j] == ‘|’) cnt1++; if(ans &gt; 100000)break; } } if(ans &gt; 100000)printf(“doge\n”); else printf(“%d\n”,(int)ans); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4893 Wow! Such Sequence! （线段树）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4893%2F</url>
    <content type="text"><![CDATA[HDU 4893Wow! Such Sequence! 线段树。 加个标记就可以了。 Wow! Such Sequence!Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2403 Accepted Submission(s): 710 Problem Description Recently, Doge got a funny birthday present from his new friend, Protein Tiger from St. Beeze College. No, not cactuses. It’s a mysterious blackbox. After some research, Doge found that the box is maintaining a sequence an of n numbers internally, initially all numbers are zero, and there are THREE “operations”: 1.Add d to the k-th number of the sequence. 2.Query the sum of ai where l ≤ i ≤ r. 3.Change ai to the nearest Fibonacci number, where l ≤ i ≤ r. 4.Play sound “Chee-rio!”, a bit useless. Let F0 = 1,F1 = 1,Fibonacci number Fn is defined as Fn = Fn - 1 + Fn - 2 for n ≥ 2. Nearest Fibonacci number of number x means the smallest Fn where |Fn - x| is also smallest. Doge doesn’t believe the machine could respond each request in less than 10ms. Help Doge figure out the reason. Input Input contains several test cases, please process till EOF. For each test case, there will be one line containing two integers n, m. Next m lines, each line indicates a query: 1 k d - “add” 2 l r - “query sum” 3 l r - “change to nearest Fibonacci” 1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, |d| &lt; 231, all queries will be valid. Output For each Type 2 (“query sum”) operation, output one line containing an integer represent the answer of this query. Sample Input 1 1 2 1 1 5 4 1 1 7 1 3 17 3 2 4 2 1 5 Sample Output 0 22 Author Fudan University Source 2014 Multi-University Training Contest 3 只需要使用线段树，加个懒得标记。 sum1表示当前的和，sum2表示当前最近的斐波那契数列的和。 然后直接搞就可以了。 /* ***Author :kuangbinCreated Time :2014/8/3 15:06:42File Name :E:\2014ACM\比赛\2014多校训练\2014多校3\HDU4893.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;long long f[72];const int MAXN = 100010;struct Node{ int l,r; int lazy; long long sum1,sum2;}segTree[MAXN&lt;&lt;2];void Update(int i){ segTree[i].sum1 = segTree[i].sum2; segTree[i].lazy = 1;}void push_up(int i){ segTree[i].sum1 = segTree[i&lt;&lt;1].sum1 + segTree[(i&lt;&lt;1)|1].sum1; segTree[i].sum2 = segTree[i&lt;&lt;1].sum2 + segTree[(i&lt;&lt;1)|1].sum2;}void push_down(int i){ if(segTree[i].lazy) { Update(i&lt;&lt;1); Update((i&lt;&lt;1)|1); segTree[i].lazy = 0; }}void build(int i,int l,int r){ segTree[i].l = l; segTree[i].r = r; segTree[i].lazy = 0; if(l == r) { segTree[i].sum1 = 0; segTree[i].sum2 = 1; return; } int mid = (l+r)/2; build(i&lt;&lt;1,l,mid); build((i&lt;&lt;1)|1,mid+1,r); push_up(i);} void Add(int i,int k,int d){ if(segTree[i].l == k &amp;&amp; segTree[i].r == k) { segTree[i].sum1 += d; int id = lower_bound(f,f+70,segTree[i].sum1) - f; segTree[i].sum2 = f[id]; if(id &gt; 0) { if(segTree[i].sum1-f[id-1] &lt;= f[id]-segTree[i].sum1) segTree[i].sum2 = f[id-1]; } return; } push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(k &lt;= mid)Add(i&lt;&lt;1,k,d); else Add((i&lt;&lt;1)|1,k,d); push_up(i);}long long query(int i,int l,int r){ if(segTree[i].l == l &amp;&amp; segTree[i].r == r) return segTree[i].sum1; push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)return query(i&lt;&lt;1,l,r); else if(l &gt; mid)return query((i&lt;&lt;1)|1,l,r); else return query(i&lt;&lt;1,l,mid) + query((i&lt;&lt;1)|1,mid+1,r);}void Change(int i,int l,int r){ if(segTree[i].l == l &amp;&amp; segTree[i].r == r) { Update(i); return; } if(segTree[i].lazy)return; int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)Change(i&lt;&lt;1,l,r); else if(l &gt; mid)Change((i&lt;&lt;1)|1,l,r); else { Change(i&lt;&lt;1,l,mid); Change((i&lt;&lt;1)|1,mid+1,r); } push_up(i);} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); f[0] = 1; f[1] = 1; for(int i = 2;i &lt; 70;i++) { f[i] = f[i-1]+f[i-2]; } int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2) { build(1,1,n); int op; int l,r; while(m–) { scanf(“%d%d%d”,&amp;op,&amp;l,&amp;r); if(op == 1)Add(1,l,r); else if(op == 2)printf(“%I64d\n”,query(1,l,r)); else Change(1,l,r); } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>数据结构</category>
        <category>算法</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4889 Scary Path Finding Algorithm （构造）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4889%2F</url>
    <content type="text"><![CDATA[HDU 4889Scary Path Finding AlgorithmScary Path Finding AlgorithmTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 268 Accepted Submission(s): 121 Special Judge Problem Description Fackyyj loves the challenge phase in TwosigmaCrap(TC). One day, he meet a task asking him to find shortest path from vertex 1 to vertex n, in a graph with at most n vertices and m edges. (1 ≤ n ≤ 100,0 ≤ m ≤ n(n-1))Fackyyj solved this problem at first glance, after that he opened someone’s submission, spotted the following code: long long spfa_slf() { int n,m; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int,int&gt; &gt; edges[111]; for(int i = 0;i &lt; m;i++) { int x,y,w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; edges[x].push_back(make_pair(y,w)); } deque q; vector dist(n+1, ~0ULL&gt;&gt;1); vector inQueue(n+1, false); dist[1] = 0; q.push_back(1); inQueue[1] = true; int doge = 0; while(!q.empty()) { int x = q.front(); q.pop_front(); if(doge++ &gt; C) { puts(“doge”); return 233; } for(vector&lt;pair&lt;int,int&gt; &gt;::iterator it = edges[x].begin(); it != edges[x].end();++it) { int y = it-&gt;first; int w = it-&gt;second; if(dist[y] &gt; dist[x] + w) { dist[y] = dist[x] + w; if(!inQueue[y]) { inQueue[y] = true; if(!q.empty() &amp;&amp; dist[y] &gt; dist[q.front()]) q.push_back(y); else q.push_front(y); } } } inQueue[x] = false; } return dist[n]; } Fackyyj’s face lit up with an evil smile. He immediately clicked button “Challenge!”, but due to a hard disk failure, all of his test case generators were lost! Fackyyj had no interest on recreating his precise generators, so he asked you to write one. The generator should be able to generate a test case with at most 100 vertices, and it must be able to fail the above code, i.e. let the above code print “doge”. It should NOT contain any negative-cost loop. For those guys who doesn’t know C++, Fackyyj explain the general idea of the above algorithm by the following psuedo-code: Input Input contains several test cases, please process till EOF. For each test case, there will be a single line containing an integer C. It is the constant C in the above code. (C &lt;= 23333333) Output For each test case, on the first line, print two integers, n and m, indicating the number of vertices and the number of edges of your graph. Next m lines, on each line print x y w, means there is a road from x to y, cost w. 1 ≤ n ≤ 100,0 ≤ m ≤ n(n-1),|w| &lt; 231. Note that your output shouldn’t contain any negative-cost loop. Sample Input 1 Sample Output 4 3 1 2 1 2 3 1 3 4 1 Author Fudan University Source 2014 Multi-University Training Contest 3 直接进行构造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* ***************Author :kuangbinCreated Time :2014/8/3 12:18:25File Name :E:\2014ACM\比赛\2014多校训练\2014多校3\HDU4889.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int C; while(scanf("%d",&amp;C) == 1) &#123; int n = 30; int m = n*(n-1)/2; printf("%d %d\n",n,m); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i+1;j &lt;= n;j++) printf("%d %d %d\n",i,j,-(1&lt;&lt;(n-i))); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4888 Redraw Beautiful Drawings （最大流）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4888%2F</url>
    <content type="text"><![CDATA[HDU 4888Redraw Beautiful DrawingsRedraw Beautiful DrawingsTime Limit: 3000/1500 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1856 Accepted Submission(s): 415 Problem Description Alice and Bob are playing together. Alice is crazy about art and she has visited many museums around the world. She has a good memory and she can remember all drawings she has seen. Today Alice designs a game using these drawings in her memory. First, she matches K+1 colors appears in the picture to K+1 different integers(from 0 to K). After that, she slices the drawing into grids and there are N rows and M columns. Each grid has an integer on it(from 0 to K) representing the color on the corresponding position in the original drawing. Alice wants to share the wonderful drawings with Bob and she tells Bob the size of the drawing, the number of different colors, and the sum of integers on each row and each column. Bob has to redraw the drawing with Alice’s information. Unfortunately, somtimes, the information Alice offers is wrong because of Alice’s poor math. And sometimes, Bob can work out multiple different drawings using the information Alice provides. Bob gets confused and he needs your help. You have to tell Bob if Alice’s information is right and if her information is right you should also tell Bob whether he can get a unique drawing. Input The input contains mutiple testcases. For each testcase, the first line contains three integers N(1 ≤ N ≤ 400) , M(1 ≤ M ≤ 400) and K(1 ≤ K ≤ 40). N integers are given in the second line representing the sum of N rows. M integers are given in the third line representing the sum of M columns. The input is terminated by EOF. Output For each testcase, if there is no solution for Bob, output “Impossible” in one line(without the quotation mark); if there is only one solution for Bob, output “Unique” in one line(without the quotation mark) and output an N * M matrix in the following N lines representing Bob’s unique solution; if there are many ways for Bob to redraw the drawing, output “Not Unique” in one line(without the quotation mark). Sample Input 2 2 4 4 2 4 2 4 2 2 2 2 5 0 5 4 1 4 3 9 1 2 3 3 Sample Output Not Unique Impossible Unique 1 2 3 3 用最大流去判断有没有解。 判断多解的话，在残余网络中看能不能找到长度大于2的环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364/* ***************Author :kuangbinCreated Time :2014/8/3 13:06:32File Name :E:\2014ACM\比赛\2014多校训练\2014多校3\HDU4888.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1010;//点数的最大值const int MAXM = 400010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;//加边，单向图三个参数，双向图四个参数void addedge(int u,int v,int w,int rw=0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u]; edge[tol].flow = 0;head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v]; edge[tol].flow = 0;head[v]=tol++;&#125;//输入参数：起点、终点、点的总数//点的编号没有影响，只要输入点的总数int sap(int start,int end,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; &#125; u = start; ans += Min; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1;i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = pre[v] = i; break; &#125; &#125; if(flag) &#123; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1;i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; &#125; return ans;&#125;int a[500];int b[500];int id[500][500];bool vis[MAXN];bool dfs(int u,int pre)&#123; //printf("%d %d\n",pre,u); if(vis[u])return true; vis[u] = true; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(edge[i].cap &lt;= edge[i].flow)continue; if(v == pre)continue; if(dfs(v,u))return true; &#125; vis\[u\] = false; return false;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m,K; while(scanf("%d%d%d",&amp;n,&amp;m,&amp;K) == 3) &#123; init(); int sum1 = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;a[i]); sum1 += a[i]; addedge(0,i,a[i]); &#125; int sum2 = 0; for(int i = 1;i &lt;= m;i++) &#123; scanf("%d",&amp;b[i]); sum2 += b[i]; addedge(i+n,n+m+1,b[i]); &#125; if(sum1 != sum2) &#123; printf("Impossible\n"); continue; &#125; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; id[i][j] = tol; addedge(i,j+n,K); &#125; int tmp = sap(0,n+m+1,n+m+2); if(tmp != sum1) &#123; printf("Impossible\n"); continue; &#125; memset(vis,false,sizeof(vis)); bool flag = false; for(int i = 1;i &lt;= n;i++) if(dfs(i,i)) &#123; flag = true; break; &#125; if(flag) &#123; printf("Not Unique\n"); continue; &#125; printf("Unique\n"); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; printf("%d",edge[id[i][j]].flow); if(j &lt; m)printf(" "); else printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4887 Endless Punishment （矩阵+BSGS）]]></title>
    <url>%2F2014%2F08%2F03%2Fhdu4887%2F</url>
    <content type="text"><![CDATA[HDU 4887Endless PunishmentEndless PunishmentTime Limit: 30000/15000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 95 Accepted Submission(s): 41 Problem Description In the ancient Greek tale, Sisyphus was a king of Ephyra, he was punished for chronic deceitfulness by being compelled to roll an immense stone up a hill every day, only to watch it roll back down, and to repeat this action forever. Zeus, the God of the universe, shows some mercy for Sisyphus, so he decides to change the way of punishment. He puts N stones with the color of white or black in a line on the hill, everyday when Sisyphus rolls a new stone up the hill, the new stone is added to the back of the old N stones, and the first stone rolls down to the foot of the hill. Then Zeus shows his magic to change the color of the new N stones. Firstly, he looks at a subset S1 of the original N stones, which always includes the first stone, if an odd number of the stones are black, then the newly N-th stone will be black and white otherwise. After the first step is done, he flips the color of another subset S2 of the new N stones, black stone will become white, and white stone will become black vice versa. The following example illustrates how Zeus’s magic works. Consider the case of N = 4, S1 = {1,3}, S2 = {2,4}. Suppose the current stone color state is ●○○○, (○ for white stone, and ● for black stone), the 1st and 3rd stone is black and white respectively, so the new 4th stone will be black, produces ○○○● after the first step. At the second step, the 2nd and 4th stone flip its color, produces ○●○○ in the end. Zeus tells to Sisyphus that, if one day after the two steps are done, the color of the stones turns to one specific state, he will get his freedom. Now given the current and final stone colors, please compute how many days are needed for Sisyphus’s freedom? Input There are several test cases, please process till EOF. For each test case, the first line contains three integers, the first integer is N(2 ≤ N ≤ 31), the number of stones, followed by two integers S1 and S2, (1 ≤ S1,S2 ≤ N), denoting the size of two subsets as mentioned above. The second and third line contains S1 and S2 integers a and b in the increasing order, describing the two subsets. It is guaranteed that a1 always equals to 1. The last two lines each contains N integers with 0 (for white), or 1 (for black) denoting the current and final state. The first integer describes the first stone, and the last integer describes the last stone. Please note that there are about 500 test cases, fortunately, only 20 of them are big test cases. Output For each test case, output a single integer, the minimum days for Sisyphus to get his freedom. If Zeus is an absolute liar, then just simply print the sentence poor sisyphus. Sample Input 4 2 2 1 3 2 4 1 0 0 0 0 1 0 0 4 2 2 1 3 2 4 1 1 1 1 0 0 0 0 4 2 2 1 3 2 4 1 1 1 1 0 1 0 0 10 5 6 1 2 4 5 6 2 4 5 8 9 10 0 0 0 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 Sample Output 1 4 poor sisyphus 387 Author Fudan University Source 2014 Multi-University Training Contest 3 题意很清楚。N(2 ≤ N ≤ 31)个01串，按照规则去变化，问经过几步可以从原串变化到目标串。首先需要说明的是，两个变化其实都可以写成矩阵形式，运算就是异或，也就是模2加。 把N个01向量，后面加一个1，变成N+1维，这样两个操作都可以使用N+1 * N+1 的矩形进行表示了。 然后还有个问题，因为S1集合里面一定包含了1， 所以这两个操作都是可逆的。 使用BSGS的方法去寻找。 状态最多是 1&lt;&lt;n step = ceil(sqrt(1&lt;&lt;n)). 首先从目标态，倒着求step步的状态，进行映射。 这个就是baby step. 然后从初始状态，每次走大步， 知道落入刚才的映射值。 小步的时候，复杂度是O(n), 大步的时候复杂度是O(n^2) 的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305/* ***************Author :kuangbinCreated Time :2014/8/3 9:31:49File Name :E:\2014ACM\比赛\2014多校训练\2014多校3\HDU4887.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;//矩阵struct Matrix&#123; int n; int mat[40][40]; void init(int _n) &#123; n = _n; memset(mat,0,sizeof(mat)); &#125; Matrix operator *(const Matrix &amp;b)const &#123; Matrix ret; ret.init(n); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) &#123; for(int k = 0;k &lt; n;k++) &#123; ret.mat[i][j] += (mat[i][k]*b.mat[k][j])&amp;1; ret.mat[i][j] &amp;= 1; &#125; &#125; return ret; &#125; void debug() &#123; printf("n : %d\n",n); for(int i = 0;i &lt; n;i++) &#123; for(int j = 0;j &lt; n;j++)printf("%d ",mat[i][j]); cout&lt;&lt;endl; &#125; &#125;&#125;;Matrix pow_M(Matrix a,int n)&#123; Matrix ret; ret.init(a.n); for(int i = 0;i &lt; a.n;i++)ret.mat[i][i] = 1; Matrix tmp = a; while(n) &#123; if(n&amp;1)ret = ret*tmp; tmp = tmp*tmp; n &gt;&gt;= 1; &#125; return ret;&#125;Matrix A,B,C,D;int a[40],b[40],c[40],d[40];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; int S1,S2; while(scanf("%d%d%d",&amp;n,&amp;S1,&amp;S2) == 3) &#123; A.init(n+1);//第一个操作的变换矩阵 for(int i = 0;i &lt; n-1;i++)A.mat[i+1][i] = 1; A.mat[n][n] = 1; for(int i = 0;i &lt; S1;i++) &#123; scanf("%d",&amp;a[i]); a[i]--; A.mat[a[i]][n-1] = 1; &#125; int change = 0; B.init(n+1);//第二个操作矩阵 for(int i = 0;i &lt; n+1;i++)B.mat[i][i] = 1; for(int i = 0;i &lt; S2;i++) &#123; scanf("%d",&amp;b[i]); b[i]--; change |= (1&lt;&lt;(n-1-b[i])); B.mat[n][b[i]] = 1; &#125; for(int i = 0;i &lt; n;i++)scanf("%d",&amp;c[i]); int end = 0; for(int i = 0;i &lt; n;i++) &#123; scanf("%d",&amp;d[i]); end &lt;&lt;= 1; end |= d[i]; &#125; int step = ceil(sqrt((1LL)&lt;&lt;n)); map&lt;int,int&gt;mp; int now = end; for(int i = 0;i &lt; step;i++) &#123; if(mp.find(now) == mp.end())mp[now] = i; else break; now ^= change; int tmp = now&amp;1; for(int j = 1;j &lt; S1;j++) tmp ^= ( (now&amp;(1&lt;&lt;(n-1-(a[j]-1)))) != 0 ); now &gt;&gt;= 1; now |= tmp*(1&lt;&lt;(n-1)); &#125; int tot = (1LL&lt;&lt;n)/step; int ans = -1; //A.debug(); //B.debug(); C = A*B; C = pow_M(C,step); c[n] = 1; for(int i = 0;i &lt;= tot;i++) &#123; int st = 0; for(int j = 0;j &lt; n;j++) &#123; st &lt;&lt;= 1; st |= c[j]; &#125; if(mp.find(st) != mp.end()) &#123; ans = i*step + mp[st]; break; &#125; for(int j = 0;j &lt;= n;j++) &#123; d[j] = 0; for(int k = 0;k &lt;= n;k++) &#123; d[j] ^= ((c[k]*C.mat[k][j])&amp;1); &#125; &#125; for(int j = 0;j &lt;= n;j++)c[j] = d[j]; &#125; if(ans == -1)printf("poor sisyphus\n"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>数学题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数学</tag>
        <tag>Baby-Step Giant-Step</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 6141 Binary Matrix 2 （ZKW费用流）]]></title>
    <url>%2F2014%2F08%2F02%2Fuvalive6141%2F</url>
    <content type="text"><![CDATA[UVALive 6141Binary Matrix 2用最小费用最大流做。 题目链接： UVALive VJ 题意就是n*m的01矩阵。 可以把0翻转为1,1翻转为0， 求最少的翻转次数，使得每行1的个数相同，每列1的个数相同。 构建一个费用流模型。 首先可以枚举最终状态，假如最终每行有i个1，那么每列1的个数就是i*n/m (当然要保证整除) 左边是n个点，右边是m个点。 源点到左边n个点的费用就是0，流量就是i. 右边的m个点到汇点的边费用是0，流量是i*n/m 然后左边到右边的点，两两之间的边就是流量为1的，费用的话看对应的位置是0还是1，是1的话，费用是-1，是0的话费用是1. 那么这次需要的最少翻转次数就是 最小费用+原来1的总个数。 建图的理解可以这样想， 首先费用是原来1的总个数。 就相当于把所有1都翻转为0， 然后建图以后，如果走一条原来就是1的边，那么加费用为-1的边，表示如果利用一个的话，费用就是-1了。 相反如果走原来为0的边，那么费用要+1. 这样最小费用 + sum 就是答案了。 这种类似二分图的费用流， 路径短，边很多。 使用SPFA的费用流是很慢的， 对于这题SPFA的费用流就T了。 写这题的目的就是为了写一个重口味费用流的模板。 zkw费用流适合这种二分图类型的图。 /* ***Author :kuangbinCreated Time :2014/8/2 10:21:53File Name :E:\2014ACM\区域赛练习\2012\2012Hatyai\A.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 100;const int MAXM = 20000;const int INF = 0x3f3f3f3f;struct Edge{ int to,next,cap,flow,cost; Edge(int _to = 0,int _next = 0,int _cap = 0,int _flow = 0,int _cost = 0): to(_to),next(_next),cap(_cap),flow(_flow),cost(_cost){}}edge[MAXM]; struct ZKW_MinCostMaxFlow{ int head[MAXN],tot; int cur[MAXN]; int dis[MAXN]; bool vis[MAXN]; int ss,tt,N;//源点、汇点和点的总个数（编号是0~N-1）,不需要额外赋值，调用会直接赋值 int min_cost, max_flow; void init() { tot = 0; memset(head,-1,sizeof(head)); } void addedge(int u,int v,int cap,int cost) { edge[tot] = Edge(v,head[u],cap,0,cost); head[u] = tot++; edge[tot] = Edge(u,head[v],0,0,-cost); head[v] = tot++; } int aug(int u,int flow) { if(u == tt)return flow; vis[u] = true; for(int i = cur[u];i != -1;i = edge[i].next) { int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; !vis[v] &amp;&amp; dis[u] == dis[v] + edge[i].cost) { int tmp = aug(v,min(flow,edge[i].cap-edge[i].flow)); edge[i].flow += tmp; edge[i^1].flow -= tmp; cur[u] = i; if(tmp)return tmp; } } return 0; } bool modify_label() { int d = INF; for(int u = 0;u &lt; N;u++) if(vis[u]) for(int i = head[u];i != -1;i = edge[i].next) { int v = edge[i].to; if(edge[i].cap&gt;edge[i].flow &amp;&amp; !vis[v]) d = min(d,dis[v]+edge[i].cost-dis[u]); } if(d == INF)return false; for(int i = 0;i &lt; N;i++) if(vis[i]) { vis[i] = false; dis[i] += d; } return true; } /\* \* 直接调用获取最小费用和最大流 \* 输入: start-源点，end-汇点，n-点的总个数（编号从0开始） \* 返回值: pair&lt;int,int&gt; 第一个是最小费用，第二个是最大流 */ pair&lt;int,int&gt; mincostmaxflow(int start,int end,int n) { ss = start, tt = end, N = n; min\_cost = max\_flow = 0; for(int i = 0;i &lt; n;i++)dis\[i\] = 0; while(1) { for(int i = 0;i &lt; n;i++)cur\[i\] = head\[i\]; while(1) { for(int i = 0;i &lt; n;i++)vis\[i\] = false; int tmp = aug(ss,INF); if(tmp == 0)break; max_flow += tmp; min_cost += tmp*dis\[ss\]; } if(!modify_label())break; } return make\_pair(min\_cost,max_flow); } }solve;char str[110][110]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,m; scanf(“%d”,&amp;T); int iCase = 0; while(T–) { iCase++; scanf(“%d%d”,&amp;n,&amp;m); int sum = 0; for(int i = 0;i &lt; n;i++) { scanf(“%s”,str[i]); for(int j = 0;j &lt; m;j++) if(str[i][j] == ‘1’) sum++; } int ans = min(sum,nm-sum); for(int x = 1;x &lt; m;x++) { if(xn%m != 0)continue; int c = xn/m; if(abs(sum-nx) &gt;= ans)continue; solve.init(); for(int i = 0;i &lt; n;i++)solve.addedge(n+m,i,x,0); for(int j = 0;j &lt; m;j++)solve.addedge(j+n,n+m+1,c,0); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) { if(str[i][j] == ‘1’)solve.addedge(i,j+n,1,-1); else solve.addedge(i,j+n,1,1); } pair&lt;int,int&gt; tmp = solve.mincostmaxflow(n+m,n+m+1,n+m+2); ans = min(ans,tmp.first+sum); } printf(“Case %d: %d\n”,iCase,ans); } return 0;}]]></content>
      <categories>
        <category>UVALive</category>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4906 Our happy ending （DP）]]></title>
    <url>%2F2014%2F07%2F31%2Fhdu4906%2F</url>
    <content type="text"><![CDATA[HDU 4906 Our happy endingOur happy endingTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 128 Accepted Submission(s): 26 Problem Description There is an old country and the king fell in love with a devil. The devil always asks the king to do some crazy things. Although the king used to be wise and beloved by his people. Now he is just like a boy in love and can’t refuse any request from the devil. Also, this devil is looking like a very cute Loli.Y*wan still remember the day he first meets the devil. Now everything is done and the devil is gone. Y*wan feel very sad and suicide. You feel guilty after killing so many loli, so you suicide too. Nobody survive in this silly story, but there is still some hope, because this is just a silly background story during one programming contest! And the last problem is: Given a sequence a_1,a_2,…,a_n, if we can take some of them(each a_i can only be used once), and they sum to k, then we say this sequence is a good sequence. How many good sequence are there? Given that each a_i is an integer and 0&lt;= a_i &lt;= L. You should output the result modulo 10^9+7. Input The first line contains an integer T, denoting the number of the test cases. For each test case, the first line contains 3 integers n, k, L.T&lt;=20, n,k&lt;=20 , 0&lt;=L&lt;=10^9. Output For each cases, output the answer in a single line. Sample Input 1 2 2 2 Sample Output 6 Author WJMZBMR Source 2014 Multi-University Training Contest 4 题意比较容易理解。 这题的关键点就是n,k比较小，都&lt;= 20 虽然L 比较大，但是 取0 和 取 &gt; k是没有影响的。 使用状态压缩去DP。 使用dp\[j\] 表示前i个数，可以表示的数的状态是j , 有多少种。 第一维不需要增加空间了，滚动数组就可以了。 /* ***Author :kuangbinCreated Time :2014/7/31 19:00:30File Name :E:\2014ACM\比赛\2014多校训练\2014多校4\HDU4906.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;int dp[1&lt;&lt;20];void add(int &amp;a,int b){ a += b; if(a &gt;= MOD)a -= MOD;}int two[30]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); two[0] = 1; for(int i = 1;i &lt; 30;i++) two[i] = 2two[i-1]; int T; int n,k,L; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d%d”,&amp;n,&amp;k,&amp;L); memset(dp,0,sizeof(dp)); dp[0] = 1; for(int i = 0;i &lt; n;i++) for(int j = two[k]-1; j &gt;= 0;j–) if(dp[j]) { int tmp = dp[j]; for(int x = 1;x &lt;= min(k,L);x++) { int nj = j | two[x-1]; nj |= ((j &lt;&lt; x) &amp; (two[k]-1)); add(dp[nj],tmp); } if(L &gt; k)add(dp[j],(long long)tmp(L-k)%MOD); } int ans = 0; for(int i = two[k-1];i &lt; two[k];i++) add(ans,dp[i]); printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>DP</category>
        <category>HDU</category>
        <category>Online Judge</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>DP</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4866 Shooting （主席树）]]></title>
    <url>%2F2014%2F07%2F24%2Fhdu-4866-shooting-ef-bc-88-e4-b8-bb-e5-b8-ad-e6-a0-91-ef-bc-89%2F</url>
    <content type="text"><![CDATA[HDU 4866ShootingShootingTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others) Total Submission(s): 433 Accepted Submission(s): 62 Problem Description In the shooting game, the player can choose to stand in the position of [1, X] to shoot, you can shoot all the nearest K targets. The value of K may be different on different shootings. There are N targets to shoot, each target occupy the position of [Li, Ri] , the distance from the starting line is Di(1&lt;=i&lt;=N). Shooting a target can get the bonus points equal to the distance to the starting line. After each shooting targets still exist. Additional, if the previous bonus points is more than P, then as a reward for the shooting present bonus points doubled(and then check the next one). Player wants to know the bonus points he got in each shot. Input The input consists several test cases. The first line has two integers, N, M, X, P(1&lt;=N, M ,X&lt;=100000, P&lt;=1000000000), N represents the total number of target shooting, M represents the number of shooting. The next N lines of three integers L, R, D (1&lt;=L&lt;=R&lt;=X, 1&lt;=D&lt;=10000000), occupy the position of [L, R] and the distance from the starting line is D. The next M lines, each line contains four integers x, a, b, c (1&lt;=x&lt;=X, 0&lt;=a,b&lt;=N, 1&lt;=c&lt;=10000000), and K = ( a * Pre + b ) % c. Pre is the bonus point of previous shooting , and for the first shooting Pre=1. It denotes standing in the position x and the player can shoot the nearest K targets. Output Output M lines each corresponds to one integer. Sample Input 4 3 5 8 1 2 6 2 3 3 2 4 7 1 5 2 2 2 1 5 3 1 1 10 4 2 3 7 Sample Output 11 10 18 Author FZU Source 2014 Multi-University Training Contest 1 y坐标离散化一下。 线段树维护。 加入主席树。 按照从左到右加入，左端点加，右端点减。 线段树一个是记录个数，一个是记录和。 /* ***Author :kuangbinCreated Time :2014/7/23 23:37:24File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\HDU4866.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 200010;const int M = MAXN * 100;int n,tot;int T[MAXN];int lson[M],rson[M];int c1[M];long long c2[M];int build(int l,int r){ int root = tot++; c1[root] = 0; c2[root] = 0; if(l != r) { int mid = (l+r)/2; lson[root] = build(l,mid); rson[root] = build(mid+1,r); } return root;}int update(int root,int pos,int val1,long long val2){ int newroot = tot++, tmp = newroot; c1[newroot] = c1[root] + val1; c2[newroot] = c2[root] + val2; int l = 1, r = n; while(l &lt; r) { int mid = (l+r)/2; if(pos &lt;= mid) { lson[newroot] = tot++; rson[newroot] = rson[root]; newroot = lson[newroot]; root = lson[root]; r = mid; } else { rson[newroot] = tot++; lson[newroot] = lson[root]; newroot = rson[newroot]; root = rson[root]; l = mid+1; } c1[newroot] = c1[root] + val1; c2[newroot] = c2[root] + val2; } return tmp;}long long query(int root,int K){ long long ret = 0; int l = 1, r = n; while(l &lt; r) { int mid = (l+r)/2; if(c1[lson[root]] &gt;= K) { r = mid; root = lson[root]; } else { K -= c1[lson[root]]; ret += c2[lson[root]]; root = rson[root]; l = mid+1; } } return ret + c2[root];} struct Node{ int x; int D; int index; Node(int _x = 0,int _D = 0,int _index = 0) { x = _x; D = _D; index = _index; }}node[MAXN];bool cmp(Node a,Node b){ if(a.x != b.x)return a.x &lt; b.x; else return a.D &gt; b.D;}int y[MAXN];int ind[MAXN];bool cmp2(int a,int b){ return y[a] &lt; y[b];}int rind[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int N,MM,X,P; while(scanf(“%d%d%d%d”,&amp;N,&amp;MM,&amp;X,&amp;P) == 4) { tot = 0; int cnt = 0; int cnty = 0; int L,R,D; for(int i = 0;i &lt; N;i++) { scanf(“%d%d%d”,&amp;L,&amp;R,&amp;D); y[cnty++] = D; ind[i] = i; node[++cnt] = Node(L,D,i); node[++cnt] = Node(R,-D,i); } sort(ind,ind+N,cmp2); for(int i = 0;i &lt; N;i++) rind[ind[i]] = i+1; n = N; sort(node+1,node+cnt+1,cmp); T[0] = build(1,n); for(int i = 1;i &lt;= cnt;i++) { if(node[i].D &gt; 0) T[i] = update(T[i-1],rind[node[i].index],1,node[i].D); else T[i] = update(T[i-1],rind[node[i].index],-1,node[i].D); } int x,a,b,c; long long pre = 1; while(MM–) { scanf(“%d%d%d%d”,&amp;x,&amp;a,&amp;b,&amp;c); int id = 0; int l = 1, r = cnt; while(l &lt;= r) { int mid = (l+r)/2; if(node[mid].x &lt; x || (node[mid].x == x &amp;&amp; node[mid].D &gt; 0)) { id = mid; l = mid+1; } else { r = mid-1; } } int K = (pre%ca%c+b)%c; if(K == 0) { printf(“0\n”); pre = 0; continue; } long long ans = query(T[id],K); if(pre &gt; P)ans = 2; printf(“%I64d\n”,ans); pre = ans; } } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>主席树</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4865 Peter's Hobby （胡搞）]]></title>
    <url>%2F2014%2F07%2F23%2Fhdu4865%2F</url>
    <content type="text"><![CDATA[HDU 4865Peter’s HobbyPeter’s HobbyTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 344 Accepted Submission(s): 148 Problem Description Recently, Peter likes to measure the humidity of leaves. He recorded a leaf humidity every day. There are four types of leaves wetness: Dry , Dryish , Damp and Soggy. As we know, the humidity of leaves is affected by the weather. And there are only three kinds of weather: Sunny, Cloudy and Rainy.For example, under Sunny conditions, the possibility of leaves are dry is 0.6. Give you the possibility list of weather to the humidity of leaves. The weather today is affected by the weather yesterday. For example, if yesterday is Sunny, the possibility of today cloudy is 0.375. The relationship between weather today and weather yesterday is following by table: Now,Peter has some recodes of the humidity of leaves in N days.And we know the weather conditons on the first day : the probability of sunny is 0.63,the probability of cloudy is 0.17,the probability of rainny is 0.2.Could you know the weathers of these days most probably like in order? Input The first line is T, means the number of cases, then the followings are T cases. for each case: The first line is a integer n(n&lt;=50),means the number of days, and the next n lines, each line is a string shows the humidity of leaves (Dry, Dryish, Damp, Soggy) Output For each test case, print the case number on its own line. Then is the most possible weather sequence.( We guarantee that the data has a unique solution) Sample Input 1 3 Dry Damp Soggy Sample Output Case #1: Sunny Cloudy Rainy Hint Log is useful. Author FZU Source 2014 Multi-University Training Contest 1 马尔科夫链去转移，记录路径，然后输出结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191/* ***************Author :kuangbinCreated Time :2014/7/23 21:58:58File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\HDU4865.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;double dp[100][3];int pre[100][3];char str[20];double a[][4] = &#123; &#123;0.6,0.2,0.15,0.05&#125;, &#123;0.25,0.3,0.2,0.25&#125;, &#123;0.05,0.10,0.35,0.50&#125;,&#125;;double b[][3] = &#123; &#123;0.5,0.375,0.125&#125;, &#123;0.25,0.125,0.625&#125;, &#123;0.25,0.375,0.375&#125;,&#125;;int get(char str[])&#123; if(strcmp(str,"Dry") == 0)return 0; else if(strcmp(str,"Dryish") == 0)return 1; else if(strcmp(str,"Damp") == 0)return 2; else return 3;&#125;void out(int i,int t)&#123; if(i &gt; 1)out(i-1,pre[i][t]); if(t == 0)printf("Sunny\n"); else if(t == 1)printf("Cloudy\n"); else printf("Rainy\n");&#125;int main()&#123; // freopen("1005.in","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; int n; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d",&amp;n); printf("Case #%d:\n",iCase); dp[0][0] = log(0.63); dp[0][1] = log(0.17); dp[0][2] = log(0.2); for(int i = 1;i &lt;= n;i++) &#123; scanf("%s",str); int id = get(str); if(i == 1) &#123; for(int j = 0;j &lt; 3;j++) dp[i][j] = dp[i-1][j] + log(a[j][id]); &#125; else &#123; for(int j = 0;j &lt; 3;j++) &#123; dp[i][j] = -100000000.0; for(int t = 0;t &lt; 3;t++) &#123; if(dp[i-1][t] + log(b[t][j])+log(a[j][id]) &gt; dp[i][j]) &#123; dp[i][j] = dp[i-1][t]+log(b[t][j])+log(a[j][id]); pre[i][j] = t; &#125; &#125; &#125; &#125; &#125; if(dp[n][0] &gt; dp[n][1] &amp;&amp; dp[n][0] &gt; dp[n][2]) out(n,0); else if(dp[n][1] &gt; dp[n][0] &amp;&amp; dp[n][1] &gt; dp[n][2]) out(n,1); else out(n,2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4864 Task （multiset）]]></title>
    <url>%2F2014%2F07%2F23%2Fhdu-4864-task-ef-bc-88multiset-ef-bc-89%2F</url>
    <content type="text"><![CDATA[HDU 4864TaskTaskTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 2221 Accepted Submission(s): 572 Problem Description Today the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500*xi+2*yi) dollars. The company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine. The company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum. Input The input contains several test cases. The first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 &lt; =N &lt;= 100000,1&lt;=M&lt;=100000). The following N lines each contains two integers xi(0&lt;xi&lt;1440),yi(0=&lt;yi&lt;=100).xi is the maximum time the machine can work.yi is the level of the machine. The following M lines each contains two integers xi(0&lt;xi&lt;1440),yi(0=&lt;yi&lt;=100).xi is the time we need to complete the task.yi is the level of the task. Output For each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get. Sample Input 1 2 100 3 100 2 100 1 Sample Output 1 50004 Author FZU Source 2014 Multi-University Training Contest 1 直接使用multiset进行贪心。 按照y从大到小排序。 然后每次选择y尽量大，x尽量大的。 /* ***Author :kuangbinCreated Time :2014/7/23 21:43:15File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\HDU4864.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;struct Node{ int x,y; void input() { scanf(“%d%d”,&amp;x,&amp;y); } Node(int _x = 0,int _y = 0) { x = _x; y = _y; }};struct classcomp{ bool operator()(const Node &amp;a,const Node &amp;b)const { if(a.x != b.x)return a.x &gt; b.x; else return a.y&gt; b.y; }};multiset&lt;Node,classcomp&gt;mt;multiset&lt;Node,classcomp&gt;::iterator it; const int MAXN = 100010;Node node1[MAXN];Node node2[MAXN];bool cmp(Node a,Node b){ return a.y &lt; b.y;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2) { for(int i = 0;i &lt; n;i++)node1[i].input(); for(int i = 0;i &lt; m;i++)node2[i].input(); mt.clear(); sort(node1,node1+n,cmp); sort(node2,node2+m,cmp); int id = 0; int ans1 = 0; long long ans2 = 0; for(int i = 0;i &lt; n;i++) { while(id &lt; m &amp;&amp; node2[id].y &lt;= node1[i].y) { mt.insert(node2[id]); id++; } it = mt.lower_bound(Node(node1[i].x,1000)); if(it != mt.end()) { ans1++; ans2 += (long long)500(\it).x + 2*(*it).y; mt.erase(it); } } printf(“%d %I64d\n”,ans1,ans2); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Online Judge</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4871 Shortest-path tree （树分治）]]></title>
    <url>%2F2014%2F07%2F23%2Fhdu4871%2F</url>
    <content type="text"><![CDATA[HDU 4871Shortest-path tree树分治。 Shortest-path treeTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 130712/130712 K (Java/Others) Total Submission(s): 146 Accepted Submission(s): 47 Problem Description Given a connected, undirected graph G, a shortest-path tree rooted at vertex v is a spanning tree T of G, such that the path distance from root v to any other vertex u in T is the shortest path distance from v to u in G. We may construct a shortest-path tree using the following method: We consider a shortest-path tree rooted at node 1. For every node i in the graph G, we choose a shortest path from root to i. If there are many shortest paths from root to i, we choose the one that the sequence of passing nodes’ number is lexicographically minimum. All edges on the paths that we chose form a shortest-path tree. Now we want to know how long are the longest simple paths which contain K nodes in the shortest-path tree and how many these paths? Two simple paths are different if the sets of nodes they go through are different. Input The first line has a number T (T &lt;= 10), indicating the number of test cases. For each test case, the first line contains three integers n, m, k(1&lt;=n&lt;=30000,1&lt;=m&lt;=60000,2&lt;=k&lt;=n), denote the number of nodes, the number of edges and the nodes of required paths. Then next m lines, each lines contains three integers a, b, c(1&lt;=a, b&lt;=n, 1&lt;=c&lt;=10000),denote there is an edge between a, b and length is c. Output For each case, output two numbers, denote the length of required paths and the numbers of required paths. Sample Input 1 6 6 4 1 2 1 2 3 1 3 4 1 2 5 1 3 6 1 5 6 1 Sample Output 3 4 Author FZU Source 2014 Multi-University Training Contest 1 首先跑一下堆优化的Dij 或者SPFA 把树搞出来。 树搞出来以后就是树分治了。 一颗一颗子树加入。每次都找重心。 树分治写起来要小心，很容易T的。 树分治还需要多练习了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547/* ***************Author :kuangbinCreated Time :2014/7/23 17:45:13File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\HDU4871.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 30010;struct qnode&#123; int v; int c; qnode(int _v = 0,int _c = 0):v(_v),c(_c)&#123;&#125; bool operator &lt;(const qnode &amp;r)const &#123; if(c != r.c)return c &gt; r.c; else return v &gt; r.v; &#125;&#125;;struct EE&#123; int v,cost; EE(int _v = 0,int _cost = 0):v(_v),cost(_cost)&#123;&#125;&#125;;vector&lt;EE&gt;E[MAXN];bool vis[MAXN];int dist[MAXN];int pre[MAXN];int pre_w[MAXN];void Dijkstra(int n,int start)&#123; memset(vis,false,sizeof(vis)); for(int i = 1;i &lt;= n;i++)dist[i] = INF; priority_queue&lt;qnode&gt;que; while(!que.empty())que.pop(); dist[start] = 0; pre[start] = -1; que.push(qnode(start,0)); qnode tmp; while(!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if(vis[u])continue; vis[u] = true; for(int i = 0;i &lt; E[u].size();i++) &#123; int v = E[u][i].v; int cost = E[u][i].cost; if(!vis[v]) &#123; if(dist[v] &gt; dist[u]+cost) &#123; dist[v] = dist[u]+cost; pre[v] = u; pre_w[v] = E[u][i].cost; que.push(qnode(v,dist[v])); &#125; else if(dist[v] == dist[u]+cost &amp;&amp; u &lt; pre[v]) &#123; pre[v] = u; pre_w[v] = cost; &#125; &#125; &#125; &#125;&#125;struct Edge&#123; int to,next; int w;&#125;edge[MAXN*2];int head[MAXN],tot;void init()&#123; memset(head,-1,sizeof(head)); tot = 0;&#125;void addedge(int u,int v,int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;int ans1,ans2;int k;int size[MAXN];int dfssize(int u,int pre)&#123; size[u] = 1; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(v == pre || vis[v])continue; size[u] += dfssize(v,u); &#125; return size[u];&#125;int minn;void getroot(int u,int pre,int totnum,int &amp;root)&#123; int maxx = totnum - size[u]; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(v == pre || vis[v])continue; getroot(v,u,totnum,root); maxx = max(maxx,size[v]); &#125; if(maxx &lt; minn)&#123;minn = maxx; root = u;&#125;&#125;int dp[MAXN];int dpnum[MAXN];int pd[MAXN];int pdnum[MAXN];bool used[MAXN];int dis[MAXN];int dep[MAXN];int maxdep;void getdp(int s,int w)&#123; memset(pd,0,sizeof(pd)); memset(pdnum,0,sizeof(pdnum)); memset(used,false,sizeof(used)); pdnum[0] = 1; dis[s] = w; dep[s] = 1; pd[dep[s]] = w; pdnum[dep[s]] = 1; queue&lt;int&gt;q; q.push(s); used[s] = true; while(!q.empty()) &#123; int u = q.front(); q.pop(); if(maxdep &lt; dep[u])maxdep = dep[u]; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(used[v] || vis[v])continue; dep[v] = dep[u]+1; dis[v] = dis[u]+edge[i].w; used[v] = true; q.push(v); if(dis[v] &gt; pd[dep[v]]) &#123; pd[dep[v]] = dis[v]; pdnum[dep[v]] = 1; &#125; else if(dis[v] == pd[dep[v]]) pdnum[dep[v]]++; &#125; &#125;&#125;void getpd(int u,int pre,int nw,int nd)&#123; if(nd &gt; k-1)return; if(maxdep &lt; nd)maxdep = nd; if(nw &gt; pd[nd]) &#123; pd[nd] = nw; pdnum[nd] = 1; &#125; else if(nw == pd[nd]) pdnum[nd]++; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(v == pre || vis[v])continue; getpd(v,u,nw+edge[i].w,nd+1); &#125;&#125;void solve(int u)&#123; int totnum = dfssize(u,-1); minn = INF; int root; getroot(u,-1,totnum,root); vis[root] = true; for(int i = 0;i &lt;= totnum;i++) &#123; dp[i] = 0; dpnum[i] = 0; &#125; dpnum[0] = 1; for(int i = head[root];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(vis[v])continue; maxdep = 0; for(int j = 0;j &lt;= size[v];j++) &#123; pd[j] = 0; pdnum[j] = 0; &#125; pdnum[0] = 1; getpd(v,u,edge[i].w,1); for(int j = 1;j &lt;= maxdep &amp;&amp; j &lt; k;j++) if(pdnum[j]&amp;&amp;dpnum[k-1-j]) &#123; if(ans1 &lt; pd[j]+dp[k-1-j]) &#123; ans1 = pd[j]+dp[k-1-j]; ans2 = pdnum[j]*dpnum[k-1-j]; &#125; else if(ans1 == pd[j]+dp[k-1-j]) ans2 += pdnum[j]*dpnum[k-1-j]; &#125; for(int j = 1;j &lt;= maxdep &amp;&amp; j &lt;= k;j++) &#123; if(dp[j] &lt; pd[j]) &#123; dp[j] = pd[j]; dpnum[j] = pdnum[j]; &#125; else if(dp[j] == pd[j]) dpnum[j] += pdnum[j]; &#125; &#125; for(int i = head[root];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(vis[v])continue; solve(v); &#125;&#125;int main()&#123; //freopen("1011.in","r",stdin); //freopen("out.txt","w",stdout); int T; int n,m; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i &lt;= n;i++)E[i].clear(); int u,v,w; while(m--) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); E[u].push_back(EE(v,w)); E[v].push_back(EE(u,w)); &#125; Dijkstra(n,1); init(); int ccc = 0; for(int i = 2;i &lt;= n;i++) &#123; addedge(i,pre[i],pre_w[i]); addedge(pre[i],i,pre_w[i]); &#125; ans1 = 0; ans2 = 0; memset(vis,false,sizeof(vis)); solve(1); printf("%d %d\n",ans1,ans2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>树分治</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4863 Centroid of a Tree （树形DP）]]></title>
    <url>%2F2014%2F07%2F23%2Fhdu4863%2F</url>
    <content type="text"><![CDATA[HDU 4863Centroid of a TreeCentroid of a TreeTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 49 Accepted Submission(s): 15 Problem Description Given a tree T with N vertices, your task is calculating the number of the connected sub-tree of T, which has the same centroid as T. In order to define the centroid, some integer value will be associated to every vertex. Let’s consider the vertex k. If we remove the vertex k from the tree (along with its adjacent edges), the remaining graph will have only N-1 vertices and may be composed of more than one connected components. Each of these components is (obviously) a tree. The value associated to vertex k is the largest number of vertices contained by some connected component in the remaining graph, after the removal of vertex k. All the vertices for which the associated value is minimum are considered centroids. A graph can have an arbitrary number of centroids. However,it can be proved that for trees, there are only two possibilities: 1. The tree has precisely one centroid. 2. The tree has precisely two centroids. In this case, the two centroids are adjacent. Note that in case 2, we just consider that T has two centroids, you should only count the sub-tree which has the two same centroids as T. Input The first line of the date is an integer T, which is the number of the text cases. Then T cases follow each case starts of a number N descript above. Then N-1 lines follow, each line contains two integers x and y, which means that there is a edge between x and y in tree T, you can assume that the index of T is from 1 to N. 1 &lt;= T &lt;= 50, 1 &lt;= N &lt;= 200, Output For each case, output the case number first, then output the number of the connected sub-tree which has the same centroid as T. Give your answer modulo 10007. Sample Input 5 1 2 1 2 3 1 2 1 3 4 1 2 1 3 1 4 5 1 2 1 3 1 4 4 5 Sample Output Case 1: 1 Case 2: 1 Case 3: 2 Case 4: 5 Case 5: 6 Author FZU Source 2014 Multi-University Training Contest 1 本题需要找出和原来的树有相同重心的子树。 首先树形DP来求出重心。 然后如果重心有一个。 以重心为根，树形DP一下，得出dp\[i\]\[j\]表示i的子树保留j个结点的种数。 然后可以先求反面。 就是根的一颗子树大小大于剩下的和。 暴力枚举最大子树，DP出其余子树取i个的方法数f\[i\]. 然后枚举最大子树取几个。 使用总数减掉这个就是答案。 如果两个重心，可以分成两颗树，这两颗树大小要一样。 好题啊。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385/* ***************Author :kuangbinCreated Time :2014/7/23 12:13:36File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\HDU4863.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 220;struct Edge&#123; int to,next;&#125;edge[MAXN*2];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int size[MAXN];int mx[MAXN];void dfs1(int u,int pre,int n)&#123; size[u] = 1; mx[u] = 0; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(v == pre)continue; dfs1(v,u,n); size[u] += size[v]; mx[u] = max(mx[u],size[v]); &#125; mx[u] = max(mx[u],n-size[u]);&#125;const int MOD = 10007;int dp[MAXN][MAXN];//dp[i][j]是i子树取j个结点的方法数void dfs_1(int u,int pre)&#123; size[u] = 1; dp[u][1] = 1; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(v == pre)continue; dfs_1(v,u); size[u] += size[v]; for(int j = size[u];j &gt; 0;j--) for(int k = 1;k &lt; j &amp;&amp; k &lt;= size[v];k++) &#123; dp[u][j] += dp[u][j-k]*dp[v][k]%MOD; if(dp[u][j] &gt;= MOD)dp[u][j] -= MOD; &#125; &#125;&#125;int f[MAXN];int solve1(int cen,int n)&#123; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++)dp[i][0] = 1; dfs_1(cen,cen); int ans = 0; for(int i = head[cen];i != -1;i = edge[i].next) &#123; int u = edge[i].to; memset(f,0,sizeof(f)); f[0] = 1; for(int j = head[cen];j != -1;j = edge[j].next) if(j != i) &#123; int v = edge[j].to; for(int y = n;y &gt; 0;y--) for(int x = 1;x &lt;= size[v] &amp;&amp; x &lt;= y;x++) &#123; f[y] += f[y-x]*dp[v][x]%MOD; if(f[y] &gt;= MOD)f[y] -= MOD; &#125; &#125; int tmp = f[0]%MOD; for(int j = 1;j &lt;= size[u];j++) &#123; ans += tmp*dp[u][j]%MOD; ans %= MOD; tmp += f[j]; tmp %= MOD; &#125; &#125; int tot = 1; for(int i = head[cen];i != -1;i = edge[i].next) &#123; int v = edge[i].to; int tmp = 0; for(int j = 0;j &lt;= size[v];j++) &#123; tmp = (tmp+dp[v][j])%MOD; &#125; tot = tot*tmp%MOD; &#125; ans = tot-ans; ans = (ans%MOD+MOD)%MOD; return ans;&#125;void dfs_2(int u,int pre,int no)&#123; size[u] = 1; dp[u][1] = 1; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(v == pre || v == no)continue; dfs_2(v,u,no); size[u] += size[v]; for(int j = size[u];j &gt; 0;j--) for(int k = 1;k &lt; j &amp;&amp; k &lt;= size[v];k++) &#123; dp[u][j] += dp[u][j-k]*dp[v][k]%MOD; if(dp[u][j] &gt;= MOD)dp[u][j] -= MOD; &#125; &#125;&#125;int solve2(int cen1,int cen2,int n)&#123; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++)dp[i][0] = 1; dfs_2(cen1,cen1,cen2); dfs_2(cen2,cen2,cen1); int ans = 0; for(int i = 1;i &lt;= n;i++) &#123; ans += dp[cen1][i]*dp[cen2][i]%MOD; ans %= MOD; &#125; return ans;&#125;int main()&#123; //freopen("1003.in","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; int n; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d",&amp;n); init(); int u,v; for(int i = 1;i &lt; n;i++) &#123; scanf("%d%d",&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; dfs1(1,1,n); int cen1,cen2; int cnt = 0; int MM = n; for(int i = 1;i &lt;= n;i++) &#123; if(mx[i] &lt; MM) &#123; MM = mx[i]; cen1 = i; cnt = 1; &#125; else if(mx[i] == MM) &#123; cen2 = i; cnt = 2; &#125; &#125; if(cnt == 1)printf("Case %d: %d\n",iCase,solve1(cen1,n)); else printf("Case %d: %d\n",iCase,solve2(cen1,cen2,n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4869 Turn the pokers]]></title>
    <url>%2F2014%2F07%2F23%2Fhdu4869%2F</url>
    <content type="text"><![CDATA[HDU 4869Turn the pokersTurn the pokersTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 394 Accepted Submission(s): 140 Problem Description During summer vacation,Alice stay at home for a long time, with nothing to do. She went out and bought m pokers, tending to play poker. But she hated the traditional gameplay. She wants to change. She puts these pokers face down, she decided to flip poker n times, and each time she can flip Xi pokers. She wanted to know how many the results does she get. Can you help her solve this problem? Input The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers n and m(0&lt;n,m&lt;=100000). The next line contains n integers Xi(0&lt;=Xi&lt;=m). Output Output the required answer modulo 1000000009 for each test case, one per line. Sample Input 3 4 3 2 3 3 3 3 2 3 Sample Output 8 3 Hint For the second example: 0 express face down,1 express face up Initial state 000 The first result:000-&gt;111-&gt;001-&gt;110 The second result:000-&gt;111-&gt;100-&gt;011 The third result:000-&gt;111-&gt;010-&gt;101 So, there are three kinds of results(110,011,101) Author FZU Source 2014 Multi-University Training Contest 1 其实就是求最后状态有几个可能翻转，然后就是组合数了。 有几个翻转是连续的区间，而且奇偶性和总和是一样的。 递推求出区间，然后求解。 一开始区间是\[0,0\] 递推的时候把几种情况都罗列一下，就得出了下一个区间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175/* ***************Author :kuangbinCreated Time :2014/7/23 8:54:58File Name :HDU4869.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int MOD = 1e9+9;long long pow_m(long long a,long long n,long long mod)&#123; long long ret = 1; long long tmp = a%mod; while(n) &#123; if(n&amp;1)ret = ret*tmp%mod; tmp = tmp*tmp%mod; n &gt;&gt;= 1; &#125; return ret;&#125;long long inv(long long a,long long mod)&#123; return pow_m(a,mod-2,mod);&#125;long long C[MAXN];long long INV[MAXN];int main()&#123; //freopen("1009.in","r",stdin); //freopen("out.txt","w",stdout); for(int i = 1;i &lt; MAXN;i++) INV[i] = inv(i,MOD); int n,m,a; while(scanf("%d%d",&amp;n,&amp;m) == 2) &#123; C[0] = 1; for(int i = 1;i &lt;= m;i++) &#123; C[i] = C[i-1](m-i+1)%MODINV[i]%MOD; &#125; int l = 0, r = 0; for(int i = 0;i &lt; n;i++) &#123; scanf("%d",&amp;a); int tmp1 = min(m-l,a); int nr = l+tmp1-(a-tmp1); int tmp2 = min(r,a); int nl = r-tmp2+(a-tmp2); if(nl &gt; nr)swap(nl,nr); if(l &lt;= a &amp;&amp; a &lt;= r) &#123; if(l%2 == a%2) nl = 0; else nl = min(nl,1); &#125; if((m-r) &lt;= a &amp;&amp; a &lt;= (m-l)) &#123; if((m-l)%2 == a%2) nr = m; else nr = max(nr,m-1); &#125; if(l &gt;= a)nl = min(nl,l-a); if(m-r &gt;= a)nr = max(nr,r+a); l = nl; r = nr; &#125; int ans = 0; for(int i = l;i &lt;= r;i += 2) &#123; ans += C[i]; if(ans &gt;= MOD)ans -= MOD; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>数学题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4870 Rating（高斯消元）]]></title>
    <url>%2F2014%2F07%2F22%2Fhdu4870%2F</url>
    <content type="text"><![CDATA[HDU 4870Rating 高斯消元。变量不多。 RatingTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 166 Accepted Submission(s): 87 Special Judge Problem Description A little girl loves programming competition very much. Recently, she has found a new kind of programming competition named “TopTopTopCoder”. Every user who has registered in “TopTopTopCoder” system will have a rating, and the initial value of rating equals to zero. After the user participates in the contest held by “TopTopTopCoder”, her/his rating will be updated depending on her/his rank. Supposing that her/his current rating is X, if her/his rank is between on 1-200 after contest, her/his rating will be min(X+50,1000). Her/His rating will be max(X-100,0) otherwise. To reach 1000 points as soon as possible, this little girl registered two accounts. She uses the account with less rating in each contest. The possibility of her rank between on 1 - 200 is P for every contest. Can you tell her how many contests she needs to participate in to make one of her account ratings reach 1000 points? Input There are several test cases. Each test case is a single line containing a float number P (0.3 &lt;= P &lt;= 1.0). The meaning of P is described above. Output You should output a float number for each test case, indicating the expected count of contest she needs to participate in. This problem is special judged. The relative error less than 1e-5 will be accepted. Sample Input 1.000000 0.814700 Sample Output 39.000000 82.181160 Author FZU Source 2014 Multi-University Training Contest 1 其实变量数很少，直接高斯消元。 其中在求解过程判断了 &lt; eps 返回无解，WA了好多发。 注释掉就AC了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/* ***************Author :kuangbinCreated Time :2014/7/22 23:33:49File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\HDU4870.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;#define eps 1e-9const int MAXN=420;double a[MAXN][MAXN],x[MAXN];//方程的左边的矩阵和等式右边的值，求解之后x存的就是结果int equ,var;//方程数和未知数个数/**返回0表示无解，1表示有解*/int Gauss()&#123; int i,j,k,col,max_r; for(k=0,col=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++) &#123; max_r=k; for(i=k+1;i&lt;equ;i++) if(fabs(a[i][col])&gt;fabs(a[max_r][col])) max_r=i; // if(fabs(a[max_r][col])&lt;eps)return 0; if(k!=max_r) &#123; for(j=col;j&lt;var;j++) swap(a[k][j],a[max_r][j]); swap(x[k],x[max_r]); &#125; x[k]/=a[k][col]; for(j=col+1;j&lt;var;j++)a[k][j]/=a[k][col]; a[k][col]=1; for(i=0;i&lt;equ;i++) if(i!=k) &#123; x[i]-=x[k]*a[i][col]; for(j=col+1;j&lt;var;j++)a[i][j]-=a[k][j]*a[i][col]; a[i][col]=0; &#125; &#125; return 1;&#125;int id[22][22];int main()&#123; //freopen("1010.in","r",stdin); //freopen("out.txt","w",stdout); int cnt = 0; for(int i = 0;i &lt;= 20;i++) for(int j = 0;j &lt;= 20;j++) &#123; if(i &gt; j)continue; if(i == 20 &amp;&amp; j == 20)continue; id[i][j] = cnt++; &#125; equ = var = cnt; double p; while(scanf("%lf",&amp;p) == 1) &#123; memset(a,0,sizeof(a)); for(int i = 0;i &lt;= 20;i++) for(int j = 0;j &lt;= 20;j++) &#123; if(i &gt; j)continue; if(i == 20 &amp;&amp; j == 20)continue; int u = id[i][j]; a[u][u] = 1.0; if(i == 20 || j == 20) &#123; x[u] = 0.0; continue; &#125; x[u] = 1.0; int nx = i+1; if(nx &lt;= j) a[u][id[nx][j]] -= p; else a[u][id[j][nx]] -= p; nx = max(0,i-2); a[u][id[nx][j]] -= (1-p); &#125; Gauss(); printf("%.6lf\n",x[0]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>数学题</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4862 Jump （最小费用最大流）]]></title>
    <url>%2F2014%2F07%2F22%2Fhdu4862%2F</url>
    <content type="text"><![CDATA[HDU 4862Jump 最小费用最大流。 很经典的网络流建图。 JumpTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 189 Accepted Submission(s): 63 Problem Description There are n*m grids, each grid contains a number, ranging from 0-9. Your initial energy is zero. You can play up to K times the game, every time you can choose any one of the grid as a starting point (but not traveled before) then you can choose a grid on the right or below the current grid to jump, but it has not traveled before. Every time you can jump as many times as you want, as long as you do not violate rules. If you are from (x1, y1) to (x2, y2), then you consume |x1-x2|+|y1-y2|-1 energies. Energy can be negative. However, in a jump, if you start position and end position has same numbers S, then you can increase the energy value by S. Give me the maximum energy you can get. Notice that you have to go each grid exactly once and you don’t have to play exactly K times. Input The first line is an integer T, stands for the number of the text cases. Then T cases followed and each case begin with three numbers N, M and K. Means there are N rows and M columns, you have K times to play. Then N lines follow, each line is a string which is made up by M numbers. The grids only contain numbers from 0 to 9. (T&lt;=100, N&lt;=10，M&lt;=10，K&lt;=100) Output Each case, The first you should output “Case x : ”,(x starting at 1),then output The maximum number of energy value you can get. If you can’t reach every grid in no more than K times, just output -1. Sample Input 5 1 5 1 91929 1 5 2 91929 1 5 3 91929 3 3 3 333 333 333 3 3 2 333 333 333 Sample Output Case 1 : 0 Case 2 : 15 Case 3 : 16 Case 4 : 18 Case 5 : -1 Author FZU Source 2014 Multi-University Training Contest 1 建图方法： 左右各n*m个点。加一个源点和一个汇点。 源点向左侧的每一个点连一条流量为1，费用为0的边。 右侧点连一条流量为1，费用为0的边到汇点。 如果左侧点的点，可以转移的话，对应连一条左侧点到右侧点的边，一步到达。 费用是消耗的费用-获得的费用。 再加一个点，起点到这个点连流量为1，费用为0的边。这个点向右侧的点连一条流量为1，费用为0的边。。 如果非满流，则不满足。 否则最小费用相反数就是最大收益。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315/* ***************Author :kuangbinCreated Time :2014/7/22 22:53:24File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\2014 Multi-University Training Contest 1（标程+数据）\多校第一场（标程+数据）\HDU4862.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1010;const int MAXM = 10010;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int N;void init(int n)&#123; N = n; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; N;i++) &#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] +edge[i].cost) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t)) &#123; int Min = INF; for(int i = pre[t];i != -1 ;i = pre[edge[i^1].to]) &#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != -1;i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost*Min; &#125; flow += Min; &#125; return flow;&#125;int n,m,k;char str[12][12];void solve()&#123; init(2*n*m + 3); int start = 2*n*m; int end = 2*n*m+2; addedge(start,start+1,k,0); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; addedge(start,2(im+j),1,0); addedge(2(im+j)+1,end,1,0); addedge(start+1,2(im+j)+1,1,0); for(int y = j+1;y &lt; m;y++) &#123; if(str[i][y] == str[i][j]) addedge(2(i*m+j),2*(im+y)+1,1,-(str[i][j]-'0')+y-j-1); else addedge(2(i*m+j),2*(im+y)+1,1,y-j-1); &#125; for(int x = i+1; x &lt; n;x++) &#123; if(str[x][j] == str[i][j]) addedge(2(i*m+j),2*(xm+j)+1,1,-(str[i][j]-'0')+x-i-1); else addedge(2(i*m+j),2*(xm+j)+1,1,x-i-1); &#125; &#125; int cost; int flow = minCostMaxflow(start,end,cost); if(flow != n*m)printf("-1\n"); else printf("%d\n",-cost);&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 0;i &lt; n;i++) scanf("%s",str[i]); printf("Case %d : ",iCase); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4861 Couple doubi]]></title>
    <url>%2F2014%2F07%2F22%2Fhdu4861%2F</url>
    <content type="text"><![CDATA[HDU 4861 Couple doubi 一个水题。 可以随便找规律。 Couple doubiTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 221 Accepted Submission(s): 186 Problem Description DouBiXp has a girlfriend named DouBiNan.One day they felt very boring and decided to play some games. The rule of this game is as following. There are k balls on the desk. Every ball has a value and the value of ith (i=1,2,…,k) ball is 1^i+2^i+…+(p-1)^i (mod p). Number p is a prime number that is chosen by DouBiXp and his girlfriend. And then they take balls in turn and DouBiNan first. After all the balls are token, they compare the sum of values with the other ,and the person who get larger sum will win the game. You should print “YES” if DouBiNan will win the game. Otherwise you should print “NO”. Input Multiply Test Cases. In the first line there are two Integers k and p(1&lt;k,p&lt;2^31). Output For each line, output an integer, as described above. Sample Input 2 3 20 3 Sample Output YES NO Author FZU Source 2014 Multi-University Training Contest 1 1^k + 2^k + 3^k + (p-1)^k % p 只有当k|p-1的时候才等于p-1,其余都是0的。 故非零的个数是 k/(p-1) 判断这个是奇数还是偶数就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* ***************Author :kuangbinCreated Time :2014/7/22 22:11:38File Name :E:\2014ACM\比赛\2014多校训练\2014多校1\2014 Multi-University Training Contest 1（标程+数据）\多校第一场（标程+数据）\HDU4861.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int k,p; while(scanf("%d%d",&amp;k,&amp;p) == 2) &#123; int t = k/(p-1); if(t&amp;1)printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regionals 2012 :: Asia - Dhaka]]></title>
    <url>%2F2014%2F07%2F21%2F2012dhaka%2F</url>
    <content type="text"><![CDATA[2012Dhaka题目链接：UVALive 比赛链接：VJ B： Wedding of Sultan就是一颗树的DFS序。求各个点的度。 直接搞，很简单，。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* ***************Author :kuangbinCreated Time :2014/7/21 18:09:57File Name :E:\2014ACM\区域赛练习\2012\2012Dhaka\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;char str[10000];int du[30];int pre[30];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%s",str); memset(du,0,sizeof(du)); int now = str[0] - 'A'; pre[now] = -1; int len = strlen(str); for(int i = 1;i &lt; len;i++) &#123; if(now == str[i] - 'A') now = pre[now]; else &#123; du[now]++; pre[str[i]-'A'] = now; now = str[i]-'A'; du[now] = 1; &#125; &#125; printf("Case %d\n",iCase); for(int i = 0;i &lt; 26;i++) if(du[i]) printf("%c = %d\n",'A'+i,du[i]); &#125; return 0;&#125; C： Memory Overflow水题一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* ***************Author :kuangbinCreated Time :2014/7/21 18:20:39File Name :E:\2014ACM\区域赛练习\2012\2012Dhaka\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;char str[1000];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; int n,k; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d%d%s",&amp;n,&amp;k,&amp;str); int ans = 0; for(int i = 0;i &lt; n;i++) &#123; for(int j = 1;j &lt;= k &amp;&amp; j &lt;= i;j++) if(str[i-j] == str[i]) &#123; ans++; break; &#125; &#125; printf("Case %d: %d\n",iCase,ans); &#125; return 0;&#125; D： Laptop Chargers关于第一问，其实只要产生的大于消耗的，就可以一直运行下去。 第二问的时候，要二分时间，然后去判断这个时间产生和消耗的关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* ***************Author :kuangbinCreated Time :2014/7/21 18:25:02File Name :E:\2014ACM\区域赛练习\2012\2012Dhaka\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double eps = 1e-8;struct Node&#123; int C,T,R; void input() &#123; scanf("%d%d%d",&amp;C,&amp;T,&amp;R); &#125;&#125;node[110];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,Q; int iCase = 0; while(scanf("%d%d",&amp;n,&amp;Q) == 2) &#123; if(n == 0 &amp;&amp; Q == 0)break; iCase++; printf("Case %d:\n",iCase); int C; scanf("%d",&amp;C); double sum = 0.0; for(int i = 0;i &lt; n;i++) &#123; node[i].input(); sum += (double)node[i].C/node[i].T; &#125; printf("%d\n",(int)ceil(sum/C)); int m; while(Q--) &#123; scanf("%d",&amp;m); double l = 0, r = 100010.0; while(r-l &gt;= eps) &#123; double mid = (l+r)/2; double tmp = 0.0; for(int i = 0;i &lt; n;i++) tmp += max(0.0,mid*node[i].C/node[i].T-node[i].R); if(tmp &lt;= (double)m*C*mid) l = mid+eps; else r = mid-eps; &#125; if(l &gt;= 100000)printf("-1.000\n"); else printf("%.3lf\n",l); &#125; &#125; return 0;&#125; E: Poker End Games高斯消元求解。 直接建立方程。 然后解方程就可以了。 变量是n+m+1个变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/* ***************Author :kuangbinCreated Time :2014/7/21 19:55:49File Name :E:\2014ACM\区域赛练习\2012\2012Dhaka\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;#define eps 1e-9const int MAXN=330;double a[MAXN][MAXN],x[MAXN];int equ,var;/**返回0表示无解，1表示有解*/int Gauss()&#123; int i,j,k,col,max_r; for(k=0,col=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++) &#123; max_r=k; for(i=k+1;i&lt;equ;i++) if(fabs(a[i][col])&gt;fabs(a[max_r][col])) max_r=i; if(fabs(a[max_r][col])&lt;eps)return 0; if(k!=max_r) &#123; for(j=col;j&lt;var;j++) swap(a[k][j],a[max_r][j]); swap(x[k],x[max_r]); &#125; x[k]/=a[k][col]; for(j=col+1;j&lt;var;j++)a[k][j]/=a[k][col]; a[k][col]=1; for(i=0;i&lt;equ;i++) if(i!=k) &#123; x[i]-=x[k]*a[i][k]; for(j=col+1;j&lt;var;j++)a[i][j]-=a[k][j]*a[i][col]; a[i][col]=0; &#125; &#125; return 1;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; int n,m; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d%d",&amp;n,&amp;m); equ = var = n+m+1; memset(a,0,sizeof(a)); a[0][0] = 1.0; x[0] = 0.0; a[n+m][n+m] = 1.0; x[n+m] = 0.0; for(int i = 1;i &lt; n+m;i++) &#123; a[i][i] = 1.0; x[i] = 1.0; int tmp = min(i,n+m-i); a[i][i-tmp] -= 0.5; a[i][i+tmp] -= 0.5; &#125; Gauss(); double ans1 = x[n]; memset(a,0,sizeof(a)); a[0][0] = 1.0; x[0] = 0.0; a[n+m][n+m] = 1.0; x[n+m] = 1.0; for(int i = 1;i &lt; n+m;i++) &#123; a[i][i] = 1.0; x[i] = 0.0; int tmp = min(i,n+m-i); a[i][i-tmp] -= 0.5; a[i][i+tmp] -= 0.5; &#125; Gauss(); double ans2 = x[n]; printf("Case %d: %.6lf %.6lf\n",iCase,ans1,ans2); &#125; return 0;&#125; F： Overlapping Characters水题。 直接暴力。 就是题意比较麻烦，卧槽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;char str[40][20][50];char s[100];map&lt;char,int&gt;mp;int a[100];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,q; while(scanf("%d%d",&amp;n,&amp;q) == 2) &#123; mp.clear(); scanf("%s",s); for(int i = 0;i &lt; n;i++) mp[s[i]] = i; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; 17;j++) scanf("%s",str[i][j]); for(int k = 0;k &lt; q;k++) &#123; scanf("%s",s); int m = strlen(s); for(int i = 0;i &lt; m;i++) a[i] = mp[s[i]]; printf("Query %d: ",k+1); for(int i = 0;i &lt; m;i++) &#123; bool flag = false; for(int x = 0;x &lt; 16;x++) for(int y = 0;y &lt; 43;y++) &#123; if(flag)break; if(str[a[i]][x][y] == '*') &#123; bool ff = true; for(int j = 0;j &lt; m;j++) if(j != i &amp;&amp; str[a[j]][x][y] == '*') &#123; ff = false; break; &#125; if(ff) &#123; flag = true; break; &#125; &#125; &#125; if(flag)printf("Y"); else printf("N"); &#125; printf("\n"); &#125; &#125; return 0;&#125; G: Reduce the Maintenance Cost首先是进行缩点，把桥都找出来。 其实需要分配的就是这些桥。 缩点以后形成一个有向无环图。 就是很多颗树。 对于每颗树， 桥的分配从下到上。桥尽量分配给底下的点，不能分在分给顶上。 二分答案，然后进行判断。 写起来比较麻烦，非常锻炼代码能力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461/* ***************Author :kuangbinCreated Time :2014/7/21 18:40:44File Name :E:\2014ACM\区域赛练习\2012\2012Dhaka\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10010;//点数const int MAXM = 40010;//边数，因为是无向图，所以这个值要*2struct Edge&#123; int to,next; int w; bool cut;//是否是桥标记 int to_node;&#125;edge[MAXM];int head[MAXN],tot;int Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];//Belong数组的值是1~blockint Index,top;int block;//边双连通块数bool Instack[MAXN];int bridge;//桥的数目void addedge(int u,int v,int w)&#123; edge[tot].to = v;edge[tot].next = head[u];edge[tot].cut=false; edge[tot].w = w; head[u] = tot++;&#125;struct Node//存的是桥相关信息&#123; int u,v; int w; long long val; Node(int _u = 0,int _v = 0,int _w = 0) &#123; u = _u; v = _v; w = _w; &#125;&#125;node[MAXM];void Tarjan(int u,int pre)&#123; int v; Low[u] = DFN[u] = ++Index; Stack[top++] = u; Instack[u] = true; for(int i = head[u];i != -1;i = edge[i].next) &#123; v = edge[i].to; if(v == pre)continue; if( !DFN[v] ) &#123; Tarjan(v,u); if( Low[u] &gt; Low[v] )Low[u] = Low[v]; if(Low[v] &gt; DFN[u]) &#123; node[bridge] = Node(u,v,edge[i].w); edge[i].to_node = bridge;//根据边的编号指向桥的编号 edge[i^1].to_node = bridge; bridge++; edge[i].cut = true; edge[i^1].cut = true; &#125; &#125; else if( Instack[v] &amp;&amp; Low[u] &gt; DFN[v] ) Low[u] = DFN[v]; &#125; if(Low[u] == DFN[u]) &#123; block++; do &#123; v = Stack[--top]; Instack[v] = false; Belong[v] = block; &#125; while( v!=u ); &#125;&#125;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;vector&lt;int&gt;vec[MAXN];//存的缩点后的图vector&lt;int&gt;vec2[MAXN];//缩点后的图边对于的桥的编号int dep[MAXN];//深度int num[MAXN];//连通块大小int tot_num[MAXN];//缩点后子树大小void dfs(int u,int pre,int d)//计算深度，以及子树大小&#123; dep[u] = d; tot_num[u] = num[u]; int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++) &#123; int v = vec[u][i]; if(v == pre)continue; dfs(v,u,d+1); tot_num[u] += tot_num[v]; &#125;&#125;int TOT;void dfs2(int u,int pre)//算每个桥的信息&#123; int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++) &#123; int v = vec[u][i]; if(v == pre)continue; int id = vec2[u][i]; node[id].val = (long long)node[id].w*tot_num[v]*(TOT-tot_num[v]); dfs2(v,u); &#125;&#125;bool cmp(Node a,Node b)//按照深度从大到小排序&#123; return dep[Belong[a.v]] &gt; dep[Belong[b.v]];&#125;int iv[MAXN];long long pv[MAXN];void solve(int n)&#123; memset(DFN,0,sizeof(DFN)); memset(Instack,false,sizeof(Instack)); Index = top = block = 0; bridge = 0; for(int i = 1;i &lt;= n;i++) if(DFN[i] == 0) Tarjan(i,0); for(int i = 1;i &lt;= block;i++) &#123; vec[i].clear(); vec2[i].clear(); &#125; for(int i = 1;i &lt;= n;i++) for(int j = head[i];j != -1;j = edge[j].next) if(edge[j].cut) &#123; vec[Belong[i]].push_back(Belong[edge[j].to]); vec2[Belong[i]].push_back(edge[j].to_node); &#125; memset(num,0,sizeof(num)); for(int i = 1;i &lt;= n;i++) num[Belong[i]]++; memset(dep,-1,sizeof(dep)); for(int i = 1;i &lt;= block;i++) if(dep[i] == -1) &#123; dfs(i,-1,0); TOT = tot_num[i]; dfs2(i,-1); &#125; for(int i = 0;i &lt; bridge;i++) &#123; if(dep[Belong[node[i].u]] &gt; dep[Belong[node[i].v]]) swap(node[i].u,node[i].v); &#125; sort(node,node+bridge,cmp); //二分答案 long long ans; long long l = 0; long long r = 1000000000000000000LL; for(int i = 1;i &lt;= n;i++) if(iv[i] &gt; l) l = iv[i]; while(l &lt;= r) &#123; long long mid = (l+r)/2; for(int i = 1;i &lt;= n;i++) pv[i] = iv[i]; bool flag = true; for(int i = 0;i &lt; bridge;i++) &#123; if(pv[node[i].v] + node[i].val &lt;= mid) pv[node[i].v] += node[i].val; else if(pv[node[i].u] + node[i].val &lt;= mid) pv[node[i].u] += node[i].val; else &#123; flag = false; break; &#125; &#125; if(flag) &#123; ans = mid; r = mid-1; &#125; else l = mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n,m; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; init(); scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;iv[i]); int u,v,w; while(m--) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addedge(u,v,w); addedge(v,u,w); &#125; printf("Case %d: ",iCase); solve(n); &#125; return 0;&#125; H： Team Mathematics Olympiad典型的概率DP。 状态压缩去表示每个人答了多少题，以及前一题是答对还是答错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;const double INF = 1e30;double p[10][100];bool f[100];double dp[1100000][2];bool vis[1100000][2];int base;int n,m;int encode(int a[])&#123; int ret = 0; for(int i = 0;i &lt; n;i++) &#123; ret *= base; ret += a[i]; &#125; return ret;&#125;void decode(int a[],int s)&#123; for(int i = n-1;i &gt;= 0;i--) &#123; a[i] = s%base; s /= base; &#125;&#125;double solve(int s,int pre)&#123; if(vis[s][pre])return dp[s][pre]; vis[s][pre] = true; int num[10]; decode(num,s); int tot = 0; for(int i = 0;i &lt; n;i++) tot += num[i]; if(tot == m) &#123; int Max = num[0],Min = num[0]; for(int i = 1;i &lt; n;i++) &#123; Max = max(Max,num[i]); Min = min(Min,num[i]); &#125; if(Max - Min &gt; 1)return dp[s][pre] = -INF; else return dp[s][pre] = 0.0; &#125; dp[s][pre] = -INF; for(int i = 0;i &lt; n;i++) &#123; if(num[i]+1 &gt;= base)continue; num[i]++; int ns = encode(num); if(solve(ns,0) &lt; -10) &#123; num[i]--; continue; &#125; double pp = p[i][tot]; if(f[tot] &amp;&amp; pre == 0) pp = 0; dp[s][pre] = max(dp[s][pre],solve(ns,0)(1-pp) + (solve(ns,1)+1)pp); num[i]--; &#125; return dp[s][pre];&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int iCase = 0; scanf("%d",&amp;T); while(T--) &#123; iCase++; scanf("%d%d",&amp;n,&amp;m); memset(f,false,sizeof(f)); int nn;int u; scanf("%d",&amp;nn); while(nn--) &#123; scanf("%d",&amp;u); u--; f[u] = true; &#125; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) scanf("%lf",&amp;p[i][j]); base = m/n; if(m%n)base += 2; else base++; memset(vis,false,sizeof(vis)); printf("Case %d: %.4lf\n",iCase,solve(0,0)); &#125; return 0;&#125; I： Learning Vector按照顺序进行排序。 之后就是简单的DP了。 很简单的题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* ***************Author :kuangbinCreated Time :2014/7/21 20:11:55File Name :E:\2014ACM\区域赛练习\2012\2012Dhaka\I.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;struct Node&#123; int x,y;&#125;node[100];bool cmp(Node a,Node b)&#123; return a.y*b.x &gt; a.x*b.y;&#125;int dp[55][55][3000];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n,k; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; int sum = 0; scanf("%d%d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d%d",&amp;node[i].x,&amp;node[i].y); sum += node[i].y; &#125; sort(node+1,node+n+1,cmp); memset(dp,-1,sizeof(dp)); dp[0][0][0] = 0; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt;= k &amp;&amp; j &lt;= i;j++) for(int L = 0;L &lt;= sum;L++) &#123; if(dp[i][j][L] &lt; 0)continue; dp[i+1][j][L] = max(dp[i+1][j][L],dp[i][j][L]); if(j &lt; k) dp[i+1][j+1][L+node[i+1].y] = max(dp[i+1][j+1][L+node[i+1].y],dp[i][j][L]+L*node[i+1].x*2+node[i+1].x*node[i+1].y); &#125; int ans = 0; for(int i = 0;i &lt;= sum;i++) ans = max(ans,dp[n][k][i]); printf("Case %d: %d\n",iCase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>套题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4859 海岸线（最小割）]]></title>
    <url>%2F2014%2F07%2F21%2Fhdu4859%2F</url>
    <content type="text"><![CDATA[HDU 4859海岸线题目链接：here 海岸线Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 44 Accepted Submission(s): 7 Problem Description 欢迎来到珠海！ 由于土地资源越来越紧张，使得许多海滨城市都只能依靠填海来扩展市区以求发展。作为Z市的决策人，在仔细观察了Z市地图之后，你准备通过填充某些海域来扩展Z市的海岸线到最长，来吸引更多的游客前来旅游度假。为了简化问题，假设地图为一个N*M的格子，其中一些是陆地，一些是可以填充的浅海域，一些是不可填充的深海域。这里定义海岸线的长度为一个联通块陆地（可能包含浅海域填充变为的陆地）的边缘长度，两个格子至少有一个公共边，则视为联通。 值得注意的是，这里Z市的陆地区域可以是不联通的，并且整个地图都处在海洋之中，也就是说，Z市是由一些孤岛组成的，比如像，夏威夷？ 你的任务是，填充某些浅海域，使得所有岛屿的海岸线之和最长。 Input 输入第一行为T，表示有T组测试数据。 每组数据以两个整数N和M开始，表示地图的规模。接下来的N行，每一行包含一个长度为M的字符串，表示地图，‘.’表示陆地，’E’表示浅海域，’D’表示深海域。 [Technical Specification] 1. 1 &lt;= T &lt;= 100 2. 1 &lt;= N, M &lt;= 47 Output 对每组数据，先输出为第几组数据，然后输出最长的海岸线长度。 Sample Input 32 2EEEE3 3EEE.E.EEE3 3EEEDEDEEE Sample Output Case 1: 8Case 2: 16Case 3: 20Hint 对于第三组样例，一种可行方案是： .E.D.D.E. 这样5个孤立小岛的海岸线总长为4 * 5 = 20。 Author Isea@WHU 题目是中文的，题意不再赘述。直接搞。.是陆地，D是海，E的话可以变成.或者D. 要求.的连通块组成的周长最长，其实就是相邻两个格子.E不同的个数要最多。 因为E有两个选择D或者. 其实就暗含了最小割的模型。 最小割的话，就是一部分分到源点一侧，一部分分到汇点一侧。 如果把源点分在一起当成是. 和汇点分在一起当成是D. 那么建图的时候，相邻的建流量为1的边。 如果这个点本来是. 那个连汇点是INF，本来是D的，连源点是INF。 如果是这种建图的话，最小割求出来的最小周长。 我们需要的最大周长。 稍微转化下。 我们希望相邻格子不同的最多，其实就是要相邻格子相同的最少。 所以用最小割来求相邻格子相同的最小值，然后总相邻数减掉这个就是答案了。 建图方法就是一开始进行奇偶染色。相当于对于点(x,y) 如果(x+y)%2 == 0 那么当成这个格子是 . 的，和源点分在一起。 如果(x+y)%2 == 1 那么当成这个格子是 D 的，和汇点分在一起。 相邻两点都建边。 这样建图的话，如果在源点一侧的跑到了汇点一侧，那么就相当于这个点从.变到D, 自然相同的数量要减少了、 汇点一侧的跑到了源点一侧，那么就相当于这个点从D变成了. 建图的时候，如果(x+y)%2==0 &amp;&amp; 这个点本来就是D 或者 (x+y)%2 == 1 &amp;&amp; 这个点本来就是. 那么这个点必须和汇点在一起，就把这个点和源点连INF的边。 相反情况类似处理。 这样建图出来的最小割，一定就是相邻格子是同一类的最小数量。总相邻减掉这个值就是答案了。 具体参见code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307/* ***************Author :kuangbinCreated Time :2014/7/21 11:52:20File Name :E:\2014ACM\HDU\HDU4859.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10010;const int MAXM = 100010;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];int tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u]; edge[tol].flow = 0; head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v]; edge[tol].flow = 0;head[v] = tol++;&#125;int sap(int start,int end,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; for(int i = pre[u];i != -1;i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u];i != -1;i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; &#125; u = start; ans += Min; continue; &#125; bool flag = false; int v; for(int i = cur[u];i != -1;i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = pre[v] = i; break; &#125; &#125; if(flag) &#123; u = v; continue; &#125; int Min = N; for(int i = head[u];i != -1;i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start)u = edge[pre[u]^1].to; &#125; return ans;&#125;char g[100][100];int id[100][100];int Move[][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n,m; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) scanf("%s",g[i]+1); for(int i = 0;i &lt;= m+1;i++) &#123; g[0][i] = 'D'; g[n+1][i] = 'D'; &#125; for(int i = 1;i &lt;= n;i++) &#123; g[i][0] = 'D'; g[i][m+1] = 'D'; &#125; int cnt = 0; for(int i= 0;i &lt;= n+1;i++) for(int j = 0;j &lt;= m+1;j++) id[i][j] = ++cnt; init(); int start = 0, end = cnt+1; int ans = 0; for(int i = 0;i &lt;= n+1;i++) for(int j = 0;j &lt;= m+1;j++) &#123; for(int k = 0;k &lt; 4;k++) &#123; int x = i + Move[k][0]; int y = j + Move[k][1]; if(x &lt; 0 || x &gt; n+1 || y &lt; 0 || y &gt; m+1)continue; ans++; addedge(id[i][j],id[x][y],1); &#125; if(g[i][j] != 'E') &#123; if( ((i+j)%2 == 1 &amp;&amp; g[i][j] == '.') || ((i+j)%2 == 0 &amp;&amp; g[i][j] == 'D') ) addedge(start,id[i][j],INF); else addedge(id[i][j],end,INF); &#125; &#125; printf("Case %d: %d\n",iCase,ans/2-sap(start,end,cnt+2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regionals 2011 :: North America - Southeast USA]]></title>
    <url>%2F2014%2F07%2F16%2F2011seu%2F</url>
    <content type="text"><![CDATA[题目链接：UVALiveVJ比赛链接：VJA题。 水题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/* ***************Author :kuangbinCreated Time :2014/7/15 19:13:25File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const double pi = acos(-1.0);double dp[1010][12];int main()&#123; //freopen("drive-000.inp","r",stdin); //freopen("out.txt","w",stdout); int n,m; while(scanf("%d%d",&amp;n,&amp;m) == 2) &#123; if(n == 0 &amp;&amp; m == 0)break; double k; char op[10]; for(int i = 1;i &lt;= n;i++) &#123; scanf("%s%lf",op,&amp;k); if(i == 1) &#123; if(op[0] == 'S') &#123; for(int j = 0;j &lt; m;j++) dp[i][j] = k; &#125; else if(op[0] == 'L') &#123; for(int j = 0;j &lt; m;j++) dp[i][j] = pi/2(k+5+j10); &#125; else &#123; for(int j = 0;j &lt; m;j++) dp[i][j] = pi/2(k+5+(m-1-j)10); &#125; &#125; else &#123; if(op[0] == 'S') &#123; for(int j = 0;j &lt; m;j++) dp[i][j] = dp[i-1][j]+k; for(int j = 0;j &lt; m;j++) for(int x = 0;x &lt; m;x++) &#123; double tmp = abs(j-x)*100; if(tmp &gt; k+0.01)continue; dp[i][j] = min(dp[i][j],dp[i-1][x]+sqrt(k*k + 10.0*10.0*abs(j-x)*abs(j-x))); &#125; &#125; else if(op[0] == 'L') &#123; for(int j = 0;j &lt; m;j++) dp[i][j] = dp[i-1][j] + pi/2(k+5+j10); &#125; else &#123; for(int j = 0;j &lt; m;j++) dp[i][j] = dp[i-1][j] + pi/2(k+5+(m-1-j)10); &#125; &#125; &#125; double ans = dp[n][0]; for(int i = 1;i &lt; m;i++) ans = min(ans,dp[n][i]); printf("%.2lf\n",ans); &#125; return 0;&#125; B: 暴力搞一下就OK了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/* ***************Author :kuangbinCreated Time :2014/7/15 21:22:19File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int a[12];struct Node&#123; int x,y,z; Node(int _x=0,int _y = 0,int _z = 0) &#123; x = _x; y = _y; z = _z; &#125;&#125;;vector&lt;Node&gt;V;bool used[12];bool used2[12];int A[3],B[3],C[5];int sum;bool check1()&#123; return a[C[0]]+a[A[0]]+a[B[0]]+a[C[1]] == sum &amp;&amp; a[C[0]]+a[A[1]]+a[C[2]]+a[C[4]] == sum &amp;&amp; a[C[1]]+a[B[1]]+a[C[3]]+a[C[4]] == sum &amp;&amp; a[A[2]]+a[C[2]]+a[C[3]]+a[B[2]] == sum;&#125;bool check2()&#123; return a[A[0]]+a[B[1]]+a[C[1]]+a[C[4]] == sum &amp;&amp; a[A[2]]+a[C[0]]+a[C[2]]+a[C[4]] == sum &amp;&amp; a[B[0]]+a[A[1]]+a[C[0]]+a[C[3]] == sum &amp;&amp; a[B[2]]+a[C[1]]+a[C[2]]+a[C[3]] == sum;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(1) &#123; sum = 0; for(int i = 0;i &lt; 12;i++) &#123; scanf("%d",&amp;a[i]); sum += a[i]; &#125; if(sum == 0)break; if(sum % 3 != 0) &#123; printf("0\n"); continue; &#125; sum /= 3; V.clear(); for(int i = 1;i &lt; 12;i++) for(int j = 1;j &lt; i;j++) for(int k = 1;k &lt; j;k++) if(a[i]+a[j]+a[k]+a[0] == sum) V.push_back(Node(k,j,i)); int sz = V.size(); int ans = 0; for(int i = 0;i &lt; sz;i++) &#123; memset(used,false,sizeof(used)); A[0] = V[i].x; A[1] = V[i].y; A[2] = V[i].z; used[A[0]] = used[A[1]] = used[A[2]] = true; for(int j = 0;j &lt; i;j++) if(!used[V[j].x] &amp;&amp; !used[V[j].y] &amp;&amp; !used[V[j].z]) &#123; B[0] = V[j].x; B[1] = V[j].y; B[2] = V[j].z; memset(used2,false,sizeof(used2)); used2[A[0]] = used2[A[1]] = used2[A[2]] = true; used2[B[0]] = used2[B[1]] = used2[B[2]] = true; int cnt = 0; for(int k = 1;k &lt; 12;k++) if(!used2[k]) C[cnt++] = k; do &#123; do &#123; do &#123; if(check1())ans++; if(check2())ans++; &#125; while(next_permutation(C,C+5)); &#125; while(next_permutation(B,B+3)); &#125; while(next_permutation(A,A+3)); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; C: Flooring Tiles分两种情况，如果是平方数，约数个数就是2*n-1 如果是非平方数，约数个数就是2*n. 然后暴力去搜就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt;yueshu[200];int prime[] = &#123;2,3,5,7,11,13,17,19&#125;;unsigned long long ans;bool squ;void solve(unsigned long long now,int pos,int n,int last,bool flag)&#123; if(now &gt;= ans)return; if(n == 1) &#123; if(now &lt; ans &amp;&amp; flag == squ)ans = now; return; &#125; int sz = yueshu[n].size(); for(int i = 0;i &lt; sz;i++) &#123; if(yueshu[n][i] &gt; last)break; int v = yueshu[n][i]; if(squ &amp;&amp; v%2 != 1)continue; unsigned long long nxt = now; for(int j = 0;j &lt; v-1;j++) &#123; if((double)nxt &gt; (double)ans/prime[pos] + 10)return; nxt *= prime[pos]; if(nxt &gt; ans) &#123; return; &#125; &#125; solve(nxt,pos+1,n/v,v,flag &amp;&amp; v%2 == 1); &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; for(int i = 2;i &lt; 200;i++) &#123; for(int j = 2;j &lt;= i;j++) if(i%j == 0) yueshu[i].push_back(j); &#125; while(scanf("%d",&amp;n) ==1 &amp;&amp; n) &#123; ans = 1000000000000000000LL + 10; squ = true; solve(1,0,2*n-1,200,1); squ = false; solve(1,0,2*n,200,1); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; D： Vive la Difference!水题了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int a,b,c,d; while(scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d) == 4) &#123; if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0) break; int ans = 0; while(1) &#123; if(a == b &amp;&amp; c == b &amp;&amp; d == c)break; ans++; int na = abs(a-b); int nb = abs(b-c); int nc = abs(c-d); int nd = abs(d-a); a = na; b = nb; c = nc; d = nd; &#125; printf("%d\n",ans); &#125; return 0;&#125; E: Robot Navigation就是BFS的水题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309/* ***************Author :kuangbinCreated Time :2014/7/15 23:22:33File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\E.cpp ************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MOD = 1000000;int Move[][2] = &#123; &#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;char g[110][110];int n,m;int sx,sy,sd;int ex,ey;int dp1[110][110][4];int dp2[110][110][4];struct Node&#123; int x,y; int d; Node(int _x = 0,int _y = 0,int _d = 0) &#123; x = _x; y = _y; d = _d; &#125;&#125;;bool check(int x,int y)&#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] != '*';&#125;void bfs()&#123; queue&lt;Node&gt;q; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) for(int k = 0;k &lt; 4;k++) &#123; dp1[i][j][k] = INF; dp2[i][j][k] = 0; &#125; q.push(Node(sx,sy,sd)); dp1[sx][sy][sd] = 0; dp2[sx][sy][sd] = 1; while(!q.empty()) &#123; Node tmp = q.front(); q.pop(); int x = tmp.x; int y = tmp.y; x += Move[tmp.d][0]; y += Move[tmp.d][1]; while(check(x,y)) &#123; if(dp1[x][y][tmp.d] &gt; dp1[tmp.x][tmp.y][tmp.d]+1) &#123; dp1[x][y][tmp.d] = dp1[tmp.x][tmp.y][tmp.d]+1; dp2[x][y][tmp.d] = dp2[tmp.x][tmp.y][tmp.d]; q.push(Node(x,y,tmp.d)); &#125; else if(dp1[x][y][tmp.d] == dp1[tmp.x][tmp.y][tmp.d]+1) &#123; dp2[x][y][tmp.d] += dp2[tmp.x][tmp.y][tmp.d]; if(dp2[x][y][tmp.d] &gt;= MOD) dp2[x][y][tmp.d] -= MOD; &#125; x += Move[tmp.d][0]; y += Move[tmp.d][1]; &#125; if(dp1[tmp.x][tmp.y][(tmp.d+1)%4] &gt; dp1[tmp.x][tmp.y][tmp.d]+1) &#123; dp1[tmp.x][tmp.y][(tmp.d+1)%4] = dp1[tmp.x][tmp.y][tmp.d]+1; dp2[tmp.x][tmp.y][(tmp.d+1)%4] = dp2[tmp.x][tmp.y][tmp.d]; q.push(Node(tmp.x,tmp.y,(tmp.d+1)%4)); &#125; else if(dp1[tmp.x][tmp.y][(tmp.d+1)%4] == dp1[tmp.x][tmp.y][tmp.d]+1) &#123; dp2[tmp.x][tmp.y][(tmp.d+1)%4] += dp2[tmp.x][tmp.y][tmp.d]; if(dp2[tmp.x][tmp.y][(tmp.d+1)%4] &gt;= MOD) dp2[tmp.x][tmp.y][(tmp.d+1)%4] -= MOD; &#125; if(dp1[tmp.x][tmp.y][(tmp.d+3)%4] &gt; dp1[tmp.x][tmp.y][tmp.d]+1) &#123; dp1[tmp.x][tmp.y][(tmp.d+3)%4] = dp1[tmp.x][tmp.y][tmp.d]+1; dp2[tmp.x][tmp.y][(tmp.d+3)%4] = dp2[tmp.x][tmp.y][tmp.d]; q.push(Node(tmp.x,tmp.y,(tmp.d+3)%4)); &#125; else if(dp1[tmp.x][tmp.y][(tmp.d+3)%4] == dp1[tmp.x][tmp.y][tmp.d]+1) &#123; dp2[tmp.x][tmp.y][(tmp.d+3)%4] += dp2[tmp.x][tmp.y][tmp.d]; if(dp2[tmp.x][tmp.y][(tmp.d+3)%4] &gt;= MOD) dp2[tmp.x][tmp.y][(tmp.d+3)%4] -= MOD; &#125; &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d%d",&amp;n,&amp;m) == 2) &#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0;i &lt; n;i++) &#123; scanf("%s",g[i]); for(int j = 0;j &lt; m;j++) &#123; if(g[i][j] == 'X') &#123; ex = i; ey = j; &#125; else if(g[i][j] == 'N' || g[i][j] == 'E' || g[i][j] == 'S' || g[i][j] == 'W') &#123; sx = i; sy = j; if(g[i][j] == 'N')sd = 0; else if(g[i][j] == 'E')sd = 1; else if(g[i][j] == 'S')sd = 2; else sd = 3; &#125; &#125; &#125; bfs(); int ans1 = INF; int ans2 = 0; for(int i = 0;i &lt; 4;i++) &#123; if(dp1[ex][ey][i] &lt; ans1) &#123; ans1 = dp1[ex][ey][i]; ans2 = dp2[ex][ey][i]; &#125; else if(dp1[ex][ey][i] == ans1) &#123; ans2 += dp2[ex][ey][i]; if(ans2 &gt;= MOD) ans2 -= MOD; &#125; &#125; if(ans1 == INF)ans1 = 0; printf("%d %d\n",ans1,ans2); &#125; return 0;&#125; F: Folding Game一个折纸问题。 直接写个dfs就解决了，注意细节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/* ***************Author :kuangbinCreated Time :2014/7/16 18:33:53File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int W[30],H[30];char op[30][10];int K[30];int dfs(int n,int x,int y)&#123; if(n == 0)return 1; int ans = 0; if(op[n][0] == 'T') &#123; int tmp = H[n] - y; if(K[n] &gt; tmp)ans += dfs(n-1,x,H[n-1]-(K[n]-tmp)); if(H[n-1]-K[n] &gt; tmp)ans += dfs(n-1,x,H[n-1]-K[n]-tmp); &#125; else if(op[n][0] == 'B') &#123; if(K[n] &gt; y)ans += dfs(n-1,x,K[n]-y); if(H[n-1]-K[n] &gt; y)ans += dfs(n-1,x,y+K[n]); &#125; else if(op[n][0] == 'L') &#123; if(K[n] &gt; x)ans += dfs(n-1,K[n]-x,y); if(W[n-1]-K[n] &gt; x)ans += dfs(n-1,K[n]+x,y); &#125; else &#123; int tmp = W[n]-x; if(K[n] &gt; tmp)ans += dfs(n-1,W[n-1]-(K[n]-tmp),y); if(W[n-1]-K[n] &gt; tmp)ans += dfs(n-1,W[n-1]-K[n]-tmp,y); &#125; return ans;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d%d%d",&amp;W[0],&amp;H[0],&amp;n) == 3) &#123; if(W[0] == 0 &amp;&amp; H[0] == 0 &amp;&amp; n == 0)break; for(int i = 1;i &lt;= n;i++) &#123; scanf("%s%d",op[i],&amp;K[i]); if(op[i][0] == 'T' || op[i][0] == 'B') &#123; W[i] = W[i-1]; H[i] = max(K[i],H[i-1]-K[i]); &#125; else &#123; H[i] = H[i-1]; W[i] = max(K[i],W[i-1]-K[i]); &#125; &#125; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",dfs(n,x,y)); &#125; return 0;&#125; H: Family Fortune一颗树上，要选择k个节点，这k个节点没有祖先和后代关系。 要求k个点的值的和最大。 可以发现当一个点选择一个，它子树下面，和它上面的点都不能选了。 所以按照dfs的顺序进行DP，要么选子树，要么选当前点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/* ***************Author :kuangbinCreated Time :2014/7/16 19:47:08File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\H.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;struct Edge&#123; int to,next;&#125;edge[MAXN];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int W[MAXN];int n,k;int dp[1010][1010];void dfs(int u,int dep)&#123; for(int i = 0;i &lt;= k;i++) dp[dep+1][i] = dp[dep][i]; for(int i = head[u];i != -1;i = edge[i].next) dfs(edge[i].to,dep+1); for(int i = k-1;i &gt;= 0;i--) if(dp[dep][i] &gt; -1 &amp;&amp; dp[dep][i]+W[u] &gt; dp[dep][i+1]) dp[dep][i+1] = dp[dep][i]+W[u]; for(int i = 0;i &lt;= k;i++) if(dp[dep+1][i] &gt; dp[dep][i]) dp[dep][i] = dp[dep+1][i];&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d%d",&amp;n,&amp;k) == 2) &#123; if(n == 0 &amp;&amp; k == 0)break; int root; int u; init(); for(int i = 1;i &lt;= n;i++) &#123; scanf("%d%d",&amp;u,&amp;W[i]); if(u == 0)root = i; else addedge(u,i); &#125; memset(dp[0],-1,sizeof(dp[0])); dp[0][0] = 0; dfs(root,0); if(dp[0][k] == -1)printf("0\n"); else printf("%d\n",dp[0][k]); &#125; return 0;&#125; I: Moving Points状态压缩DP。 直接状压，以及当前在哪个点。 然后直接相对速度去求就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;const int MAXN = 16;double X[MAXN],Y[MAXN],D[MAXN],S[MAXN];const double PI = acos(-1.0);struct Point&#123; double x,y; Point(double _x = 0,double _y = 0) &#123; x = _x; y = _y; &#125; double operator ^(const Point &amp;b)const &#123; return x*b.y-y*b.x; &#125; double operator *(const Point &amp;b)const &#123; return x*b.x + y*b.y; &#125;&#125;;double calc(double x0,double y0,double x1,double y1,double dx,double dy,double C,double S)&#123; Point p1 = Point(x1-x0,y1-y0); Point p2 = Point(-dx,-dy); double jiao = atan2(fabs(p1^p2),p1*p2); double a = 1; double b = -2*S*cos(jiao); double c = S*S - C*C; double deta = b*b - 4*a*c; double tmp = (-b+sqrt(deta))/(2.0*a); double s = sqrt((x0-x1)(x0-x1) + (y0-y1)(y0-y1)); return s/tmp;&#125;double dp[MAXN][1&lt;&lt;MAXN];const double INF = 1e20;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; double C; while(scanf("%d%lf",&amp;n,&amp;C) == 2) &#123; if(n == 0 &amp;&amp; C == 0)break; for(int i = 0;i &lt; n;i++) scanf("%lf%lf%lf%lf",&amp;X[i],&amp;Y[i],&amp;D[i],&amp;S[i]); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; (1&lt;&lt;n);j++) dp[i][j] = INF; for(int i = 0;i &lt; n;i++) &#123; dp[i][1&lt;&lt;i] = calc(0.0,0.0,X[i],Y[i],cos(D[i]/180.0*PI),sin(D[i]/180.0*PI),C,S[i]); &#125; int tot = (1&lt;&lt;n); for(int j = 0;j &lt; tot;j++) for(int i = 0;i &lt; n;i++) if(j&amp;(1&lt;&lt;i)) &#123; double nx = S[i]*cos(D[i]/180.0*PI)*dp[i][j] + X[i]; double ny = S[i]*sin(D[i]/180.0*PI)*dp[i][j] + Y[i]; for(int k = 0;k &lt; n;k++) if((j&amp;(1&lt;&lt;k)) == 0) &#123; double tx = S[k]*cos(D[k]/180.0*PI)*dp[i][j] + X[k]; double ty = S[k]*sin(D[k]/180.0*PI)*dp[i][j] + Y[k]; dp[k][j^(1&lt;&lt;k)] = min(dp[k][j^(1&lt;&lt;k)],dp[i][j] + calc(nx,ny,tx,ty,cos(D[k]/180.0*PI),sin(D[k]/180.0*PI),C,S[k])); &#125; &#125; double ans = INF; for(int i = 0;i &lt; n;i++) ans = min(ans,dp[i][tot-1]); printf("%.2lf\n",ans); &#125; return 0;&#125; J: Vampire Numbers暴力搞就可以了。 姿势写不好就容易T。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/* ***************Author :kuangbinCreated Time :2014/7/16 21:06:34File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\J.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int num1[10],num2[10];bool check(int u,int a,int b)&#123; memset(num1,0,sizeof(num1)); memset(num2,0,sizeof(num2)); while(u) &#123; num1[u%10]++; u /= 10; &#125; while(a) &#123; num2[a%10]++; a /= 10; &#125; while(b) &#123; num2[b%10]++; b /= 10; &#125; for(int i = 0;i &lt; 10;i++) if(num1[i] != num2[i]) return false; return true;&#125;bool check(int n)&#123; for(int i = 1;i*i &lt;= n;i++) if(n%i == 0) if(check(n,i,n/i)) return true; return false;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1 &amp;&amp; n) &#123; while(1) &#123; if(check(n)) &#123; printf("%d\n",n); break; &#125; n++; &#125; &#125; return 0;&#125; 当然，这题也可以打表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/* ***************Author :kuangbinCreated Time :2014/7/16 21:06:34File Name :E:\2014ACM\区域赛练习\2011\2011Southeast_USA\J.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int num1[10],num2[10];bool check(int u,int a,int b)&#123; memset(num1,0,sizeof(num1)); memset(num2,0,sizeof(num2)); while(u) &#123; num1[u%10]++; u /= 10; &#125; while(a) &#123; num2[a%10]++; a /= 10; &#125; while(b) &#123; num2[b%10]++; b /= 10; &#125; for(int i = 0;i &lt; 10;i++) if(num1[i] != num2[i]) return false; return true;&#125;bool check(int n)&#123; for(int i = 1;i*i &lt;= n;i++) if(n%i == 0) if(check(n,i,n/i)) return true; return false;&#125;int a[]=&#123;126,153,688,1206,1255,1260,1395,1435,1503,1530,1827,2187,3159,3784,6880,10251,10255,10426,10521,10525,10575,11259,11844,11848,12006,12060,12384,12505,12546,12550,12595,12600,12762,12843,12955,12964,13243,13545,13950,14035,14350,15003,15030,15246,15300,15435,15624,15795,16272,17325,17428,17437,17482,18225,18265,18270,19026,19215,21375,21586,21753,21870,25105,25375,25474,25510,28476,29632,31509,31590,33655,33696,36855,37840,37845,39784,41665,42898,44676,45684,45760,45864,47538,48672,49855,51759,52168,53865,56295,56875,62968,63895,67149,67392,67950,68800,71199,78975,100255,100525,101299,102051,102505,102510,102541,102550,102595,102942,102955,103968,104026,104260,104368,105021,105025,105075,105210,105250,105264,105295,105723,105750,107163,107329,108126,108135,108216,108612,108864,109525,110758,112468,112509,112590,114268,115672,115699,116478,116496,116725,116928,117067,118408,118440,118480,118575,118926,119848,120006,120060,120384,120600,120762,120843,121086,121576,121815,122746,122764,123084,123354,123538,123840,123894,124483,124488,124542,124978,125005,125050,125095,125248,125433,125460,125500,125950,125995,126000,126027,126108,126846,127417,127620,128403,128430,128943,129438,129505,129514,129550,129564,129595,129640,129775,129955,131242,132430,132565,132615,132655,133245,134275,134725,135045,135450,135828,135837,136525,136854,136948,138784,139500,139824,140035,140350,141345,142978,143500,143739,143793,145273,145314,145345,145683,146137,146520,146952,149364,149782,150003,150030,150246,150300,150435,150624,150826,152271,152406,152460,152608,152685,152946,153000,153436,154350,155277,156024,156240,156289,156325,156915,157950,158193,162072,162526,162720,162976,163255,163795,163854,163944,164583,165208,168520,171598,172246,172386,172822,173250,173925,174028,174082,174208,174280,174298,174370,174793,174802,174820,174982,175329,176215,178294,178942,179325,179428,179482,180225,180297,180621,182065,182250,182650,182700,182974,184126,186624,187029,189702,189742,190260,190827,191205,192150,192375,192685,192717,193257,193945,194229,197428,197482,197725,201852,205785,207391,208624,210375,210681,210753,211896,212868,213075,213466,213750,213759,214506,215086,215424,215455,215860,216733,217503,217530,217638,217854,218488,218700,223524,226498,226872,226876,227448,229648,231579,231673,233896,236754,236758,236925,238968,241506,241564,243175,245182,245448,246150,246928,250105,250510,251005,251050,251095,251896,253750,254740,255010,255100,256315,256410,256414,258795,259510,260338,261378,261783,262984,263074,263155,263736,267034,268398,279328,281736,283198,283648,284598,284760,285376,286416,286974,287356,289674,291375,291753,293625,295105,295510,296320,297463,297832,304717,307183,312475,312565,312655,312975,314199,314743,315009,315090,315490,315594,315625,315900,316255,319059,319536,325615,326155,326452,328419,328864,329346,329656,336195,336550,336960,338296,341284,341653,342688,346288,346725,346968,347913,352966,355995,361989,362992,365638,368104,368550,368784,369189,371893,373864,375156,375615,376992,378400,378418,378450,381429,384912,384925,386415,390847,392566,393246,393417,394875,397840,399784,404932,404968,414895,415575,416065,416259,416650,416988,419287,428980,429664,435784,439582,442975,446760,446976,447916,449676,449955,450688,451768,456840,457168,457600,458640,462672,465088,465984,468535,475380,475893,476892,486720,488592,489159,489955,490176,491688,493857,495328,497682,498550,515907,516879,517509,517590,519745,520168,520816,521608,521680,526792,529672,530379,531297,535968,536539,538650,549765,559188,562950,564912,567648,568750,571648,573768,588676,611793,611878,612598,614965,617728,618759,623758,629680,632875,638950,649638,661288,665919,667876,671409,671490,671944,673920,678892,679500,687919,688000,692712,697248,702189,702918,710496,711099,711909,711990,715959,719199,729688,736695,738468,741928,769792,773896,778936,782896,785295,789250,789525,789750,791289,792585,794088,798682,809919,809937,809964,815958,829696,841995,859968,899019,936985,939658,960988,1000255,1000525,1002501,1002505,1002550,1002595,1002955,1004251,1005025,1005201,1005250,1005295,1008126,1009525,1012099,1012198,1012297,1012396,1012495,1012581,1012594,1012693,1012792,1012891,1012990,1014975,1016568,1016635,1017382,1019722,1020051,1020510,1020537,1021968,1021999,1024555,1024582,1024884,1025005,1025041,1025046,1025050,1025095,1025100,1025410,1025500,1025779,1025950,1025995,1029042,1029420,1029505,1029550,1029595,1029955,1031899,1032565,1032655,1032876,1039680,1040026,1040260,1040368,1041799,1042353,1042542,1042600,1043680,1043968,1045296,1046209,1050021,1050025,1050075,1050210,1050250,1050295,1050750,1051263,1051533,1051699,1052100,1052235,1052500,1052640,1052950,1052995,1053153,1053265,1053315,1057108,1057162,1057230,1057500,1058715,1058890,1061599,1062247,1062517,1063251,1064254,1065325,1065748,1066572,1067166,1068192,1068592,1071063,1071499,1071630,1071958,1072512,1072539,1073029,1073290,1077219,1079239,1079653,1080126,1080135,1080216,1080612,1080864,1081206,1081260,1081350,1081399,1082160,1083285,1083537,1083942,1086012,1086120,1086129,1088640,1088964,1089612,1089913,1090525,1091299,1092816,1095025,1095250,1095295,1098238,1098522,1099525,1104264,1104966,1106424,1106428,1107580,1109295,1113385,1114852,1116684,1116846,1118466,1118736,1123632,1124199,1124680,1124689,1125009,1125090,1125900,1130436,1131448,1134486,1134688,1136268,1137339,1137393,1137933,1138986,1139125,1139229,1140862,1140885,1142680,1144786,1147923,1148175,1150677,1152027,1152225,1152549,1152837,1155996,1156428,1156720,1156833,1156990,1160725,1160995,1163484,1163974,1164096,1164780,1164960,1167250,1167259,1167714,1169280,1169478,1169496,1170670,1172682,1175625,1176039,1176754,1177254,1177384,1178248,1178464,1178635,1179603,1179616,1180242,1181565,1182537,1184008,1184080,1184400,1184625,1184800,1185075,1185678,1185750,1186528,1186992,1187455,1188265,1189206,1189260,1192045,1192554,1193017,1193283,1194831,1195236,1196496,1198408,1198476,1198480,1198575,1198926,1199848,1200006,1200060,1200384,1200600,1200762,1200843,1201086,1201815,1202355,1203084,1203651,1203840,1203894,1204168,1205406,1205482,1205595,1205685,1206000,1206108,1206814,1207620,1207714,1208196,1208403,1208430,1208943,1209541,1209564,1209735,1210806,1210860,1215180,1215760,1215972,1216894,1216948,1218015,1218150,1219576,1225462,1226745,1227460,1227640,1227694,1229548,1229674,1230084,1230840,1230894,1232896,1233540,1234768,1234876,1235038,1235380,1236384,1236726,1236748,1236874,1237369,1237468,1237486,1238400,1238584,1238940,1238994,1240537,1240677,1240843,1241284,1243584,1244502,1244830,1244880,1245208,1245420,1245964,1246396,1247958,1248876,1249528,1249668,1249780,1250005,1250050,1250095,1250496,1250500,1250950,1250964,1250995,1252480,1253065,1253632,1254330,1254600,1254748,1255000,1255005,1255729,1255810,1256436,1256490,1256530,1256827,1258816,1259473,1259500,1259649,1259793,1259950,1259995,1260000,1260108,1260270,1261080,1261399,1261885,1262079,1263456,1263604,1263748,1264086,1264536,1265305,1265530,1268316,1268374,1268460,1269342,1269774,1270647,1270948,1271943,1274170,1274368,1274665,1274836,1274872,1275264,1275286,1275925,1276065,1276200,1276348,1276524,1276834,1279642,1280524,1281582,1282716,1283166,1283359,1283476,1283544,1283674,1283746,1284003,1284030,1284300,1284435,1285384,1285915,1286374,1286608,1286968,1287436,1287634,1288354,1289376,1289403,1289430,1289943,1290564,1291234,1291675,1292458,1292746,1294380,1294519,1295005,1295014,1295050,1295095,1295140,1295500,1295640,1295644,1295694,1295950,1295964,1295995,1296400,1296648,1297611,1297750,1298475,1298632,1299505,1299550,1299595,1299955,1302448,1302565,1302655,1302714,1303438,1304118,1305265,1306246,1306278,1306525,1307826,1312420,1312542,1312726,1314895,1318648,1320241,1320475,1320493,1320867,1322046,1322455,1324125,1324300,1324584,1324854,1324917,1325065,1325650,1325695,1325776,1325965,1326150,1326204,1326415,1326505,1326550,1326595,1326717,1326955,1328445,1329565,1329655,1332450,1335442,1336176,1338246,1338768,1339416,1340163,1341027,1341274,1342750,1342768,1342876,1345360,1347250,1347628,1347682,1348276,1348285,1348762,1348974,1348996,1349023,1350045,1350450,1352286,1352416,1352457,1352664,1352929,1354284,1354288,1354500,1356376,1356498,1357398,1357884,1357924,1358280,1358370,1358442,1360435,1361785,1362438,1362748,1362874,1365250,1367428,1367482,1368054,1368274,1368432,1368540,1368594,1368742,1369480,1369732,1371784,1373071,1374268,1374286,1374628,1374682,1374826,1374862,1375479,1379128,1379448,1380645,1381743,1386571,1387840,1387984,1388178,1392435,1395000,1395648,1396782,1397281,1398240,1400035,1400350,1401696,1402533,1402695,1402978,1403500,1406137,1409278,1409782,1413045,1413445,1413450,1413472,1417437,1418679,1418976,1419165,1420978,1423318,1425375,1425753,1426225,1427368,1427899,1428736,1429780,1429798,1429978,1430941,1432768,1432876,1434069,1435000,1435036,1436472,1436526,1436728,1436872,1437039,1437093,1437268,1437286,1437309,1437390,1437520,1437903,1437930,1439059,1439739,1439793,1443096,1443906,1448392,1452343,1452730,1452888,1453140,1453450,1455970,1456798,1456803,1456830,1458810,1458828,1458832,1459354,1461370,1462072,1463728,1465200,1465290,1465870,1468372,1468953,1469520,1470568,1471365,1472368,1472836,1473628,1473664,1473678,1473682,1473934,1475266,1475635,1476328,1476688,1476832,1480279,1482138,1482736,1483276,1483672,1483726,1484892,1486372,1487236,1487286,1487362,1487632,1489752,1492456,1492632,1493640,1493739,1493793,1493964,1495683,1495786,1497366,1497802,1497820,1497982,1498032,1498783,1499782,1500003,1500030,1500246,1500300,1500435,1500624,1502406,1502460,1502946,1503000,1504350,1506024,1506240,1506294,1506325,1506523,1507968,1508026,1508260,1510267,1510533,1512396,1518264,1519978,1520365,1520608,1520766,1522710,1523277,1524006,1524060,1524339,1524600,1524762,1524978,1525630,1526080,1526287,1526305,1526850,1529325,1529406,1529460,1529946,1530000,1530054,1530625,1531053,1532389,1532560,1532605,1532776,1533105,1534360,1537263,1537425,1538181,1538433,1538964,1541938,1542343,1542496,1543284,1543500,1543716,1547334,1548738,1552630,1552770,1553260,1553269,1553409,1558228,1558426,1560024,1560240,1560325,1562224,1562346,1562400,1562530,1562890,1563025,1563048,1563250,1563264,1563295,1563507,1565329,1568484,1569150,1570392,1572925,1574253,1576827,1579419,1579486,1579500,1579648,1581268,1581930,1583145,1583865,1584432,1585390,1586245,1586304,1587820,1588158,1590435,1590835,1591884,1592419,1594138,1596325,1597725,1599426,1601626,1603255,1605208,1605325,1608246,1608520,1608624,1613538,1614235,1614262,1615374,1615833,1620072,1620720,1624338,1624536,1625026,1625260,1625305,1625476,1625530,1626322,1627200,1627348,1627524,1627632,1627857,1628734,1629396,1629576,1629760,1630255,1630287,1630525,1632505,1632550,1632595,1632708,1632748,1632874,1632955,1633545,1634728,1634872,1637950,1638054,1638540,1638594,1639440,1642356,1642455,1643292,1645312,1645735,1645803,1645830,1645839,1647436,1647828,1648732,1649583,1652008,1652080,1652472,1652584,1657062,1662039,1664892,1667952,1672348,1672398,1672528,1672834,1672884,1672965,1673257,1673428,1673482,1673752,1674328,1674832,1675728,1677672,1679458,1680520,1682032,1682608,1682734,1683274,1683346,1683472,1685200,1687149,1687234,1687342,1687432,1687950,1688328,1691865,1693237,1693795,1695537,1698327,1698412,1698642,1698750,1699137,1702345,1702624,1704312,1704339,1712434,1713649,1715098,1715980,1716975,1717699,1718248,1722460,1723036,1723468,1723486,1723698,1723806,1723860,1723927,1724184,1724886,1726348,1726834,1726884,1727896,1728220,1728342,1728346,1728634,1732153,1732414,1732500,1734129,1734268,1734286,1734628,1734682,1734826,1734862,1739128,1739250,1739925,1740028,1740082,1740208,1740235,1740280,1740298,1740802,1740820,1740982,1742008,1742080,1742098,1742800,1742958,1742980,1742998,1743268,1743286,1743700,1743997,1746328,1746832,1747039,1747930,1748002,1748020,1748200,1748326,1748632,1749802,1749820,1749982,1750432,1753290,1755918,1756890,1758393,1759198,1760535,1762069,1762150,1762384,1765273,1768248,1772941,1775038,1779975,1780294,1780942,1782094,1782562,1782940,1782994,1783584,1784695,1785204,1785726,1789402,1789420,1789942,1790995,1792386,1793250,1793925,1794028,1794082,1794208,1794280,1794298,1794802,1794820,1794883,1794982,1795680,1798294,1798942,1799325,1799428,1799482,1800225,1802250,1802727,1802970,1802974,1804288,1806021,1806210,1807029,1809702,1809742,1812636,1813747,1815835,1820065,1820227,1820650,1820763,1820875,1820974,1822500,1823845,1823976,1824732,1825416,1826055,1826500,1826892,1827000,1828075,1828701,1829079,1829740,1829794,1829974,1831752,1834128,1835046,1835644,1839744,1839852,1841260,1847286,1851988,1852384,1854832,1854972,1856272,1856277,1858212,1861249,1863504,1866240,1867216,1867536,1870209,1870290,1871428,1873264,1874520,1879195,1879326,1882435,1887291,1890265,1890702,1893258,1895364,1897020,1897213,1897402,1897420,1897942,1899742,1900521,1902109,1902465,1902600,1902775,1904274,1904728,1905025,1908270,1908324,1908522,1909026,1909215,1912050,1912806,1913886,1914129,1915893,1917958,1919232,1920235,1920285,1920555,1920919,1921500,1923628,1923750,1925658,1925896,1926504,1926850,1927062,1927170,1928115,1929816,1932417,1932570,1934946,1935220,1935756,1937592,1937848,1938321,1939450,1942290,1942978,1946853,1949782,1950835,1956325,1962675,1963255,1965433,1965537,1965820,1966288,1967238,1968219,1973826,1974028,1974082,1974208,1974280,1974298,1974802,1974820,1974982,1977250,1978294,1978942,1979428,1979482,1979725,1979802,1980252,1982061,1982974,1984248,1985328,1989742,1994265,1997428,1997482&#125;;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; /* int cnt = 0; for(int i = 10;i &lt;= 2000000;i++) if(check(i)) a[cnt++] = i; for(int i = 0;i &lt; cnt;i++) printf("%d,",a[i]); cout&lt;&lt;endl; */ int cnt = sizeof(a)/sizeof(int); while(scanf("%d",&amp;n) == 1 &amp;&amp; n) &#123; int t = lower_bound(a,a+cnt,n)-a; printf("%d\n",a[t]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>套题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4848 Wow! Such Conquering! （搜索）]]></title>
    <url>%2F2014%2F07%2F16%2Fhdu4848%2F</url>
    <content type="text"><![CDATA[HDU4848Wow! Such Conquering!Time Limit: 15000/8000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 290 Accepted Submission(s): 92 Problem Description There are n Doge Planets in the Doge Space. The conqueror of Doge Space is Super Doge, who is going to inspect his Doge Army on all Doge Planets. The inspection starts from Doge Planet 1 where DOS (Doge Olympic Statue) was built. It takes Super Doge exactly Txy time to travel from Doge Planet x to Doge Planet y. With the ambition of conquering other spaces, he would like to visit all Doge Planets as soon as possible. More specifically, he would like to visit the Doge Planet x at the time no later than Deadlinex. He also wants the sum of all arrival time of each Doge Planet to be as small as possible. You can assume it takes so little time to inspect his Doge Army that we can ignore it. Input There are multiple test cases. Please process till EOF. Each test case contains several lines. The first line of each test case contains one integer: n, as mentioned above, the number of Doge Planets. Then follow n lines, each contains n integers, where the y-th integer in the x-th line is Txy . Then follows a single line containing n - 1 integers: Deadline2 to Deadlinen. All numbers are guaranteed to be non-negative integers smaller than or equal to one million. n is guaranteed to be no less than 3 and no more than 30. Output If some Deadlines can not be fulfilled, please output “-1” (which means the Super Doge will say “WOW! So Slow! Such delay! Much Anger! . . . ” , but you do not need to output it), else output the minimum sum of all arrival time to each Doge Planet. Sample Input 40 3 8 64 0 7 47 5 0 26 9 3 030 8 3040 2 3 32 0 3 32 3 0 32 3 3 02 3 3 Sample Output 36 -136-1 Hint Explanation: In case #1: The Super Doge travels to Doge Planet 2 at the time of 8 and to Doge Planet 3 at the time of 12, then to Doge Planet 4 at the time of 16. The minimum sum of all arrival time is 36. Source 2014西安全国邀请赛 题意很清楚，也比较简单。 就是从1这点出发，要经过2~n的点，每个点要在截止时间前到达。 求最后总到达时间的和最小。 直接暴力搜索就可以了，简单剪枝。很水的题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* ***************Author :kuangbinCreated Time :2014/7/16 18:15:26File Name :E:\2014ACM\比赛\2014西安邀请赛\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int a[100][100];int dt[100];int n;int ans;bool used[100];void dfs(int u,int now,int tot,int cnt)&#123; if(cnt == n-1) &#123; if(tot &lt; ans)ans = tot; return; &#125; if(tot + (n-1-cnt)*now &gt;= ans)return; for(int i = 1;i &lt; n;i++) if(!used[i] &amp;&amp; now+a[u][i] &gt; dt[i]) return; for(int i = 1;i &lt; n;i++) if(!used[i]) &#123; used[i] = true; dfs(i,now+a[u][i],tot+now+a[u][i],cnt+1); used[i] = false; &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); while(scanf("%d",&amp;n) == 1) &#123; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) scanf("%d",&amp;a[i][j]); for(int k = 0;k &lt; n;k++) for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) if(a[i][k]+a[k][j] &lt; a[i][j]) a[i][j] = a[i][k]+a[k][j]; for(int i = 1;i &lt; n;i++) scanf("%d",&amp;dt[i]); ans = INF; memset(used,false,sizeof(used)); dfs(0,0,0,0); if(ans == INF)ans = -1; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regionals 2013 :: Asia - Dhaka]]></title>
    <url>%2F2014%2F07%2F13%2Fregionals-2013-asia-dhaka%2F</url>
    <content type="text"><![CDATA[题目链接：UVALive开的比赛地址：VJ A: Falling Ants水题。找一个H最大的，相同找H*W*L最大的。输出H*W*L; /* ***Author :kuangbinCreated Time :2014/7/5 14:07:59File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\A.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;int L[110],W[110],H[110]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; while(scanf(“%d”,&amp;n) ==1 &amp;&amp; n) { for(int i = 0;i &lt; n;i++) scanf(“%d%d%d”,&amp;L[i],&amp;W[i],&amp;H[i]); int ans = 0; for(int i = 1;i &lt; n;i++) if(H[i] &gt; H[ans] || (H[i] == H[ans] &amp;&amp; H[i]*W[i]*L[i] &gt; H[ans]*W[ans]*L[ans])) ans = i; printf(“%d\n”,H[ans]*L[ans]*W[ans]); } return 0;} B: Game of MJ比较简单的博弈题。稍微分析下就可以了。 每一位上加1的话，有不同效果，有的是模3为0,1,2的。 不同位上进行分类，得到cnt0,cnt1,cnt2,代码这些位上数字操作模3的效果。 可以发现第一个人有两种方法： 1 1 2 1 2 1 2 1 2 1 2…… 2 2 1 2 1 2 1 2 1 2 1…. 1表示模3为1的，2表示模3为2的。 模3为0的可以插入到中间去。 这样分类讨论下就可以知道结果了。 具体看代码吧。 /* ***Author :kuangbinCreated Time :2014/7/5 14:45:36File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\B.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; int iCase = 0; scanf(“%d”,&amp;T); while(T–) { iCase++; long long cnt0 = 0, cnt1 = 0, cnt2 = 0; scanf(“%d”,&amp;n); int L,B; while(n–) { scanf(“%d%d”,&amp;L,&amp;B); if(L == 1)continue; if(B%3 == 0) { cnt0 += (long long)(L-1)(B-1); } else if(B%3 == 1) { cnt1 += (long long)(L-1)(B-1); } else { cnt1 += (long long)((L-1)/2)(B-1); cnt2 += (long long)(L/2)(B-1); } } //不能操作 if(cnt0 == 0 &amp;&amp; cnt1 == 0 &amp;&amp; cnt2 == 0) { printf(“Case %d: Draw\n”,iCase); continue; } if(cnt1 == 0 &amp;&amp; cnt2 == 0 &amp;&amp; cnt0 != 0) { printf(“Case %d: J\n”,iCase); continue; } bool canwin = false; bool candraw = false; //对M进行分析 //第一次选余数为1的 if(cnt1) { if(cnt1-1 == cnt2 || cnt1-1 == cnt2+1) { candraw = true; } else { if(cnt1-1 &lt; cnt2) { if(cnt0%2 == 0) canwin = true; } else { if(cnt0%2 == 1) canwin = true; } } } if(cnt2) { if(cnt2-1 == cnt1 || cnt2-1 == cnt1+1) candraw = true; else { if(cnt2-1 &lt; cnt1) { if(cnt0%2 == 0) canwin = true; } else { if(cnt0%2 == 1) canwin = true; } } } if(canwin)printf(“Case %d: M\n”,iCase); else if(candraw)printf(“Case %d: Draw\n”,iCase); else printf(“Case %d: J\n”,iCase); } return 0;} C: Game of Throne很好的一道题。 主要是转化建模的过程。 N个点的图。每条边有权值。 需要求一个子图。 1~K个点度数为奇数， K+1~N需要度数为偶数。 求子图的最小权值和。 先floyed 一遍，求出两两之间的最短路径。 这样其实就是一个完全图。 度数为偶数的可以不管。 直接看度数为奇数的。 其实就是需要前K个点两两匹配，求最小权值和。 变成了一般图的最小加权匹配。 套一发模板就可以了。 /* ***Author :kuangbinCreated Time :2014/7/9 19:18:06File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\C2.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;//一般图的最大加权匹配模板//注意G的初始化,需要偶数个点，刚好可以形成n/2个匹配//如果要求最小权匹配，可以取相反数，或者稍加修改就可以了//点的编号从0开始的const int MAXN = 110;const int INF = 0x3f3f3f3f;int G[MAXN][MAXN];int cnt_node;//点的个数int dis[MAXN];int match[MAXN];bool vis[MAXN];int sta[MAXN],top;//堆栈bool dfs(int u){ sta[top++] = u; if(vis[u])return true; vis[u] = true; for(int i = 0;i &lt; cnt_node;i++) if(i != u &amp;&amp; i != match[u] &amp;&amp; !vis[i]) { int t = match[i]; if(dis[t] &lt; dis[u] + G[u][i] - G[i][t]) { dis[t] = dis[u] + G[u][i] - G[i][t]; if(dfs(t))return true; } } top–; vis[u] = false; return false;}int P[MAXN];int get_Match(int N)//返回最大匹配权值{ cnt_node = N; for(int i = 0;i &lt; cnt_node;i++)P[i] = i; for(int i = 0;i &lt; cnt_node;i += 2) { match[i] = i+1; match[i+1] = i; } int cnt = 0; while(1) { memset(dis,0,sizeof(dis)); memset(vis,false,sizeof(vis)); top = 0; bool update = false; for(int i = 0;i &lt; cnt_node;i++) if(dfs(P[i])) { update = true; int tmp = match[sta[top-1]]; int j = top-2; while(sta[j] != sta[top-1]) { match[tmp] = sta[j]; swap(tmp,match[sta[j]]); j–; } match[tmp] = sta[j]; match[sta[j]] = tmp; break; } if(!update) { cnt++; if(cnt &gt;= 3)break; random_shuffle(P,P+cnt_node); } } int ans = 0; for(int i = 0;i &lt; cnt_node;i++) { int v = match[i]; if(i &lt; v)ans += G[i][v]; } return ans;}int g[MAXN][MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; int n,m,K; scanf(“%d”,&amp;T); while(T–) { iCase++; scanf(“%d%d%d”,&amp;n,&amp;m,&amp;K); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) { if(i == j)g[i][j] = 0; else g[i][j] = INF; } int u,v,w; while(m–) { scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w); u–; v–; g[u][v] = g[v][u] = min(g[u][v],w); } if(K&amp;1) { printf(“Case %d: Impossible\n”,iCase); continue; } for(int k = 0;k &lt; n;k++) for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) g[i][j] = min(g[i][j],g[i][k]+g[k][j]); for(int i = 0;i &lt; K;i++) for(int j = 0;j &lt; K;j++) G[i][j] = -g[i][j]; printf(“Case %d: %d\n”,iCase,-get_Match(K)); } return 0;} D: Pattern Locker水题，不多说，直接乘起来加起来就解决了 /* ***Author :kuangbinCreated Time :2014/7/9 22:21:58File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\D.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const long long MOD = 1e13+7; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; int L,N,M; scanf(“%d”,&amp;T); while(T–) { iCase++; scanf(“%d%d%d”,&amp;L,&amp;M,&amp;N); long long ans = 0; long long tmp = 1; for(int i = 1;i &lt;= N;i++) { tmp = tmp(LL-i+1)%MOD; if(i &gt;= M) ans = (ans+tmp)%MOD; } printf(“Case %d: %lld\n”,iCase,ans); } return 0;} F: Two Points Revisited水题。简单构造就可以了，保证垂直。 /* ***Author :kuangbinCreated Time :2014/7/10 17:54:54File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\F.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int x1,y1,x2,y2; scanf(“%d”,&amp;T); int iCase = 0; while(T–) { iCase++; scanf(“%d%d%d%d”,&amp;x1,&amp;y1,&amp;x2,&amp;y2); printf(“Case %d: %d %d %d %d\n”,iCase,y2,x1,y1,x2); } return 0;} G: Watching the Kangaroo胡乱搞一下就可以了。 /* ***Author :kuangbinCreated Time :2014/7/10 18:13:29File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\G.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;struct Node{ int x,index;}node[MAXN];bool cmp(Node a,Node b){ return a.x &lt; b.x;}int M;vectoravec[MAXN];vectordvec[MAXN]; void gao(int L,int R,int val){ int id,l,r; id = -1; l = 0; r = M-1; while(l &lt;= r) { int mid = (l+r)/2; if(node[mid].x &gt;= L) { r = mid-1; id = mid; } else l = mid+1; } if(id != -1 &amp;&amp; node[id].x &lt;= R) { avec[id].push_back(val); id = -1; l = 0;r = M-1; while(l &lt;= r) { int mid = (l+r)/2; if(node[mid].x &lt;= R) { l = mid+1; id = mid; } else r = mid-1; } if(id != -1) dvec[id].push_back(val); }}int ans[MAXN];int L[MAXN],R[MAXN];;int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int N,T; int iCase = 0; scanf(“%d”,&amp;T); while(T–) { iCase++; printf(“Case %d:\n”,iCase); scanf(“%d%d”,&amp;N,&amp;M); for(int i = 0;i &lt; N;i++) scanf(“%d%d”,&amp;L[i],&amp;R[i]); for(int i = 0;i &lt; M;i++) { scanf(“%d”,&amp;node[i].x); node[i].index = i; } sort(node,node+M,cmp); for(int i = 0;i &lt; N;i++) { gao(L[i],(L[i]+R[i])/2,L[i]); gao((L[i]+R[i]+1)/2,R[i],R[i]); } multisetmt; multiset::iterator it; for(int i = 0;i &lt; M;i++) { int sz = avec[i].size(); for(int j = 0;j &lt; sz;j++) mt.insert(avec[i][j]); ans[node[i].index] = 0; if(!mt.empty()) { it = mt.begin(); ans[node[i].index] = max(ans[node[i].index],node[i].x-(it)); it = mt.end(); it–; ans[node[i].index] = max(ans[node[i].index],(it)-node[i].x); } sz = dvec[i].size(); for(int j = 0;j &lt; sz;j++) { it = mt.find(dvec[i][j]); mt.erase(it); } } for(int i = 0;i &lt; M;i++) printf(“%d\n”,ans[i]); for(int i = 0;i &lt; M;i++) { avec[i].resize(0); dvec[i].resize(0); } } return 0;} H: GCD XOR求gcd(A,B) == A^B 1&lt;=B&lt;=A&lt;=N 的对数 首先需要明白的是 如果A^B = tmp的话，那么A,B的差值是不会超过tmp, 这个从二进制很容易想通。 那么如果A,B的gcd为 i, 也就是A,B都是i的倍数。如果 i == A^B 那么A,B的差值只能是i 所以枚举gcd, 假如为i, 那么去判断 j*i 和 (j-1)*i 是不是符合条件。而且 gcd(j*i,(j-1)*i) 一定是i 的，不要再求了。 很容易进行预处理了。 /* ***Author :kuangbinCreated Time :2014/7/10 18:55:32File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\H.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 30000000;int f[MAXN+10];void init(){ memset(f,0,sizeof(f)); for(int i = 1;i &lt;= MAXN;i++) { for(int j = i+i;j &lt;= MAXN;j+=i) if( (j^(j-i)) == i ) f[j]++; } for(int i = 1;i &lt;= MAXN;i++) f[i] += f[i-1];} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; int iCase = 0; scanf(“%d”,&amp;T); init(); while(T–) { iCase++; scanf(“%d”,&amp;n); printf(“Case %d: %d\n”,iCase,f[n]); } return 0;} I： Fiasco按照bfs顺序从小到大去分配边。 /* ***Author :kuangbinCreated Time :2014/7/13 17:00:43File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\I.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 2510;const int MAXM = 50010;struct Edge{ int to,next; int index;}edge[MAXM];int head[MAXN],tot;void init(){ tot = 0; memset(head,-1,sizeof(head));}void addedge(int u,int v,int index){ edge[tot].to = v; edge[tot].next = head[u]; edge[tot].index = index; head[u] = tot++;} int ST[MAXM],ED[MAXM],W[MAXM];int ans[MAXM];bool used[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); int n,m,start; int iCase = 0; while(T–) { iCase++; printf(“Case %d:\n”,iCase); init(); scanf(“%d%d%d”,&amp;n,&amp;m,&amp;start); for(int i = 0;i &lt; m;i++) { scanf(“%d%d%d”,&amp;ST[i],&amp;ED[i],&amp;W[i]); addedge(ST[i],ED[i],i); addedge(ED[i],ST[i],i); } sort(W,W+m); queueq; q.push(start); memset(used,false,sizeof(used)); memset(ans,-1,sizeof(ans)); used[start] = true; int id = 0; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u];i != -1;i = edge[i].next) { int v = edge[i].to; if(used[v])continue; used[v] = true; q.push(v); ans[edge[i].index] = W[id++]; } } for(int i = 0;i &lt; m;i++) if(ans[i] == -1) ans[i] = W[id++]; for(int i = 0;i &lt; m;i++) printf(“%d %d %d\n”,ST[i],ED[i],ans[i]); } return 0;} J: Dromicpalin Substrings直接暴力，统计出现次数。 /* ***Author :kuangbinCreated Time :2014/7/13 19:54:49File Name :E:\2014ACM\区域赛练习\2013\2013Dhaka\J.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;char str[1010];int cnt[26]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int iCase = 0; scanf(“%d”,&amp;T); while(T–) { iCase++; scanf(“%s”,str); int n = strlen(str); int ans = 0; for(int i = 0;i &lt; n;i++) { memset(cnt,0,sizeof(cnt)); int odd = 0, even = 26; for(int j = i;j &lt; n;j++) { if(cnt[str[j]-‘a’]&amp;1) { odd–; even++; } else { odd++; even–; } cnt[str[j]-‘a’]++; if(odd &lt;= 1)ans++; } } printf(“Case %d: %d\n”,iCase,ans); } return 0;} K: Fill the Cuboid直接就是DLX的题目。 直接爆搞会T。 但是要把1*1*1的立方体排除掉。然后数量就不多了。 #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std; const int MaxN = 150300;const int MaxM = 200;const int maxnode = MaxNMaxM + 10000;bool used[200];int CubeSize[MaxN];struct DLX{ int n,m,size; int U[maxnode],D[maxnode],R[maxnode],L[maxnode],Row[maxnode],Col[maxnode]; int H[MaxN],S[MaxM]; void init(int _n,int _m) { n = _n; m = _m; for(int i = 0;i &lt;= m;i++) { S[i] = 0; U[i] = D[i] = i; L[i] = i-1; R[i] = i+1; } R[m] = 0; L[0] = m; size = m; for(int i = 1;i &lt;= n;i++)H[i] = -1; } void Link(int r,int c) { ++S[Col[++size]=c]; Row[size] = r; D[size] = D[c]; U[D[c]] = size; U[size] = c; D[c] = size; if(H[r] &lt; 0)H[r] = L[size] = R[size] = size; else { R[size] = R[H[r]]; L[R[H[r]]] = size; L[size] = H[r]; R[H[r]] = size; } } void remove(int c) { L[R[c]] = L[c]; R[L[c]] = R[c]; for(int i = D[c];i != c;i = D[i]) for(int j = R[i];j != i;j = R[j]) { U[D[j]] = U[j]; D[U[j]] = D[j]; –S[Col[j]]; } } void resume(int c) { for(int i = U[c];i != c;i = U[i]) for(int j = L[i];j != i;j = L[j]) ++S[Col[U[D[j]]=D[U[j]]=j]]; L[R[c]] = R[L[c]] = c; } void Dance(int d,int sum) { used[d+sum] = true; if(R[0] == 0) { return ; } int c = R[0]; for(int i = R[0];i != 0;i = R[i]) { if(S[i] &gt; S[c]) c = i; } remove(c); for(int i = D[c];i != c;i = D[i]) { if(CubeSize[Row[i]] == 1)continue; for(int j = R[i];j != i;j = R[j])remove(Col[j]); Dance(d+1,sum-CubeSize[Row[i]]); for(int j = L[i];j != i;j = L[j])resume(Col[j]); } resume(c); }};DLX dlx; bool g[22][22][22];int id[22][22][22];vectorvec[MaxN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int a,b,c,m; int iCase = 0; while(scanf(“%d%d%d%d”,&amp;a,&amp;b,&amp;c,&amp;m) == 4) { if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0 &amp;&amp; m == 0)break; iCase++; memset(g,0,sizeof(g)); int x,y,z; while(m–) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z); g[x][y][z] = true; } int m = 0; for(int i = 1;i &lt;= a;i++) for(int j = 1;j &lt;= b;j++) for(int k = 1;k &lt;= c;k++) if(!g[i][j][k]) { m++; id[i][j][k] = m; } int n = 0; for(int i = 1;i &lt;= a;i++) for(int j = 1;j &lt;= b;j++) for(int k = 1;k &lt;= c;k++) if(!g[i][j][k]) { for(int d = 1;;d++) { if(i+d-1 &gt; a || j+d-1 &gt; b || k+d-1 &gt; c)break; bool flag = true; for(int u = i;u &lt;= i+d-1;u++) for(int v = j;v &lt;= j+d-1;v++) for(int w = k;w &lt;= k+d-1;w++) { if(g[u][v][w]) { flag = false; break; } } if(!flag)break; n++; CubeSize[n] = d*d*d; for(int u = i;u &lt;= i+d-1;u++) for(int v = j;v &lt;= j+d-1;v++) for(int w = k;w &lt;= k+d-1;w++) vec[n].push_back(id[u][v][w]); } } dlx.init(n,m); for(int i = 1;i &lt;= n;i++) { int sz = vec\[i\].size(); for(int j = 0 ;j &lt; sz;j++) dlx.Link(i,vec\[i\]\[j\]); } memset(used,false,sizeof(used)); dlx.Dance(0,m); printf(&quot;Case %d:&quot;,iCase); for(int i = 0;i &lt; 200;i++) if(used\[i\]) printf(&quot; %d&quot;,i); printf(&quot;\\n&quot;); for(int i = 1;i &lt;= n;i++) vec\[i\].resize(0); } return 0; }]]></content>
      <categories>
        <category>Contest</category>
        <category>套题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas定理]]></title>
    <url>%2F2014%2F07%2F09%2Flucas-theorem%2F</url>
    <content type="text"><![CDATA[Lucas可以解决组合数求模的问题。当要求的组合数比较大，而且对一个素数取模时。普通的递推或者逆元的方法都不适用了。只能借助于Lucas定理。\[C_{n}^{m} \% p \]\[ C(n,m)=C([n/p],[m/p]) * C(n\%p,m\%p) (mod p) \] 具体证明，网上很多版本，就不给出了。 HDU3037 模板题。 m个要分给n个树。 树是不一样的。加一个空的，表示不放的。 将不大于m颗种子存放在n颗树中，问有多少种存法。 这样就是 \( x_{1} + x{2} + …… + x_{n+1} = m \) 的非负整数解个数。 答案就是 C(n+m,n) /* ***Author :kuangbinCreated Time :2014/7/9 23:18:55File Name :E:\2014ACM\专题学习\数学\Lucas定理\HDU3037.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;long long F[100010];void init(long long p){ F[0] = 1; for(int i = 1;i &lt;= p;i++) F[i] = F[i-1]i%p;}long long inv(long long a,long long m){ if(a == 1)return 1; return inv(m%a,m)(m-m/a)%m;}long long Lucas(long long n,long long m,long long p){ long long ans = 1; while(n&amp;&amp;m) { long long a = n%p; long long b = m%p; if(a &lt; b)return 0; ans = ans*F[a]%p*inv(F[b]*F[a-b]%p,p)%p; n /= p; m /= p; } return ans;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,m,p; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d%d”,&amp;n,&amp;m,&amp;p); init(p); printf(“%d\n”,(int)Lucas(n+m,n,p)); } return 0;}]]></content>
      <categories>
        <category>HDU</category>
        <category>Lucas</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACdream原创群赛(15)の每题10s多开心 非官方题解]]></title>
    <url>%2F2014%2F07%2F05%2Facdream15%2F</url>
    <content type="text"><![CDATA[Link ： ACdream2014年7月4日，ACdream群赛简单题解。 5道是本弱出的，5道是适牛出的。 写个简单的题解。 具体题解见适牛的详细版！ A： 喵喵的数字我的做法就是数位DP 数位DP可以求， &lt;=n 里面，二进制1的个数有num个的有多少个，以及他们的和。 然后num从小到大去变化。 然后二分就可以找出第M个数是什么，和也知道了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217/* ***************Author :kuangbinCreated Time :2014/6/30 21:44:09File Name :E:\2014ACM\题目\数字.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 1e9+9;long long dp1[100][100],dp2[100][100];int bit[100];long long two[100];pair&lt;long long,long long&gt; dfs(int pos,int num,bool flag)&#123; if(pos == -1) &#123; if(num == 0)return make_pair(1,0); else return make_pair(0,0); &#125; if(num &lt; 0)return make_pair(0,0); if(!flag &amp;&amp; dp1[pos][num] != -1)return make_pair(dp1[pos][num],dp2[pos][num]); long long ans1 = 0, ans2 = 0; int end = flag?bit[pos]:1; pair&lt;long long,long long&gt;tmp; for(int i = 0;i &lt;= end;i++) &#123; tmp = dfs(pos-1,i==1?num-1:num,flag&amp;&amp;i==end); ans1 += tmp.first; ans2 += (i*tmp.first%MOD*(two[pos]%MOD)%MOD + tmp.second)%MOD; if(ans2 &gt;= MOD)ans2 -= MOD; &#125; if(!flag) &#123; dp1[pos][num] = ans1; dp2[pos][num] = ans2; &#125; return make_pair(ans1,ans2);&#125;pair&lt;long long,long long&gt; solve(long long n,int num)&#123; int cnt = 0; do &#123; bit[cnt++] = n&amp;1; n &gt;&gt;= 1; &#125; while(n); return dfs(cnt-1,num,1);&#125;pair&lt;long long,long long&gt;p;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); memset(dp1,-1,sizeof(dp1)); memset(dp2,-1,sizeof(dp2)); two[0] = 1; for(int i = 1;i &lt; 63;i++) two[i] = 2*two[i-1]; long long n,m; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld%lld",&amp;n,&amp;m); long long ans1; long long ans2 = 0; m++; long long cnt = 0; for(int i = 0;i &lt;= 63;i++) &#123; p = solve(n,i); if(cnt + p.first &lt; m) &#123; cnt += p.first; ans2 = (ans2 + p.second)%MOD; continue; &#125; long long l = 0, r = n; while(l &lt;= r) &#123; long long mid = (l+r)/2; p = solve(mid,i); if(cnt + p.first &gt;= m) &#123; ans1 = mid; r = mid-1; &#125; else l = mid+1; &#125; p = solve(ans1,i); ans2 = (ans2 + p.second)%MOD; break; &#125; printf("%lld %lld\n",ans1,ans2); &#125; return 0;&#125; B： Rankings DP。 填坑法DP。 用dp[i][j] 表示 前i个里面，出来j个， 但是坑的数量不是j的，需要差值去算。 有明确位置的点，要去除，被占的也去除。 DP直接转移就可以了。 dp[n][0]就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405/* ***************Author :kuangbinCreated Time :2014/6/18 17:05:27File Name :E:\2014ACM\题目\Rankings\std.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;using namespace std;const int MAXN = 1010;const int MOD = 2014;const int INF = 0x3f3f3f3f;struct Node&#123; int index; int dx;&#125;node[MAXN];bool cmp(Node a,Node b)&#123; return a.index &lt; b.index;&#125;int getnext()&#123; char ch; ch = getchar(); while(ch != '-' &amp;&amp; ch != '+' &amp;&amp; (ch &lt; '0' || ch &gt;'9')) ch = getchar(); if(ch == '-') &#123; ch = getchar(); if(ch &lt; '0' || ch &gt; '9') return -INF; int ret = ch - '0'; while(ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10 + (ch - '0'); return -ret; &#125; else if(ch == '+') &#123; ch = getchar(); if(ch &lt; '0' || ch &gt; '9') return INF; int ret = ch - '0'; while(ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10 + (ch - '0'); return ret; &#125; else &#123; int ret = ch - '0'; while(ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10 + (ch - '0'); return ret; &#125;&#125;int loc[MAXN];void Add(int &amp;a,int b)&#123; a += b; if(a &gt;= MOD)a -= MOD;&#125;int dp[MAXN][MAXN];bool f[MAXN][MAXN];int num1[MAXN],num2[MAXN];//坑和可以提供的int main()&#123; //freopen("5.in","r",stdin); //freopen("5.out","w",stdout); int iCase = 0; int n; while(scanf("%d",&amp;n) == 1) &#123; iCase++; for(int i = 0;i &lt; n;i++)scanf("%d",&amp;node[i].index); for(int i = 0;i &lt; n;i++)node[i].dx = getnext(); sort(node,node+n,cmp); memset(loc,0,sizeof(loc)); bool flag = true; for(int i = 0;i &lt; n;i++) &#123; if(node[i].dx == INF || node[i].dx == -INF)continue; int nn = node[i].index + node[i].dx; if(nn &lt;= 0 || nn &gt; n) &#123; flag = false; break; &#125; loc[nn]++; if(loc[nn] &gt; 1) &#123; flag = false; break; &#125; &#125; if(!flag) &#123; printf("IMPOSSIBLE\n"); continue; &#125; num1[0] = num2[0] = 0; for(int i = 1;i &lt;= n;i++) &#123; num1[i] = num1[i-1]; if(loc[i] == 0)num1[i]++; num2[i] = num2[i-1]; if(node[i-1].dx == INF || node[i-1].dx == -INF) num2[i]++; &#125; memset(dp,0,sizeof(dp)); dp[0][0] = 1; memset(f,false,sizeof(f)); f[0][0] = true; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt;= n;j++) &#123; if(!f[i][j])continue; if(node[i].dx == 0) &#123; Add(dp[i+1][j],dp[i][j]); f[i+1][j] = true; continue; &#125; int kj = j + (num1[i]-num2[i]);//坑的数量 assert(kj&gt;=0); //cout&lt;&lt;kj&lt;&lt;endl; if(node[i].dx != INF &amp;&amp; node[i].dx != -INF) &#123; if(loc[i+1]) &#123; Add(dp[i+1][j],dp[i][j]); f[i+1][j] = true; &#125; else &#123; Add(dp[i+1][j],dp[i][j]); f[i+1][j] = true; if(j) &#123; Add(dp[i+1][j-1],(long long)dp[i][j]*j%MOD); f[i+1][j-1] = true; &#125; &#125; continue; &#125; if(node[i].dx == INF) &#123; if(loc[i+1]) &#123; Add(dp[i+1][j+1],dp[i][j]); f[i+1][j+1] = true; &#125; else &#123; Add(dp[i+1][j+1],dp[i][j]); f[i+1][j+1] = true; if(j) &#123; Add(dp[i+1][j],(long long)dp[i][j]*j%MOD); f[i+1][j] = true; &#125; &#125; &#125; else &#123; if(loc[i+1]) &#123; if(kj) &#123; Add(dp[i+1][j],(long long)dp[i][j]*kj%MOD); f[i+1][j] = true; &#125; &#125; else &#123; if(kj) &#123; Add(dp[i+1][j],(long long)dp[i][j]*kj%MOD); f[i+1][j] = true; if(j) &#123; Add(dp[i+1][j-1],(long long)dp[i][j]*kj*j%MOD); f[i+1][j-1] = true; &#125; &#125; &#125; &#125; &#125; if(!f[n][0])printf("IMPOSSIBLE\n"); else printf("%d\n",dp[n][0]); &#125; return 0;&#125; C： 喵喵去寻宝 董壕的神几何。 我是用求积分的方法算的，精度误差比较大，我要1e-3的误差才能过。 我就是吧五角星变成10条有向线段。 线段和抛物线求面积。 求交点，然后解析法求积分。 图就不画了，画起来麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575/* ***************Author :kuangbinCreated Time :2014/7/1 22:36:20File Name :E:\2014ACM\题目\xunbao.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;// 计算几何模板const double eps = 1e-10;const double inf = 1e20;const double pi = acos(-1.0);const double PI = pi;const int maxp = 1010;//Compares a double to zeroint sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;//square of a doubleinline double sqr(double x)&#123;return x*x;&#125;/* * Point * Point() - Empty constructor * Point(double _x,double _y) - constructor * input() - double input * output() - %.2f output * operator == - compares x and y * operator &lt; - compares first by x, then by y * operator - - return new Point after subtracting curresponging x and y * operator ^ - cross product of 2d points * operator * - dot product * len() - gives length from origin * len2() - gives square of length from origin * distance(Point p) - gives distance from p * operator + Point b - returns new Point after adding curresponging x and y * operator * double k - returns new Point after multiplieing x and y by k * operator / double k - returns new Point after divideing x and y by k * rad(Point a,Point b)- returns the angle of Point a and Point b from this Point * trunc(double r) - return Point that if truncated the distance from center to r * rotleft() - returns 90 degree ccw rotated point * rotright() - returns 90 degree cw rotated point * rotate(Point p,double angle) - returns Point after rotateing the Point centering at p by angle radian ccw */struct Point&#123; double x,y; Point()&#123;&#125; Point(double _x,double _y) &#123; x = _x; y = _y; &#125; void input() &#123; scanf("%lf%lf",&amp;x,&amp;y); &#125; void output() &#123; printf("%.2f %.2f\n",x,y); &#125; bool operator == (Point b)const &#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0; &#125; bool operator &lt; (Point b)const &#123; return sgn(x-b.x)== 0?sgn(y-b.y)&lt;0:x&lt;b.x; &#125; Point operator -(const Point &amp;b)const &#123; return Point(x-b.x,y-b.y); &#125; //叉积 double operator ^(const Point &amp;b)const &#123; return x*b.y - y*b.x; &#125; //点积 double operator *(const Point &amp;b)const &#123; return x*b.x + y*b.y; &#125; //绕着p点逆时针旋转angle Point rotate(Point p,double angle) &#123; Point v = (*this) - p; double c = cos(angle), s = sin(angle); return Point(p.x + v.x*c - v.y*s,p.y + v.x*s + v.y*c); &#125;&#125;;/* * Stores two points * Line() - Empty constructor * Line(Point _s,Point _e) - Line through _s and _e * operator == - checks if two points are same * Line(Point p,double angle) - one end p , another end at angle degree * Line(double a,double b,double c) - Line of equation ax + by + c = 0 * input() - inputs s and e * adjust() - orders in such a way that s &lt; e * length() - distance of se * angle() - return 0 &lt;= angle &lt; pi * relation(Point p) - 3 if point is on line * 1 if point on the left of line * 2 if point on the right of line * pointonseg(double p) - return true if point on segment * parallel(Line v) - return true if they are parallel * segcrossseg(Line v) - returns 0 if does not intersect * returns 1 if non-standard intersection * returns 2 if intersects * linecrossseg(Line v) - line and seg * linecrossline(Line v) - 0 if parallel * 1 if coincides * 2 if intersects * crosspoint(Line v) - returns intersection point * dispointtoline(Point p) - distance from point p to the line * dispointtoseg(Point p) - distance from p to the segment * dissegtoseg(Line v) - distance of two segment * lineprog(Point p) - returns projected point p on se line * symmetrypoint(Point p) - returns reflection point of p over se * */struct Line&#123; Point s,e; Line()&#123;&#125; Line(Point _s,Point _e) &#123; s = _s; e = _e; &#125; //求两直线的交点 //要保证两直线不平行或重合 Point crosspoint(Line v) &#123; double a1 = (v.e-v.s)^(s-v.s); double a2 = (v.e-v.s)^(e-v.s); return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1)); &#125;&#125;;double a1,b1,c1;double kk,bb;double f1(double x)&#123; return a1*x*x*x/3 + b1*x*x/2 + c1*x;&#125;double f2(double x)&#123; return kk*x*x/2 + bb*x;&#125;double asr(double a,double b)&#123; //printf("%lf %lf\n",a,b); //return asr(a,b,eps,simpson(a,b)); //if(fabs(b-a) &lt; eps)return 0.0; double mid = (b+a)/2; double tmp1 = a1*mid*mid + b1*mid + c1; double tmp2 = kk*mid + bb; double ans = 0; if(tmp1 &gt; tmp2) &#123; ans = f1(b) - f1(a); &#125; else ans = f2(b) - f2(a); //printf("%.10lf\n",ans); return ans;&#125;double solve(Point s,Point e)&#123; double x1 = s.x, y1 = s.y; double x2 = e.x, y2 = e.y; if(fabs(x1-x2) &lt; eps)return 0.0; kk = (y2-y1)/(x2-x1); bb = y1 - kk*x1; vector&lt;double&gt;vec; if(fabs(a1) &lt; eps) &#123; if(fabs(b1-bb) &lt; eps) return asr(x1,x2); else &#123; vec.push_back(x1); vec.push_back(x2); double xx = (bb-c1)/(b1-kk); if( (xx-x1)*(xx-x2) &lt; 0 ) vec.push_back(xx); sort(vec.begin(),vec.end()); double ans = 0; int sz = vec.size(); for(int i = 0;i &lt; sz-1;i++) ans += asr(vec[i],vec[i+1]); if(x1 &gt; x2)ans = -ans; return ans; &#125; &#125; double deta = (b1-kk)*(b1-kk) - 4*a1*(c1-bb); if(fabs(deta) &lt; eps)deta = 0; if(deta &lt;= -eps) return asr(x1,x2); else &#123; vec.push_back(x1); vec.push_back(x2); double xx = (-(b1-kk)+sqrt(deta))/(2*a1); if( (xx-x1)*(xx-x2) &lt; 0 ) vec.push_back(xx); xx = (-(b1-kk)-sqrt(deta))/(2*a1); if( (xx-x1)*(xx-x2) &lt; 0 ) vec.push_back(xx); sort(vec.begin(),vec.end()); int sz = vec.size(); double ans = 0; for(int i = 0;i &lt; sz-1;i++) ans += asr(vec[i],vec[i+1]); if(x1 &gt; x2)ans = -ans; return ans; &#125;&#125;vector&lt;Point&gt;p;int main()&#123; //freopen("0.in","r",stdin); //freopen("00.out","w",stdout); int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%lf%lf%lf",&amp;a1,&amp;b1,&amp;c1); Point A,B,C,D,E; A.input(); B.input(); A.y -= 1e7; B.y -= 1e7; c1 -= 1e7; C = A.rotate(B,36.0/180.0*PI); D = B.rotate(C,36.0/180.0*PI); E = C.rotate(D,36.0/180.0*PI); p.clear(); p.push_back(A); p.push_back(Line(A,E).crosspoint(Line(C,D))); p.push_back(C); p.push_back(Line(A,E).crosspoint(Line(B,C))); p.push_back(E); p.push_back(Line(D,E).crosspoint(Line(B,C))); p.push_back(B); p.push_back(Line(D,E).crosspoint(Line(A,B))); p.push_back(D); p.push_back(Line(C,D).crosspoint(Line(A,B))); double tmp = 0; int sz = p.size(); /* for(int i = 0;i &lt; sz;i++) &#123; printf("** %lf %lf\n",p[i].x,p[i].y); &#125; */ for(int i = 0;i &lt; sz;i++) &#123; double tt1 = solve(p[i],p[(i+1)%sz]); //cout&lt;&lt;tt1&lt;&lt;endl; tmp += tt1; &#125; if(tmp &lt; 0)tmp = -tmp; if(fabs(tmp) &lt; eps)tmp = 0.0; printf("%.8lf\n",tmp); //cout&lt;&lt;tmp&lt;&lt;endl; /* double L = A.distance(B); double h = L/2 * tan(18.0/180.0*PI); L = B.distance(Line(E,D).crosspoint(Line(A,B))); double ans = 5*L*h - tmp; printf("%.6lf\n",ans); */ &#125; return 0;&#125; D： Maze最后保留的箱子数肯定是 lcm(n,m)的倍数。 枚举最后的箱子数。 然后使用最小费用最大流去求最小费用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 2010;const int MAXM = 400000;const int INF = 0x3f3f3f3f;long long gcd(long long a,long long b)&#123; if(b == 0)return a; return gcd(b,a%b);&#125;long long lcm(long long a,long long b)&#123; return a/gcd(a,b)*b;&#125;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int N;void init(int n)&#123; N = n; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; N;i++) &#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t)) &#123; int Min = INF; for(int i = pre[t];i != -1;i = pre[edge[i^1].to]) &#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != -1;i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost*Min; &#125; flow += Min; &#125; return flow;&#125;int p[MAXN][MAXN];int main()&#123; //freopen("2.in","r",stdin); //freopen("2.out","w",stdout); int n,m; while(scanf("%d%d",&amp;n,&amp;m) == 2) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) scanf("%d",&amp;p[i][j]); int L = lcm(n,m); int sum = 0; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) sum += p[i][j]; int ans = sum*y; for(int s = L;s &lt;= sum;s+=L) &#123; init(n+m+2); for(int i = 0;i &lt; n;i++) &#123; addedge(n+m,i,s/n,0); if(i &lt; n-1)addedge(i,i+1,INF,x); if(i &gt; 0)addedge(i,i-1,INF,x); &#125; for(int i = 0;i &lt; m;i++) &#123; addedge(i+n,n+m+1,s/m,0); if(i &lt; m-1)addedge(i+n,i+n+1,INF,x); if(i &gt; 0)addedge(i+n,i+n-1,INF,x); &#125; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) addedge(i,j+n,p[i][j],0); int cost; minCostMaxflow(n+m,n+m+1,cost); ans = min(ans,y*(sum-s) + cost); //printf("%d %d\n ",s,ans); &#125; printf("%d\n",ans); &#125; return 0;&#125; E： 喵喵的遗憾就是求斐波那契数列数列取模的循环节。 经典问题。 对于斐波那契数列数列，求其模n的循环节 对于一个正整数n，我们求Fib数模n的循环节的长度的方法如下： （1）把 \(n\)素因子分解，即 \(n = p_{1}^{a_1}p_{2}^{a_2}…….p_{k}^{a_k}\) （2）分别计算Fib数模每个\(p_{i}^{a_i}\)的循环节长度，假设长度分别是\(x_{1},x_{2},……x_{k}\) （3）那么Fib模n的循环节长度\( lcm(x_{1},x_{2},….x_{k}) \) 从上面三个步骤看来，关键就是求Fib数模每个\(p^{m}\)的循环节长度 这里有一个优美的定理：Fib数模的最小循环节长度等于\( G(p)*p^{m-1} \)，其中\(G(p)\)表示Fib数模素数的最小循环节长度。可以看出我们现在最重要的就是求\(G(p)\) 对于求我们利用如下定理： 如果5是模的二次剩余，那么循环节的的长度\(p-1\)是的因子，否则，循环节的长度\(2(p+1)\)是的因子。 顺便说一句，对于小于等于5的素数，我们直接特殊判断，loop(2)=3,loop(3)=8,loop(5)=20。 那么我们可以先求出所有的因子，然后用矩阵快速幂来一个一个判断，这样时间复杂度不会很大。 这样这个问题就解决了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415/* ***************Author :kuangbinCreated Time :2014/6/27 22:43:58File Name :E:\2014ACM\题目\Test\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;long long gcd(long long a,long long b)&#123; if(b == 0)return a; return gcd(b,a%b);&#125;long long lcm(long long a,long long b)&#123; return a/gcd(a,b)*b;&#125;struct Matrix&#123; long long mat[2][2];&#125;;Matrix mul_M(Matrix a,Matrix b,long long mod)&#123; Matrix ret; for(int i = 0;i &lt; 2;i++) for(int j = 0;j &lt; 2;j++) &#123; ret.mat[i][j] = 0; for(int k = 0;k &lt; 2;k++) &#123; ret.mat[i][j] += a.mat[i][k]*b.mat[k][j]%mod; if(ret.mat[i][j] &gt;= mod)ret.mat[i][j] -= mod; &#125; &#125; return ret;&#125;Matrix pow_M(Matrix a,long long n,long long mod)&#123; Matrix ret; memset(ret.mat,0,sizeof(ret.mat)); for(int i = 0;i &lt; 2;i++)ret.mat[i][i] = 1; Matrix tmp = a; while(n) &#123; if(n&amp;1)ret = mul_M(ret,tmp,mod); tmp = mul_M(tmp,tmp,mod); n &gt;&gt;= 1; &#125; return ret;&#125;long long pow_m(long long a,long long n,long long mod)//a^b % mod&#123; long long ret = 1; long long tmp = a%mod; while(n) &#123; if(n&amp;1)ret = ret*tmp%mod; tmp = tmp*tmp%mod; n &gt;&gt;= 1; &#125; return ret;&#125;//素数筛选和合数分解const int MAXN = 1000000;int prime[MAXN+1];void getPrime()&#123; memset(prime,0,sizeof(prime)); for(int i = 2;i &lt;= MAXN;i++) &#123; if(!prime[i])prime[++prime[0]] = i; for(int j = 1;j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN/i;j++) &#123; prime[prime[j]*i] = 1; if(i%prime[j] == 0)break; &#125; &#125;&#125;long long factor[100][2];int fatCnt;int getFactors(long long x)&#123; fatCnt = 0; long long tmp = x; for(int i = 1;prime[i] &lt;= tmp/prime[i];i++) &#123; factor[fatCnt][1] = 0; if(tmp%prime[i] == 0) &#123; factor[fatCnt][0] = prime[i]; while(tmp%prime[i] == 0) &#123; factor[fatCnt][1]++; tmp /= prime[i]; &#125; fatCnt++; &#125; &#125; if(tmp != 1) &#123; factor[fatCnt][0] = tmp; factor[fatCnt++][1] = 1; &#125; return fatCnt;&#125;//勒让德符号int legendre(long long a,long long p)&#123; if(pow_m(a,(p-1)&gt;&gt;1,p) == 1)return 1; else return -1;&#125;int f0 = 1;int f1 = 1;long long getFib(long long n,long long mod)&#123; if(mod == 1)return 0; Matrix A; A.mat[0][0] = 0; A.mat[1][0] = 1; A.mat[0][1] = 1; A.mat[1][1] = 1; Matrix B = pow_M(A,n,mod); long long ret = f0*B.mat[0][0] + f1*B.mat[1][0]; return ret%mod;&#125;long long fac[1000000];long long GG[1000000];long long G(long long p)&#123; if(p &lt; 1000000 &amp;&amp; GG[p] != -1)return GG[p]; long long num; if(legendre(5,p) == 1)num = p-1; else num = 2*(p+1); //找出num的所有约数 int cnt = 0; for(long long i = 1;i*i &lt;= num;i++) if(num%i == 0) &#123; fac[cnt++] = i; if(i*i != num) fac[cnt++] = num/i; &#125; sort(fac,fac+cnt); long long ans; for(int i = 0;i &lt; cnt;i++) &#123; if(getFib(fac[i],p) == f0 &amp;&amp; getFib(fac[i]+1,p) == f1) &#123; ans = fac[i]; break; &#125; &#125; if(p &lt; 1000000)GG[p] = ans; return ans;&#125;long long find_loop(long long n)&#123; getFactors(n); long long ans = 1; for(int i = 0;i &lt; fatCnt;i++) &#123; long long record = 1; if(factor[i][0] == 2)record = 3; else if(factor[i][0] == 3)record = 8; else if(factor[i][0] == 5)record = 20; else record = G(factor[i][0]); for(int j = 1;j &lt; factor[i][1];j++) record *= factor[i][0]; ans = lcm(ans,record); &#125; return ans;&#125;void init()&#123; getPrime();&#125;int main()&#123; //freopen("0.in","r",stdin); //freopen("out.txt","w",stdout); init(); memset(GG,-1,sizeof(GG)); int N,P; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;N,&amp;P); long long mod1 = P; long long mod2 = find_loop(mod1); long long mod3 = find_loop(mod2); long long ans = getFib(N,mod3); ans = getFib(ans,mod2); ans = getFib(ans,mod1); printf("%d\n",(int)ans); &#125; return 0;&#125; F： 飞行棋解方程。 并不需要高斯消元一样去解，直接消就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/* ***************Author :kuangbinCreated Time :2014/6/23 23:37:43File Name :E:\2014ACM\题目\Flying_chess\std.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const double eps = 1e-8;double p[MAXN][10];double a[MAXN][10];double x[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1) &#123; int d1,d2,d3,d4,d5; memset(a,0,sizeof(a)); for(int i = 1;i &lt;= n;i++) x[i] = 1.0; x[n] = 0.0; for(int i = 1;i &lt;= n;i++) &#123; scanf("%d%d%d%d%d",&amp;d1,&amp;d2,&amp;d3,&amp;d4,&amp;d5); p[i][1] = (double)d1/(d1+d2+d3+d4+d5); p[i][2] = (double)d2/(d1+d2+d3+d4+d5); p[i][3] = (double)d3/(d1+d2+d3+d4+d5); p[i][4] = (double)d4/(d1+d2+d3+d4+d5); p[i][5] = (double)d5/(d1+d2+d3+d4+d5); a[i][2] = 1.0; for(int j = 1;j &lt;= 5;j++) &#123; int tmp = i + j - 3; if(tmp &lt;= 0)tmp = 1-tmp; if(tmp &gt; n)tmp = n - (n+1-tmp); a[i][tmp-i+2] -= p[i][j]; &#125; if(i == n) &#123; for(int j = 0;j &lt; 5;j++)a[i][j] = 0.0; a[i][2] = 1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = min(n,i+2);j&gt;i;j--) &#123; double tmp = a[i][j-i+2]; if(fabs(tmp) &lt; eps)continue; for(int k = 0;k&lt;=2 &amp;&amp; j-k &gt; 0;k++) a[i][j-k-i+2] -= a[j][2-k]*tmp; x[i] -= x[j]*tmp; &#125; double q = a[i][2]; for(int j = 0;j &lt; 5;j++) a[i][j] /= q; x[i] /= q; &#125; printf("%.2lf\n",x[1]); &#125; return 0;&#125; G: 喵喵的 Query On Tree数据是随机的。 就是暴力搞吧。 但是DS太不人道了，数据有很大的概率出现了1. 所以要对树根，就是点1的查询，进行特殊处理。 胡搞下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265/* ***************Author :kuangbinCreated Time :2014/6/29 22:50:34File Name :E:\2014ACM\题目\qtree.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10010;struct Edge&#123; int to,next;&#125;edge[MAXN];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int fa[MAXN];int w[MAXN];int dep[MAXN];void dfs(int u,int d)&#123; dep[u] = d; for(int i = head[u];i != -1;i = edge[i].next) dfs(edge[i].to,d+1);&#125;int c[MAXN];int cnt;void dfs1(int u)&#123; c[cnt++] = w[u]; for(int i = head[u];i != -1;i = edge[i].next) dfs1(edge[i].to);&#125;//适用于正负整数template &lt;class T&gt;inline bool scan_d(T &amp;ret) &#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9')) c=getchar(); sgn=(c=='-')?-1:1; ret=(c=='-')?0:(c-'0'); while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9') ret=ret*10+(c-'0'); ret*=sgn; return 1;&#125;inline void out(int x) &#123; if(x&gt;9) out(x/10); putchar(x%10+'0');&#125;multiset&lt;int&gt;st;multiset&lt;int&gt;::iterator it;int main()&#123; //freopen("2.in","r",stdin); //freopen("22.out","w",stdout); int T; int n; int u,v,x; //scanf("%d",&amp;T); scan_d(T); while(T--) &#123; //scanf("%d",&amp;n); scan_d(n); init(); st.clear(); for(int i = 1;i &lt;= n;i++)//scanf("%d",&amp;w[i]); &#123; scan_d(w[i]); st.insert(w[i]); &#125; fa[1] = 0; for(int i = 2;i &lt;= n;i++) &#123; //scanf("%d",&amp;v); scan_d(v); addedge(v,i); fa[i] = v; &#125; dfs(1,1); int Q; char op[10]; scanf("%d",&amp;Q); while(Q--) &#123; scanf("%s",op); if(op[0] == 'C') &#123; //scanf("%d%d%d",&amp;u,&amp;v,&amp;x); scan_d(u); scan_d(v); scan_d(x); while(u != v) &#123; if(dep[u] &lt; dep[v])swap(u,v); it = st.lower_bound(w[u]); st.erase(it); st.insert(x); w[u] = x; u = fa\[u\]; &#125; it = st.lower_bound(w\[u\]); st.erase(it); st.insert(x); w\[u\] = x; &#125; else &#123; //scanf("%d%d",&amp;u,&amp;x); scan_d(u); scan_d(x); if(u == 1) &#123; it = st.begin(); for(int i = 0;i &lt; n-x;i++)it++; printf("%d\\n",*it); continue; &#125; cnt = 0; dfs1(u); sort(c,c+cnt); printf("%d\\n",c\[cnt-x\]); &#125; &#125; &#125; return 0;&#125; H: Driving二分速度。 判断是否可行，然后求时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* ***************Author :kuangbinCreated Time :2014/6/17 23:49:59File Name :E:\2014ACM\题目\Driving\std.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const double eps = 1e-8;const double INF = 1e30;double s[MAXN],b[MAXN];int main()&#123; //freopen("3.in","r",stdin); //freopen("3.out","w",stdout); int n; double f,v; while(scanf("%d",&amp;n) == 1) &#123; scanf("%lf%lf",&amp;f,&amp;v); for(int i = 0;i &lt; n;i++) scanf("%lf%lf",&amp;s[i],&amp;b[i]); double l = 0, r = v; double ans = INF; bool find = false; while(r-l &gt;= eps) &#123; double mid = (l+r)/2; double cost = 0; double t = 0; for(int i = 0;i &lt; n;i++) &#123; if(b[i] &gt;= 0) &#123; cost += (0.5*mid + b[i])*s[i]; t += s[i]/mid; &#125; else &#123; cost += max(0.0,0.5*mid + b[i])*s[i]; if((0.5*mid + b[i]) &lt; eps) t += s[i]/min(v,-b[i]/0.5); else t += s[i]/mid; &#125; &#125; if(cost &lt;= f) &#123; find = true; ans = min(ans,t); l = mid; &#125; else r = mid; &#125; if(!find)printf("Bad Luck!\n"); else printf("%.3lf\n",ans); &#125; return 0;&#125; I： 喵喵的IDE字典树搞。 很水很暴力。 这需要对每个字典树中的点，维护最近的点在哪。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/* ***************Author :kuangbinCreated Time :2014/7/1 21:51:15File Name :E:\2014ACM\题目\IDE.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int INF = 0x3f3f3f3f;struct Trie&#123; int next[1001000][26]; int L[1001000]; int tot,root; int newnode() &#123; for(int i = 0;i &lt; 26;i++) next[tot][i] = -1; L[tot++] = INF; return tot-1; &#125; void init() &#123; tot = 0; root = newnode(); &#125; int insert(char buf[]) &#123; int len = strlen(buf); int ans = len; int now = root; for(int i = 0;i &lt; len;i++) &#123; if(next[now][buf[i]-'a'] == -1) &#123; next[now][buf[i]-'a'] = newnode(); now = next[now][buf[i]-'a']; &#125; else &#123; now = next[now][buf[i]-'a']; ans = min(ans,1+L[now]+len-1-i); &#125; L[now] = min(L[now],len-1-i); &#125; return ans; &#125;&#125;;Trie tree;char str[1000010];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; scanf("%d",&amp;T); while(T--) &#123; tree.init(); scanf("%d%s",&amp;n,str); tree.insert(str); for(int i = 0;i &lt; n;i++) &#123; scanf("%s",str); printf("%d\n",tree.insert(str)); &#125; &#125; return 0;&#125; J: Base Station简单数据结构。 到两个基站的距离，其实就构成了二维坐标。 其中一个按照顺序加入，另外一维用一维树状数组就可以查询了。 不多说了，很水很暴力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231/* ***************Author :kuangbinCreated Time :2014/6/25 16:17:04File Name :E:\2014ACM\题目\Base_Station\std.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int c[100010];int lowbit(int x)&#123; return x&amp;(-x);&#125;int n;void add(int i,int val)&#123; while(i &lt;= n) &#123; c[i] += val; i += lowbit(i); &#125;&#125;int sum(int i)&#123; int s = 0; while(i &gt; 0) &#123; s += c[i]; i -= lowbit(i); &#125; return s;&#125;struct Node&#123; long long x,y;&#125;p[100010];bool cmp(Node a,Node b)&#123; return a.x &gt; b.x;&#125;struct Query&#123; long long r1,r2; int index;&#125;query[100010];int ans[100010];bool cmp2(Query a,Query b)&#123; return a.r1 &gt; b.r1;&#125;long long b[100010];int main()&#123; //freopen("2.in","r",stdin); //freopen("2.out","w",stdout); int x1,y1,x2,y2; int x,y; while(scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2) == 4) &#123; scanf("%d",&amp;n); memset(c,0,sizeof(c)); int tot = 0; for(int i = 0;i &lt; n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); long long dx1 = x1-x; long long dy1 = y1-y; long long dx2 = x2-x; long long dy2 = y2-y; long long tmp1 = dx1*dx1+dy1*dy1; long long tmp2 = dx2*dx2+dy2*dy2; p[i].x = tmp1; p[i].y = tmp2; b[++tot] = tmp2; &#125; sort(p,p+n,cmp); sort(b+1,b+tot+1); tot = unique(b+1,b+tot+1) - b - 1; int m; int r1,r2; scanf("%d",&amp;m); for(int i = 0;i &lt; m;i++) &#123; scanf("%d%d",&amp;r1,&amp;r2); query[i].r1 = (long long)r1*r1; query[i].r2 = (long long)r2*r2; query[i].index = i; &#125; sort(query,query+m,cmp2); int id = 0; for(int i = 0;i &lt; m;i++) &#123; while(id &lt; n &amp;&amp; p\[id\].x &gt;= query[i].r1) &#123; int loc = lower_bound(b+1,b+tot+1,p[id].y) - b; add(loc,1); id++; &#125; int L = lower_bound(b+1,b+tot+1,query[i].r2) - b; ans[query[i].index] = sum(n) - sum(L-1); &#125; for(int i = 0;i &lt; m;i++) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Regionals 2012 :: Europe - Central]]></title>
    <url>%2F2014%2F07%2F02%2Fregionals-2012-europe-central%2F</url>
    <content type="text"><![CDATA[题目链接：UVALiveVJ比赛地址： here 总体来说，还是有几道好题的。 A： Kingdoms题目就是给出了n个人之间的欠款。 每次可以把负债的人删除，问最后只留下一个人，有多少种。 进行DP转移，状态压缩DP。 /* ***Author :kuangbinCreated Time :2014/6/29 21:18:34File Name :E:\2014ACM\区域赛练习\2012\2012CERC\A.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; bool dp[(1&lt;&lt;20)+20];int two[22];int a[22][22];int s[22][(1&lt;&lt;20)+20];int loc[(1&lt;&lt;22)]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); two[0] = 1; for(int i = 1;i &lt; 22;i++) { two[i] = 2*two[i-1]; loc[two[i]] = i; } while(T–) { scanf(“%d”,&amp;n); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) scanf(“%d”,&amp;a[i][j]); for(int i = 0;i &lt; n;i++) { s[i][0] = 0; for(int j = 0;j &lt; n;j++) s[i][0] += a[i][j]; } for(int i = 0;i &lt; n;i++) for(int j = 1;j &lt; two[n];j++) s[i][j] = s[i][j&amp;(j-1)] - a[i][loc[j&amp;(-j)]]; memset(dp,false,sizeof(dp)); dp[0] = true; for(int i = 0;i &lt; two[n];i++) if(dp[i]) { for(int j = 0;j &lt; n;j++) if((i&amp;two[j]) == 0 &amp;&amp; s[j][i] &gt; 0) dp[i^two[j]] = true; } vectorans; for(int i = 0;i &lt; n;i++) if(dp[(two[n]-1)^two[i]]) ans.push_back(i); if(ans.size() == 0)printf(“0\n”); else { sort(ans.begin(),ans.end()); int sz = ans.size(); for(int i = 0;i &lt; sz;i++) { printf(“%d”,ans[i]+1); if(i &lt; sz-1)printf(“ “); else printf(“\n”); } } } return 0;} B: Who wants to live forever?给出一个01的字符串，每次用s[i-1] xor s[i+1] 去更新s[i], 问最后能不能变成全0 规律题。 C: Chemist’s vows纯暴力，打那个表太费劲了。 /* ***Author :kuangbinCreated Time :2014/6/29 21:53:44File Name :E:\2014ACM\区域赛练习\2012\2012CERC\C.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;char str[114][10] ={ “h” ,”he”,”li”,”be”,”b” ,”c” ,”n” ,”o” ,”f” ,”ne”, “na”,”mg”,”al”,”si”,”p” ,”s” ,”cl”,”ar”,”k” ,”ca”, “sc”,”ti”,”v” ,”cr”,”mn”,”fe”,”co”,”ni”,”cu”,”zn”, “ga”,”ge”,”as”,”se”,”br”,”kr”,”rb”,”sr”,”y” ,”zr”, “nb”,”mo”,”tc”,”ru”,”rh”,”pd”,”ag”,”cd”,”in”,”sn”, “sb”,”te”,”i” ,”xe”,”cs”,”ba”,”hf”,”ta”,”w” ,”re”, “os”,”ir”,”pt”,”au”,”hg”,”tl”,”pb”,”bi”,”po”,”at”, “rn”,”fr”,”ra”,”rf”,”db”,”sg”,”bh”,”hs”,”mt”,”ds”, “rg”,”cn”,”fl”,”lv”, “la”,”ce”,”pr”,”nd”,”pm”,”sm”,”eu”,”gd”,”tb”,”dy”,”ho”,”er”,”tm”,”yb”,”lu”, “ac”,”th”,”pa”,”u” ,”np”,”pu”,”am”,”cm”,”bk”,”cf”,”es”,”fm”,”md”,”no”,”lr”};bool f[50010]; char s[50010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); while(T–) { scanf(“%s”,s); memset(f,0,sizeof(s)); int n = strlen(s); f[0] = true; for(int i = 1;i &lt;= n;i++) { for(int j = 0;j &lt; 114;j++) { int len = strlen(str[j]); if(len == 1 &amp;&amp; s[i-1] == str[j][0]) f[i] |= f[i-1]; if(len == 2 &amp;&amp; i &gt;= 2 &amp;&amp; s[i-1] == str[j][1] &amp;&amp; s[i-2] == str[j][0]) f[i] |= f[i-2]; } } if(f[n])printf(“YES\n”); else printf(“NO\n”); } return 0;} D： Non-boring sequences要求任意一个连续子序列都要有一个唯一的元素。 一种做法是分治。 判断一个区间的时候，找出这个区间里面唯一元素，然后分治。 但是为了防止退化，找唯一元素应该从两端找起。就是一前一后找。 如果按照顺序找，是有可能退化的。 代码： /* ***Author :kuangbinCreated Time :2014/6/29 22:20:39File Name :E:\2014ACM\区域赛练习\2012\2012CERC\D1.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 200010;int a[MAXN];int L[MAXN];int R[MAXN];bool check(int l,int r){ if(r &lt;= l)return true; int index = -1; for(int i = 0;i &lt; (r-l+1);i++) { int id = i&amp;1? l+i/2:r-i/2; if(L[id] &lt; l &amp;&amp; R[id] &gt; r) { index = id; break; } } if(index == -1)return false; return check(l,index-1) &amp;&amp; check(index+1,r);} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); while(T–) { scanf(“%d”,&amp;n); for(int i = 1;i &lt;= n;i++)scanf(“%d”,&amp;a[i]); map&lt;int,int&gt;mp; for(int i = 1;i &lt;= n;i++) { if(mp.find(a[i]) == mp.end())L[i] = 0; else L[i] = mp[a[i]]; mp[a[i]] = i; } mp.clear(); for(int i = n;i &gt;= 1;i–) { if(mp.find(a[i]) == mp.end())R[i] = n+1; else R[i] = mp[a[i]]; mp[a[i]] = i; } if(check(1,n))printf(“non-boring\n”); else printf(“boring\n”); } return 0;} 另外一种做法是用线段树做的。 维护一个区间的最小值，然后更新区间的值。 /* ***Author :kuangbinCreated Time :2014/6/29 22:32:15File Name :E:\2014ACM\区域赛练习\2012\2012CERC\D2.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 200010;struct Node{ int l,r; int Min; int lazy;}segTree[MAXN*4];int a[MAXN];void Update_Min(int i,int val){ if(segTree[i].Min &lt; val) { segTree[i].Min = val; segTree[i].lazy = val; }}void push_down(int i){ if(segTree[i].l == segTree[i].r)return; if(segTree[i].lazy != -1) { Update_Min(i&lt;&lt;1,segTree[i].lazy); Update_Min((i&lt;&lt;1)|1,segTree[i].lazy); segTree[i].lazy = -1; }}void push_up(int i){ if(segTree[i].l == segTree[i].r)return; segTree[i].Min = min(segTree[i&lt;&lt;1].Min,segTree[(i&lt;&lt;1)|1].Min);}void build(int i,int l,int r){ segTree[i].l = l; segTree[i].r = r; segTree[i].lazy = -1; if(l == r) { segTree[i].Min = a[l]; return; } int mid = (l+r)/2; build(i&lt;&lt;1,l,mid); build((i&lt;&lt;1)|1,mid+1,r); push_up(i);}void update(int i,int l,int r,int val){ if(segTree[i].l == l &amp;&amp; segTree[i].r == r) { Update_Min(i,val); return; } push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)update(i&lt;&lt;1,l,r,val); else if(l &gt; mid)update((i&lt;&lt;1)|1,l,r,val); else { update(i&lt;&lt;1,l,mid,val); update((i&lt;&lt;1)|1,mid+1,r,val); } push_up(i);}int query(int i,int l,int r){ if(segTree[i].l == l &amp;&amp; segTree[i].r == r) return segTree[i].Min; push_down(i); int mid = (segTree[i].l + segTree[i].r)/2; if(r &lt;= mid)return query(i&lt;&lt;1,l,r); else if(l &gt; mid)return query((i&lt;&lt;1)|1,l,r); else { return min(query(i&lt;&lt;1,l,mid),query((i&lt;&lt;1)|1,mid+1,r)); }}int b[MAXN];int L[MAXN];int R[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n; int T; scanf(“%d”,&amp;T); while(T–) { scanf(“%d”,&amp;n); for(int i = 1;i &lt;= n;i++) scanf(“%d”,&amp;b[i]); map&lt;int,int&gt;mp; for(int i = 1;i &lt;= n;i++) { if(mp.find(b[i]) == mp.end())L[i] = 1; else L[i] = mp[b[i]]+1; mp[b[i]] = i; } mp.clear(); for(int i = n;i &gt;= 1;i–) { if(mp.find(b[i]) == mp.end())R[i] = n; else R[i] = mp[b[i]]-1; mp[b[i]] = i; a[i] = R[i]; } build(1,1,n); bool flag = true; for(int i = 2;i &lt;= n;i++) { if(query(1,1,i-1) &lt; i) { flag = false; break; } update(1,L[i],i,R[i]); } if(flag)printf(“non-boring\n”); else printf(“boring\n”); } return 0;} E: Word equationsDP dp[i][j] 表示第i个点，从j这个位置匹配，匹配到的最远位置。 /* ***Author :kuangbinCreated Time :2014/7/2 13:06:54File Name :E:\2014ACM\区域赛练习\2012\2012CERC\E.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 1010; map&lt;string,int&gt;mp;vectorvec[MAXN];char s[MAXN][10]; char str1[20],str2[20],str3[20];char aim[2020];int n;int dp[MAXN][2020];void solve(int u){ if(dp[u][0] != -1)return ; if(vec[u].size() == 2) { solve(vec[u][0]); solve(vec[u][1]); for(int i = 0;i &lt;= n;i++) dp[u][i] = dp[vec[u][1]][dp[vec[u][0]][i]]; } else { int v = vec[u][0]; dp[u][n] = n; int len = strlen(s[v]); for(int i = 0;i &lt; n;i++) { int id1 = i; int id2 = 0; while(id1 &lt; n &amp;&amp; id2 &lt; len) { while(id2 &lt; len &amp;&amp; aim[id1] != s[v][id2]) id2++; if(id2 &lt; len &amp;&amp; aim[id1] == s[v][id2]) { id1++; id2++; } } dp[u][i] = id1; } }} int main(){ //freopen(“3.in”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int k; scanf(“%d”,&amp;T); while(T–) { scanf(“%d”,&amp;k); for(int i = 0;i &lt; MAXN;i++) vec[i].clear(); mp.clear(); int tot = 0; for(int i = 0;i &lt; k;i++) { scanf(“%s = %s”,str1,str2); if(mp.find(str1) == mp.end()) { strcpy(s[tot],str1); mp[str1] = tot++; } if(mp.find(str2) == mp.end()) { strcpy(s[tot],str2); mp[str2] = tot++; } vec[mp[str1]].push_back(mp[str2]); if(str2[0] &gt;= ‘A’ &amp;&amp; str2[0] &lt;= ‘Z’) { scanf(“%s%s”,str2,str3); if(mp.find(str3) == mp.end()) { strcpy(s[tot],str3); mp[str3] = tot++; } vec[mp[str1]].push_back(mp[str3]); } } scanf(“%s%s”,str1,aim); n = strlen(aim); memset(dp,-1,sizeof(dp)); solve(mp[str1]); if(dp[mp[str1]][0] == n) printf(“YES\n”); else printf(“NO\n”); } return 0;} G: Jewel heist从低到高扫描。 各类点分别处理，找出一个个小矩形。 /* ***Author :kuangbinCreated Time :2014/7/2 21:32:41File Name :E:\2014ACM\区域赛练习\2012\2012CERC\G.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 200010;struct BIT{ int c[MAXN]; int n; int lowbit(int x) { return x&amp;(-x); } void init(int _n) { n = _n; memset(c,0,sizeof(c)); } void add(int i,int val) { while(i &lt;= n) { c[i] += val; i += lowbit(i); } } int sum(int i) { int s = 0; while(i &gt; 0) { s += c[i]; i -= lowbit(i); } return s; } int sum(int l,int r) { if(l &gt; r)return 0; return sum(r) - sum(l-1); }}bt;struct Point{ int x,y; int c;}p[MAXN];bool cmp(Point p1,Point p2){ return p1.y &lt; p2.y;}int sx[MAXN]; setst[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,k; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d”,&amp;n,&amp;k); int tot = 0; for(int i = 0;i &lt; n;i++) { scanf(“%d%d%d”,&amp;p[i].x,&amp;p[i].y,&amp;p[i].c); sx[tot++] = p[i].x; } sort(sx,sx+tot); tot = unique(sx,sx+tot) - sx; bt.init(tot); for(int i = 0;i &lt; n;i++) p[i].x = lower_bound(sx,sx+tot,p[i].x) - sx + 1; sort(p,p+n,cmp); for(int i = 1;i &lt;= k;i++) st[i].clear(); for(int i = 1;i &lt;= k;i++) { st[i].insert(0); st[i].insert(tot+1); } int ans = 0; set::iterator it; for(int i = 0;i &lt; n;i++) { int ni = i; for(;ni &lt; n &amp;&amp; p[ni].y == p[i].y;ni++) { it = st[p[ni].c].lower_bound(p[ni].x); int end = (it)-1; it–; int start = (it)+1; ans = max(ans,bt.sum(start,end)); } for(int j = i;j &lt; ni;j++) { bt.add(p[j].x,1); st[p[j].c].insert(p[j].x); } i = ni-1; } for(int i = 1;i &lt;= k;i++) { it = st[i].begin(); it++; int pre = 0; while(it != st[i].end()) { ans = max(ans,bt.sum(pre+1,(it)-1)); pre = it; it++; } } printf(“%d\n”,ans); } return 0;} H: Darts水题，不解释。 /* ***Author :kuangbinCreated Time :2014/7/2 19:48:35File Name :E:\2014ACM\区域赛练习\2012\2012CERC\CERC2012\e\H.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); while(T–) { scanf(“%d”,&amp;n); int ans = 0; int x,y; while(n–) { scanf(“%d%d”,&amp;x,&amp;y); for(int i = 10;i &gt;= 1;i–) if(x*x + y*y &lt;= 20(11-i)\20*(11-i)) { ans += i; break; } } printf(“%d\n”,ans); } return 0;} I： The Dragon and the knightsN条直线，把平面分成了若干部分，需要判断是不是每个区域都有人。 首先使用公式求出分成的区域。 然后使用了set去判断，就是点在直线的哪一侧，就可以知道在哪个区域了。 #include &lt;stdio.h&gt; #include #include #include #include #include &lt;string.h&gt; #include #include #include #include &lt;math.h&gt;using namespace std; int A[110],B[110],C[110];int X[50010],Y[50010]; bool check(int i,int j){ long long tmp = (long long)A[i]*B[j] - (long long)B[i]*A[j]; if(tmp == 0)return false; return true;} set&lt;pair &gt;st;int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; int T; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d”,&amp;n,&amp;m); for(int i = 0;i &lt; n;i++)scanf(“%d%d%d”,&amp;A[i],&amp;B[i],&amp;C[i]); for(int i = 0;i &lt; m;i++)scanf(“%d%d”,&amp;X[i],&amp;Y[i]); int E = 0; int V = 0; for(int i = 0;i &lt; n;i++) { int cnt = 0; for(int j = 0;j &lt; n;j++) if(i != j) if(check(i,j)) cnt++; E += cnt+1; V += cnt; } V /= 2; int tot = 1+E - V; st.clear(); for(int i = 0;i &lt; m;i++) { long long tmp1 = 0; long long tmp2 = 0; for(int j = 0;j &lt; n;j++) { long long tmp = (long long)A[j]*X[i] + (long long)B[j]*Y[i] + C[j]; if(tmp &gt; 0) { if(j &lt; 50) tmp1 |= (1LL &lt;&lt; j); else tmp2 |= (1LL &lt;&lt; (j-50)); } } st.insert(make_pair(tmp1,tmp2)); } if(st.size() == tot)printf(“PROTECTED\n”); else printf(“VULNERABLE\n”); } return 0;} J： Conservation使用两个队列进行拓扑排序。 本题数据组数很多，如果用memset初始化会慢非常多。 /* ***Author :kuangbinCreated Time :2014/7/2 20:12:02File Name :E:\2014ACM\区域赛练习\2012\2012CERC\J.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;const int MAXM = 1000010;const int INF = 0x3f3f3f3f;struct Edge{ int to,next;}edge[MAXM];int head[MAXN],tot;void init(){ tot = 0; //memset(head,-1,sizeof(head));}void addedge(int u,int v){ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}int a[MAXN];int in[MAXN];int tmpin[MAXN];int solve(int s,int n){ for(int i = 1;i &lt;= n;i++) in[i] = tmpin[i]; queueq[2]; for(int i = 1;i &lt;= n;i++) if(in[i] == 0) q[a[i]].push(i); int now = s; int ans = 0; int cnt = 0; while(1) { if(q[now].empty())break; ans++; while(!q[now].empty()) { int u = q[now].front(); q[now].pop(); cnt++; for(int i = head[u];i != -1;i = edge[i].next) { int v = edge[i].to; in[v]–; if(in[v] == 0) q[a[v]].push(v); } } now ^= 1; } if(cnt != n)return INF; return ans-1;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,m; int u,v; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d”,&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) { scanf(“%d”,&amp;a[i]); a[i]–; } init(); for(int i = 1;i &lt;= n;i++) { head[i] = -1; in[i] = 0; } //memset(in,0,sizeof(in)); while(m–) { scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); in[v]++; } for(int i = 1;i &lt;= n;i++)tmpin[i] = in[i]; printf(“%d\n”,min(solve(0,n),solve(1,n))); } return 0;}]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OK】2010 Europe - Northwestern]]></title>
    <url>%2F2014%2F06%2F07%2F2010nwerc%2F</url>
    <content type="text"><![CDATA[2010 Europe - Northwestern开的比赛地址：HUST VJUVALive 题目链接：here A: Fair Division题目是给n个数，要在每一个数里面取出一部分来，组成和为p的。 尽量平分， 数值大、排在前面的先出。 直接暴力搞就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* ***************Author :kuangbinCreated Time :2014/5/3 22:57:22File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int a[110];int order[110];bool cmp(int t1,int t2)&#123; if(a[t1] != a[t2])return a[t1] &gt; a[t2]; else return t1 &lt; t2;&#125;int b[110];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int p,n; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;p,&amp;n); int sum = 0; for(int i = 0;i &lt; n;i++) &#123; scanf("%d",&amp;a[i]); sum += a[i]; &#125; if(sum &lt; p) &#123; printf("IMPOSSIBLE\n"); continue; &#125; for(int i = 0;i &lt; n;i++) order[i] = i; sort(order,order+n,cmp); int t = p/n; for(int i = 0;i &lt; n;i++) &#123; b[i] = min(a[i],t); p -= b[i]; &#125; int i = 0; while(p) &#123; while(b[order[i]] == a[order[i]]) i = (i+1)%n; b[order[i]]++; i = (i+1)%n; p--; &#125; for(int i = 0;i &lt; n;i++) &#123; printf("%d",b[i]); if(i &lt; n-1)printf(" "); else printf("\n"); &#125; &#125; return 0;&#125; B： Free Goodies题目意思是：有n个东西，Petra and Jan两个人轮流取。 每个东西对两个人各有一个价值。 Petra每次取得原则是取对自己价值最大的，如果相同则取对Jan价值最小的。 Jan取得原则是让最后自己的总价值最大，相同的时候让Prtra的总价值最大。 题目输入了谁先取，以及每个东西对各个人的价值。 求最后他们得到的价值和。 这题其实重要的是Prtea取法简单。 可以把东西按照对Petra价值从大到小，相等则Jan价值从小到大。 然后进行DP， Jan 取得最大价值，前i个里面，Jan最多取一半。 然后进行DP转移就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217/* ***************Author :kuangbinCreated Time :2014/5/3 23:09:10File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1010;struct Node&#123; int p,j; void input() &#123; scanf("%d%d",&amp;p,&amp;j); &#125;&#125;node[MAXN];bool cmp(Node a,Node b)&#123; if(a.p != b.p)return a.p &gt; b.p; else return a.j &lt; b.j;&#125;int dp1[MAXN][MAXN];int dp2[MAXN][MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; char name[20]; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%s",&amp;n,name); for(int i = 1;i &lt;= n;i++) node[i].input(); sort(node+1,node+n+1,cmp); memset(dp1,-1,sizeof(dp1)); memset(dp2,-1,sizeof(dp2)); dp1[0][0] = 0; dp2[0][0] = 0; if(name[0] == 'P') &#123; for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt;= i/2;j++) &#123; if(j &gt; 0) &#123; if(dp1[i][j] &lt; dp1[i-1][j-1] + node[i].j || (dp1[i][j] == dp1[i-1][j-1] + node[i].j &amp;&amp; dp2[i][j] &gt; dp2[i-1][j-1] + node[i].p)) &#123; dp1[i][j] = dp1[i-1][j-1] + node[i].j; dp2[i][j] = dp2[i-1][j-1] + node[i].p; &#125; &#125; if(j &lt;= (i-1)/2) &#123; if(dp1[i][j] &lt; dp1[i-1][j] || (dp1[i][j] == dp1[i-1][j] &amp;&amp; dp2[i][j] &gt; dp2[i-1][j])) &#123; dp1[i][j] = dp1[i-1][j]; dp2[i][j] = dp2[i-1][j]; &#125; &#125; &#125; int sum = 0; for(int i = 1;i &lt;= n;i++) sum += node[i].p; printf("%d %d\n",sum-dp2[n][n/2],dp1[n][n/2]); &#125; else &#123; for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt;= (i+1)/2;j++) &#123; if(j &gt; 0) &#123; if(dp1[i][j] &lt; dp1[i-1][j-1] + node[i].j || (dp1[i][j] == dp1[i-1][j-1] + node[i].j &amp;&amp; dp2[i][j] &gt; dp2[i-1][j-1] + node[i].p)) &#123; dp1[i][j] = dp1[i-1][j-1] + node[i].j; dp2[i][j] = dp2[i-1][j-1] + node[i].p; &#125; &#125; if(j &lt;= (i)/2) &#123; if(dp1[i][j] &lt; dp1[i-1][j] || (dp1[i][j] == dp1[i-1][j] &amp;&amp; dp2[i][j] &gt; dp2[i-1][j])) &#123; dp1[i][j] = dp1[i-1][j]; dp2[i][j] = dp2[i-1][j]; &#125; &#125; &#125; int sum = 0; for(int i = 1;i &lt;= n;i++) sum += node[i].p; printf("%d %d\n",sum-dp2[n][(n+1)/2],dp1[n][(n+1)/2]); &#125; &#125; return 0;&#125; C: High Score需要将一个全A的字符串，变换为目标串。 现在的位置在第1个。 每步操作可以左右移动，或者将字母翻到上一个或者下一个。 求最小步数。 直接枚举不需要变动的区间，走法就两种。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* ***************Author :kuangbinCreated Time :2014/5/3 23:28:19File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;char str[1010];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s",str); int n = strlen(str); int ans1 = 0; for(int i = 0;i &lt; n;i++) ans1 += min(str[i] - 'A','Z' - str[i] + 1); int ans = ans1 + n-1; for(int i = 0;i &lt; n;i++) if(str[i] == 'A') &#123; int j = i; while(j &lt; n &amp;&amp; str[j] == 'A')j++; ans = min(ans,ans1 + max(0,i-1)*2 + n - j); ans = min(ans,ans1 + max(0,i-1) + 2*(n-j)); &#125; printf("%d\n",ans); &#125; return 0;&#125; D: Hill Driving 二分+判断。 二分速度，然后进行判断。 注意下坡的情况。 这题要1e-10才能A， 1e-8WA了好久。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* ***************Author :kuangbinCreated Time :2014/6/5 23:38:01File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10010;const double eps = 1e-10;const double INF = 1e30;double x[MAXN],y[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); double a,b,v,f; int n; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;v,&amp;f); scanf("%d",&amp;n); for(int i = 0;i &lt; n;i++) &#123; scanf("%lf%lf",&amp;x[i],&amp;y[i]); x[i] /= 1000; y[i] /= 1000; &#125; double l = 0, r = v; double ans = INF; bool find = false; while(r - l &gt;= eps) &#123; double mid = (l+r)/2; double cost = 0.0; double t = 0.0; for(int i = 0;i &lt; n;i++) &#123; if(y[i] &gt;= 0) &#123; cost += (a*mid+b*y[i]/x[i])*hypot(x[i],y[i]); t += hypot(x[i],y[i])/mid; &#125; else &#123; cost += max(0.0,a*mid+b*y[i]/x[i])*hypot(x[i],y[i]); if( (a*mid+b*y[i]/x[i]) &lt; eps ) t += hypot(x[i],y[i])/min(v,-b*y[i]/x[i]/a); else t += hypot(x[i],y[i])/mid; &#125; &#125; //printf("%lf %lf %lf\n",mid,cost,t); if(cost &lt;= f) &#123; find = true; ans = min(ans,t); l = mid; &#125; else r = mid; &#125; if(!find)printf("IMPOSSIBLE\n"); else printf("%.8lf\n",ans); &#125; return 0;&#125; E： Rankings这题不会有不确定的情况。 因为任意两个之间的先后顺序都是知道的，进行拓扑排序，就可以判断是不是存在了，按照顺序输出就是答案了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/* ***************Author :kuangbinCreated Time :2014/5/6 22:57:39File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 550;int g[MAXN][MAXN];int in[MAXN];bool f[MAXN][MAXN];int rank[MAXN];vector&lt;int&gt;ans;bool used[MAXN];bool solve(int n)&#123; ans.clear(); memset(used,false,sizeof(used)); for(int t = 0;t &lt; n;t++) &#123; int k = -1; for(int i = 1;i &lt;= n;i++) if(!used[i] &amp;&amp; in[i] == 0) &#123; k = i; break; &#125; if(k == -1)return false; used[k] = true; for(int i = 1;i &lt;= n;i++) if(!used[i] &amp;&amp; g[k][i]) in[i]--; ans.push_back(k); &#125; return true;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); memset(g,0,sizeof(g)); memset(f,false,sizeof(f)); int a; for(int i = 1;i &lt;= n;i++) &#123; scanf("%d",&amp;a); rank[a] = i; &#125; int m; int u,v; scanf("%d",&amp;m); while(m--) &#123; scanf("%d%d",&amp;u,&amp;v); f[u][v] = true; &#125; memset(in,0,sizeof(in)); for(int i = 1;i &lt;= n;i++) for(int j = i+1;j &lt;= n;j++) &#123; if(f[i][j]) &#123; if(rank[i] &lt; rank[j]) &#123; g[i][j] = true; in[j]++; &#125; else &#123; g[j][i] = true; in[i]++; &#125; &#125; else &#123; if(rank[i] &gt; rank[j]) &#123; g[i][j] = true; in[j]++; &#125; else &#123; g[j][i] = true; in[i]++; &#125; &#125; &#125; if(!solve(n))printf("IMPOSSIBLE\n"); else &#123; for(int i = ans.size()-1;i &gt;= 0;i--) &#123; printf("%d",ans[i]); if(i &gt; 0)printf(" "); else printf("\n"); &#125; &#125; &#125; return 0;&#125; F: Risk 二分+ 最大流。 使用最大流去判断，经典的网络流构图。 注意二分上界的选取，不要选小了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325/* ***************Author :kuangbinCreated Time :2014/6/8 10:39:09File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1000;const int MAXM = 100000;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];int tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u]; edge[tol].flow = 0;head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v]; edge[tol].flow = 0;head[v] = tol++;&#125;int sap(int start,int end,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; for(int i = pre[u];i != -1;i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u];i != -1;i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; &#125; u = start; ans += Min; continue; &#125; bool flag = false; int v; for(int i = cur[u];i != -1;i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = pre[v] = i; break; &#125; &#125; if(flag) &#123; u = v; continue; &#125; int Min = N; for(int i = head[u];i != -1;i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start)u = edge[pre[u]^1].to; &#125; return ans;&#125;int a[110];char g[110][110];bool f[110];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i = 0;i &lt; n;i++)scanf("%d",&amp;a[i]); for(int i = 0;i &lt; n;i++)scanf("%s",g[i]); memset(f,false,sizeof(f)); for(int i = 0;i &lt; n;i++) if(a[i] == 0) for(int j = 0;j &lt; n;j++) if(g[i][j] == 'Y' &amp;&amp; a[j] &gt; 0) f[j] = true; int ans; int l = 1, r = 100000; while(l &lt;= r) &#123; int mid = (l+r)/2; init(); int start = 2*n; int end = 2*n+1; for(int i = 0;i &lt; n;i++) if(a[i] &gt; 0) addedge(start,2*i,a[i]); for(int i = 0;i &lt; n;i++) if(a[i] &gt; 0) addedge(2*i,2*i+1,INF); for(int i = 0;i &lt; n;i++) if(a[i]) for(int j = 0;j &lt; n;j++) if(a[j] &amp;&amp; g[i][j] == 'Y') addedge(2*i,2*j+1,INF); int sum = 0; for(int i = 0;i &lt; n;i++) if(a[i]) &#123; if(f[i]) &#123; addedge(2*i+1,end,mid); sum += mid; &#125; else &#123; addedge(2*i+1,end,1); sum += 1; &#125; &#125; if(sap(start,end,2*n+2) == sum) &#123; ans = mid; l = mid+1; &#125; else r = mid-1; &#125; printf("%d\n",ans); &#125; return 0;&#125; G: Selling Land 这题主要是要看懂题目。 看懂了发现就是DP。 对每个空格子进行DP，找一个以这个格子为右下角的周长最长的矩形。 这题使用单调队列进行优化的做法非常经典，赞！！！！！新技能get 具体看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* ***************Author :kuangbinCreated Time :2014/6/8 23:04:48File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1010;char str[MAXN][MAXN];int up[MAXN][MAXN];int ans[4*MAXN];int que[MAXN];int a[MAXN];int id[MAXN];int b[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); memset(ans,0,sizeof(ans)); for(int i = 0;i &lt; n;i++) &#123; scanf("%s",str[i]); int top = 0; id[top] = -1; for(int j = 0;j &lt; m;j++) &#123; if(str[i][j] == '#')up[i][j] = 0; else &#123; if(i == 0)up[i][j] = 1; else up[i][j] = up[i-1][j] + 1; &#125; if(up[i][j] == 0) &#123; top = 0; id[top] = j; continue; &#125; while(top &gt; 0 &amp;&amp; a[top] &gt;= up[i][j])top--; a[++top] = up[i][j]; id[top] = j; b[top] = a[top] - id[top-1]; if(top &gt; 1)b[top] = max(b[top],b[top-1]); int tmp = 2*(j+b[top]); ans[tmp]++; &#125; &#125; for(int i = 1;i &lt;= 2*(n+m);i++) if(ans[i]) printf("%d x %d\n",ans[i],i); &#125; return 0;&#125; H: 就是简单的模拟，读懂题意就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;math.h&gt;#include &lt;string&gt;using namespace std;struct Node&#123; int x,y; int type;&#125;node[1010];char op[20];int sell[1010];int buy[1010];int main()&#123; //freopen("in.txt", "r", stdin); int T; int n; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); memset(sell,0,sizeof(sell)); memset(buy,0,sizeof(buy)); int last = -1; int ans1 = -1; int ans2 = -1; for(int i = 0;i &lt; n;i++) &#123; scanf("%s %d shares at %d",op,&amp;node[i].x,&amp;node[i].y); if(op[0] == 's')node[i].type = 0; else node[i].type = 1; if(node[i].type == 0)sell[node[i].y] += node[i].x; else buy[node[i].y] += node[i].x; ans1 = -1; for(int j = 1;j &lt;= 1000;j++) if(sell[j]) &#123; ans1 = j; break; &#125; ans2 = -1; for(int j = 1000;j&gt;=1;j--) if(buy[j]) &#123; ans2 = j; break; &#125; while(ans1 != -1 &amp;&amp; ans2 != -1&amp;&amp; ans2 &gt;= ans1) &#123; last = ans1; int tmp = min(sell[ans1],buy[ans2]); sell[ans1] -= tmp; buy[ans2] -= tmp; ans1 = -1; for(int j = 1;j &lt;= 1000;j++) if(sell[j]) &#123; ans1 = j; break; &#125; ans2 = -1; for(int j = 1000;j&gt;=1;j--) if(buy[j]) &#123; ans2 = j; break; &#125; &#125; ans1 = -1; for(int j = 1;j &lt;= 1000;j++) if(sell[j]) &#123; ans1 = j; break; &#125; ans2 = -1; for(int j = 1000;j&gt;=1;j--) if(buy[j]) &#123; ans2 = j; break; &#125; if(ans1 == -1)printf("- "); else printf("%d ",ans1); if(ans2 == -1)printf("- "); else printf("%d ",ans2); if(last == -1)printf("-\n"); else printf("%d\n",last); &#125; &#125; return 0;&#125; I： Telephone Network 题目意思大致是 看那个图就知道了。 N输入，N输出的网络。N = 2^k 不停地分层。 2^k 输入输出的网络分成两个2^(k-1)输入输出的网络。 题目看起来很复杂。 其实很简单的一个题，题意太难懂了。 只需要在每个分层的时候，使用二分图染色，分层两部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259/* ***************Author :kuangbinCreated Time :2014/6/14 10:49:42File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\I.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;pair&lt;int,int&gt;p[100010];int Index[100010];int tmpIndex[100010];int ans[100010];vector&lt;int&gt;vec[100010];int color[100010];bool dfs(int u,int col)&#123; color[u] = col; int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++) &#123; int v = vec[u][i]; if(color[v] != -1) &#123; if(color[v] == col)return false; continue; &#125; if(!dfs(v,!col))return false; &#125; return true;&#125;struct Node&#123; int val; int id;&#125;node[100010];bool cmp(Node a,Node b)&#123; return a.val &lt; b.val;&#125;void solve(int n,int l,int r)&#123; if(n == 0)return; if(l &gt;= r)return; for(int i = l;i &lt; r;i++) vec[i].clear(); int cnt = 0; for(int i = l;i &lt; r;i++) &#123; node[cnt].val = (p[Index[i]].first &amp; ((1&lt;&lt;(n-1))-1) ); node[cnt].id = i; cnt++; &#125; sort(node,node+cnt,cmp); for(int i = 1;i &lt; cnt;i++) if(node[i-1].val == node[i].val) &#123; vec[node[i-1].id].push_back(node[i].id); vec[node[i].id].push_back(node[i-1].id); &#125; cnt = 0; for(int i = l;i &lt; r;i++) &#123; node[cnt].val = (p[Index[i]].second &amp; ((1&lt;&lt;(n-1))-1)); node[cnt].id = i; cnt++; &#125; sort(node,node+cnt,cmp); for(int i = 1;i &lt; cnt;i++) if(node[i-1].val == node[i].val) &#123; vec[node[i-1].id].push_back(node[i].id); vec[node[i].id].push_back(node[i-1].id); &#125; for(int i = l;i &lt; r;i++)color[i] = -1; for(int i = l;i &lt; r;i++) if(color[i] == -1) dfs(i,0); int cnt1 = l; for(int i = l;i &lt; r;i++) if(color[i] == 0) &#123; tmpIndex[cnt1++] = Index[i]; &#125; int cnt2 = cnt1; for(int i = l;i &lt; r;i++) if(color[i] == 1) &#123; tmpIndex[cnt2++] = Index[i]; ans[Index[i]] += (1&lt;&lt;(n-1)); &#125; for(int i = l;i &lt; r;i++)Index[i] = tmpIndex[i]; solve(n-1,l,cnt1); solve(n-1,cnt1,r);&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n,m; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; m;i++) &#123; Index[i] = i; scanf("%d%d",&amp;p[i].first,&amp;p[i].second); &#125; memset(ans,0,sizeof(ans)); solve(n,0,m); for(int i = 0;i &lt; m;i++) &#123; printf("%d",ans[i]); if(i &lt; m-1)printf(" "); else printf("\n"); &#125; &#125; return 0;&#125; J： Wormly 比较简单的题目，模拟下。 贪心往前移动就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* ***************Author :kuangbinCreated Time :2014/6/14 11:44:30File Name :E:\2014ACM\区域赛练习\2010\2010NWERC\J.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 1000010;int loc[MAXN];int pre[MAXN];char str[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int L,b,n; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;L,&amp;b,&amp;n); scanf("%s",str+1); int cnt = 0; for(int i = 1;i &lt;= n;i++) &#123; if(str[i] == '1') &#123; loc[cnt] = i; cnt++; &#125; if(cnt &gt;= L)pre[i] = loc[cnt-L]; else pre[i] = -1; &#125; long long ans = 0; int now_head = b; if(pre[now_head] &gt; 1)ans += L; while(now_head != n) &#123; int tmp = pre[now_head]; int next_head = min(n,tmp+b-1); if(next_head == now_head)break; ans += next_head - now_head; if(pre[next_head] &gt; pre[now_head]) ans += L; now_head = next_head; &#125; if(now_head != n)printf("IMPOSSIBLE\n"); else cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>套题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3074 Sudoku （数独，Dancing Links 精确覆盖）]]></title>
    <url>%2F2014%2F06%2F01%2Fpoj3074sudoku%2F</url>
    <content type="text"><![CDATA[POJ3074经典的数独的题目，Dancing Links 精确覆盖，模板题。**做的Dancing Links 练习：** [http://vjudge.net/contest/view.action?cid=47185#overview](http://vjudge.net/contest/view.action?cid=47185#overview) 3\*3的数独， 转化为精确覆盖的过程也比较容易理解。 行是N\*N\*N 行，列是4\*N*N 列。 Sudoku Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 7940 Accepted: 2822 Description In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example, . 2 7 3 8 . . 1 . . 1 . . . 6 7 3 5 . . . . . . . 2 9 3 . 5 6 9 2 . 8 . . . . . . . . . . . 6 . 1 7 4 5 . 3 6 4 . . . . . . . 9 5 1 8 . . . 7 . . 8 . . 6 5 3 4 . Given some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns. Input The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”. Output For each test case, print a line representing the completed Sudoku puzzle. Sample Input .2738..1..1…6735…….293.5692.8………..6.1745.364…….9518…7..8..6534.……52..8.4……3…9…5.1…6..2..7……..3…..6…1……….7.4…….3.end Sample Output 527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 Source Stanford Local 2006 模板题。 /* ***Author :kuangbinCreated Time :2014/5/30 11:46:50File Name :E:\2014ACM\专题学习\DLX\POJ3074.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int N = 9; //33数独const int MaxN = N\N*N + 10;const int MaxM = N*N*4 + 10;const int maxnode = MaxN4 + MaxM + 10;char g[MaxN];struct DLX{ int n,m,size; int U[maxnode],D[maxnode],R[maxnode],L[maxnode],Row[maxnode],Col[maxnode]; int H[MaxN],S[MaxM]; int ansd,ans[MaxN]; void init(int _n,int _m) { n = _n; m = _m; for(int i = 0;i &lt;= m;i++) { S[i] = 0; U[i] = D[i] = i; L[i] = i-1; R[i] = i+1; } R[m] = 0; L[0] = m; size = m; for(int i = 1;i &lt;= n;i++)H[i] = -1; } void Link(int r,int c) { ++S[Col[++size]=c]; Row[size] = r; D[size] = D[c]; U[D[c]] = size; U[size] = c; D[c] = size; if(H[r] &lt; 0)H[r] = L[size] = R[size] = size; else { R[size] = R[H[r]]; L[R[H[r]]] = size; L[size] = H[r]; R[H[r]] = size; } } void remove(int c) { L[R[c]] = L[c]; R[L[c]] = R[c]; for(int i = D[c];i != c;i = D[i]) for(int j = R[i];j != i;j = R[j]) { U[D[j]] = U[j]; D[U[j]] = D[j]; –S[Col[j]]; } } void resume(int c) { for(int i = U[c];i != c;i = U[i]) for(int j = L[i];j != i;j = L[j]) ++S[Col[U[D[j]]=D[U[j]]=j]]; L[R[c]] = R[L[c]] = c; } bool Dance(int d) { if(R[0] == 0) { for(int i = 0;i &lt; d;i++)g[(ans[i]-1)/9] = (ans[i]-1)%9 + ‘1’; for(int i = 0;i &lt; NN;i++)printf(“%c”,g[i]); printf(“\n”); return true; } int c = R[0]; for(int i = R[0];i != 0;i = R[i]) if(S[i] &lt; S[c]) c = i; remove(c); for(int i = D[c];i != c;i = D[i]) { ans[d] = Row[i]; for(int j = R[i];j != i;j = R[j])remove(Col[j]); if(Dance(d+1))return true; for(int j = L[i];j != i;j = L[j])resume(Col[j]); } resume(c); return false; }};void place(int &amp;r,int &amp;c1,int &amp;c2,int &amp;c3,int &amp;c4,int i,int j,int k){ r = (i*N+j)*N + k; c1 = i*N+j+1; c2 = N*N+iN+k; c3 = N\N*2+j*N+k; c4 = N*N*3+((i/3)*3+(j/3))N+k;}DLX dlx;int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%s”,g) == 1) { if(strcmp(g,”end”) == 0)break; dlx.init(N\N*N,N*N*4); int r,c1,c2,c3,c4; for(int i = 0;i &lt; N;i++) for(int j = 0;j &lt; N;j++) for(int k = 1;k &lt;= N;k++) if(g[i*N+j] == ‘.’ || g[i*N+j] == ‘0’+k) { place(r,c1,c2,c3,c4,i,j,k); dlx.Link(r,c1); dlx.Link(r,c2); dlx.Link(r,c3); dlx.Link(r,c4); } dlx.Dance(0); } return 0;}]]></content>
      <categories>
        <category>Dancing Links</category>
        <category>Online Judge</category>
        <category>POJ</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Dancing Links</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙大月赛 ZOJ Monthly, June 2014]]></title>
    <url>%2F2014%2F06%2F01%2Fzoj-monthly-june-2014%2F</url>
    <content type="text"><![CDATA[134 - ZOJ Monthly, June 2014 2014.6.1 Link: http://acm.zju.edu.cn/onlinejudge/contestInfo.do?contestId=356 现在只会做其中的7题，另外3题留个坑，等待总结！ A： ZOJ3788 Another Recurrence Sequence 坑！！！！待补！ I： ZOJ3796 Left 4 Dead 坑！！！！待补！ J： ZOJ3797 Sister’s Noise 坑！！！！待补！ B： ZOJ3789 Gears 题意就不赘述了！ 简单的带权并查集，很常见的题目。 其中有个删除操作，我是直接新建一个点。 /* ***Author :kuangbinCreated Time :2014/6/1 13:47:17File Name :E:\2014ACM\比赛\浙大月赛June2014\B.cpp ************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 600010;int F[MAXN];int num[MAXN];int val[MAXN];int find(int x){ if(F[x] == -1)return x; int tmp = find(F[x]); val[x] = (val[x] + val[F[x]])%2; return F[x] = tmp;}void bing(int x,int y){ int t1 = find(x); int t2 = find(y); if(t1 != t2) { F[t1] = t2; num[t2] += num[t1]; val[t1] = (val[y]-val[x]+1)%2; }}int a[MAXN];char op[10]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2) { for(int i = 1;i &lt;= n+m;i++) { F[i] = -1; num[i] = 1; val[i] = 0; a[i] = i; } int now = n+1; int u,v; while(m–) { scanf(“%s”,op); if(op[0] == ‘L’) { scanf(“%d%d”,&amp;u,&amp;v); bing(a[u],a[v]); } else if(op[0] == ‘D’) { scanf(“%d”,&amp;u); num[find(a[u])]–; a[u] = now++; } else if(op[0] == ‘Q’) { scanf(“%d%d”,&amp;u,&amp;v); if(find(a[u]) == find(a[v])) { if(val[a[u]] == val[a[v]]) printf(“Same\n”); else printf(“Different\n”); } else printf(“Unknown\n”); } else { scanf(“%d”,&amp;u); printf(“%d\n”,num[find(a[u])]); } } } return 0;} C： ZOJ3790 Consecutive Blocks 题意是给了一个长度为N(1&lt;=N&lt;=10^5)的序列，要求在最多删掉K个数的情况下，得到的连续相等序列长度。 大致思路，就是枚举起点，然后找最右可以到哪个终点组成相等序列，当然两端的数相等，中间不等的数就是要删掉的。 可以二分去查找，复杂度就是 nlogn了 做法就是先离散化一下。 然后把这些数存入不同的vector里面，对每个数进行计算即可。 /* ***Author :kuangbinCreated Time :2014/6/1 12:22:44File Name :E:\2014ACM\比赛\浙大月赛June2014\C.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 100010;int a[MAXN];int b[MAXN];vectorvec[MAXN]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,k; while(scanf(“%d%d”,&amp;n,&amp;k) == 2) { for(int i = 0;i &lt; n;i++) { scanf(“%d”,&amp;a[i]); b[i] = a[i]; } sort(b,b+n); int m = unique(b,b+n) - b; map&lt;int,int&gt;mp; for(int i = 0;i &lt; m;i++) mp[b[i]] = i; for(int i = 0;i &lt; n;i++) a[i] = mp[a[i]]; for(int i = 0;i &lt; m;i++) vec[i].clear(); for(int i =0;i &lt; n;i++) vec[a[i]].push_back(i); int ans = 0; for(int i = 0;i &lt; m;i++) { int sz = vec[i].size(); for(int j = 0;j &lt; sz;j++) vec[i][j] -= j; for(int j = 0;j &lt; sz;j++) { int t = upper_bound(vec[i].begin(),vec[i].end(),vec[i][j]+k) - vec[i].begin(); t–; ans = max(ans,t-j+1); } } printf(“%d\n”,ans); } return 0;} D： ZOJ3791 An Easy Game 题意就是给了两个长度为n的01串s1,s2 每步操作必须选择其中的m个数进行翻转。 问经过k步从s1变换到s2的方法数。 很明显的DP。 我是使用dp[i][j] 表示经过i步，变换为j个不同的方法数 初始化是dp[0][cnt] = 1 其中cnt是指原来s1,s2 不同的位数。 最终答案是dp[k][0], 因为经过k步完全要不同。 转移也很简单了，比如现在是dp[i][j] 那么有i位是不同的， n-i位是相同的。 枚举要变换的m位里面有多少个相同，多少个不同。 这样就转移过去了。 /* ***Author :kuangbinCreated Time :2014/6/1 12:57:31File Name :E:\2014ACM\比赛\浙大月赛June2014\D.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MOD = 1e9+9;int C[220][220];void init(){ C[0][0] = 1; for(int i = 1;i &lt;= 200;i++) { C[i][0] = C[i][i] = 1; for(int j = 1;j &lt; i;j++) { C[i][j] = C[i-1][j] + C[i-1][j-1]; if(C[i][j] &gt;= MOD)C[i][j] -= MOD; } }}int n,m,k;int dp[200][200];char str1[200],str2[200]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); init(); while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m) == 3) { scanf(“%s%s”,str1,str2); int cnt = 0; for(int i = 0;i &lt; n;i++) if(str1[i] != str2[i]) cnt++; memset(dp,0,sizeof(dp)); dp[0][cnt] = 1; for(int i = 0;i &lt; k;i++) for(int j = 0;j &lt;= n;j++) if(dp[i][j]) { for(int x = 0;x &lt;= j &amp;&amp; x &lt;= m;x++) if(m-x &lt;= n-j) { long long tmp = (long long)C[j][x]C[n-j][m-x]%MOD; tmp = tmpdp[i][j]%MOD; dp[i+1][j-x+m-x] += tmp; if(dp[i+1][j-x+m-x]&gt;=MOD)dp[i+1][j-x+m-x] -= MOD; } } printf(“%d\n”,dp[k][0]); } return 0;} E： [ZOJ3792](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3792) Romantic Value 其实就是求最小割。 最小割等于最大流。 求出的最小割，一个是要求出 割最小，此外还要选择的割边尽量少。 我是把边的权值乘以2000， 然后+1 这样%2000就是最小割的边数， /2000就是最小割了。 /* ***Author :kuangbinCreated Time :2014/6/1 13:23:33File Name :E:\2014ACM\比赛\浙大月赛June2014\E.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MAXN = 1010;//点数的最大值const int MAXM = 40010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge{ int to,next,cap,flow;}edge[MAXM];//注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init(){ tol = 0; memset(head,-1,sizeof(head));}//加边，单向图三个参数，双向图四个参数void addedge(int u,int v,int w,int rw=0){ edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u]; edge[tol].flow = 0;head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v]; edge[tol].flow = 0;head[v]=tol++;}//输入参数：起点、终点、点的总数//点的编号没有影响，只要输入点的总数long long sap(int start,int end,int N){ memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; long long ans = 0; while(dep[start] &lt; N) { if(u == end) { long long Min = INF; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) { edge[i].flow += Min; edge[i^1].flow -= Min; } u = start; ans += Min; continue; } bool flag = false; int v; for(int i = cur[u]; i != -1;i = edge[i].next) { v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) { flag = true; cur[u] = pre[v] = i; break; } } if(flag) { u = v; continue; } int Min = N; for(int i = head[u]; i != -1;i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) { Min = dep[edge[i].to]; cur[u] = i; } gap[dep[u]]–; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; } return ans;} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n,m,p,q; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d%d%d”,&amp;n,&amp;m,&amp;p,&amp;q); int sum = 0; int u,v,w; init(); while(m–) { scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w); addedge(u,v,w*2000+1,w*2000+1); sum += w; } long long ans = sap(p,q,n); int ans1 = ans/2000; int ans2 = ans%2000; if(ans == 0)printf(“Inf\n”); else printf(“%.2lf\n”,(double)(sum-ans1)/ans2); } return 0;} F： ZOJ3793 First Digit 水题。 纯签到，我是全部输出1，然后就 抢了个FB了。 /* ***Author :kuangbinCreated Time :2014/6/1 12:06:17File Name :E:\2014ACM\比赛\浙大月赛June2014\F.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; scanf(“%d”,&amp;T); int a,b; while(T–) { scanf(“%d%d”,&amp;a,&amp;b); printf(“1\n”); } return 0; } G： ZOJ3794 Greedy Driver 题目比较长，意思不讲了。 我是从起点和终点分别bfs一次。 求出从起点出发，可以达到某一个点剩余的最大油量。 求出 在某一个点剩余最少流量可以到达终点。 两个相减就可以了。 /* ***Author :kuangbinCreated Time :2014/6/1 14:12:57File Name :E:\2014ACM\比赛\浙大月赛June2014\G.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;const int MAXN = 1010;const int MAXM = 100010;const int INF = 0x3f3f3f3f;struct Edge{ int to,next; int w;}edge[MAXM],redge[MAXM];int head[MAXN],tot;int rhead[MAXN],rtot;void init(){ memset(head,-1,sizeof(head)); tot = 0; rtot = 0; memset(rhead,-1,sizeof(rhead));}void addedge(int u,int v,int w){ edge[tot].to = v; edge[tot].next = head[u]; edge[tot].w = w; head[u] = tot++; redge[rtot].to = u; redge[rtot].next = rhead[v]; redge[rtot].w = w; rhead[v] = rtot++;}int N,M,C;bool fuel[MAXN];int Max[1010],Min[1010];void bfs1(){ Max[1] = C; queue&lt;pair&lt;int,int&gt; &gt;q; q.push(make_pair(1,C)); while(!q.empty()) { pair&lt;int,int&gt;tmp = q.front(); q.pop(); int u = tmp.first; int v = tmp.second; if(fuel[u]) { if(Max[u] &lt; C) { Max[u] = C; q.push(make_pair(u,C)); } } for(int i = head[u];i != -1;i = edge[i].next) { int to = edge[i].to; if(edge[i].w &lt;= v &amp;&amp; Max[to] &lt; v - edge[i].w) { Max[to] = v-edge[i].w; q.push(make_pair(to,v-edge[i].w)); } } } }void bfs2(){ queue&lt;pair&lt;int,int&gt; &gt;q; Min[N] = 0; q.push(make_pair(N,0)); while(!q.empty()) { pair&lt;int,int&gt; tmp = q.front(); q.pop(); int u = tmp.first; int v = tmp.second; // printf(“%d %d\n”,u,v); if(fuel[u]) { if(Min[u] &gt; 0) { Min[u] = 0; q.push(make_pair(u,0)); } } for(int i = rhead[u];i != -1;i = redge[i].next) { int to = redge[i].to; if(v + redge[i].w &lt;= C &amp;&amp; Min[to] &gt; v + redge[i].w) { Min[to] = v + redge[i].w; q.push(make_pair(to,v+redge[i].w)); } } }} int c[1010]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); while(scanf(“%d%d%d”,&amp;N,&amp;M,&amp;C) == 3) { int u,v,w; init(); while(M–) { scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w); addedge(u,v,w); } memset(fuel,false,sizeof(fuel)); scanf(“%d”,&amp;M); while(M–) { scanf(“%d”,&amp;u); fuel[u] = true; } for(int i =1 ;i &lt;= N;i++) { Min[i] = INF; Max[i] = -INF; } bfs1(); bfs2(); //for(int i = 1;i &lt;= N;i++) // printf(“%d %d**\n”,Min[i],Max[i]); memset(c,-1,sizeof(c)); scanf(“%d”,&amp;M); while(M–) { scanf(“%d%d”,&amp;u,&amp;v); c[u] = max(c[u],v); } int ans = 0; for(int i = 1;i &lt;= N;i++) if(c[i] != -1 &amp;&amp; Min[i] != INF &amp;&amp; Max[i] != -INF) { if(Max[i] &gt;= Min[i]) ans = max(ans,c[i](Max[i] - Min[i])); } if(Min[1] &gt; C) ans = -1; printf(“%d\n”,ans); } return 0;} H： ZOJ3795 Grouping 使用有向图的强连通分量缩点吗， 然后求出一条最长链，就是答案了。 /* ***Author :kuangbinCreated Time :2014/6/1 12:37:28File Name :E:\2014ACM\比赛\浙大月赛June2014\H.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std;/* * Tarjan算法 * 复杂度O(N+M) */const int MAXN = 100010;//点数const int MAXM = 300010;//边数struct Edge{ int to,next;}edge[MAXM];int head[MAXN],tot;int Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];//Belong数组的值是1~sccint Index,top;int scc;//强连通分量的个数bool Instack[MAXN];int num[MAXN];//各个强连通分量包含点的个数，数组编号1~scc//num数组不一定需要，结合实际情况 void addedge(int u,int v){ edge[tot].to = v;edge[tot].next = head[u];head[u] = tot++;}void Tarjan(int u){ int v; Low[u] = DFN[u] = ++Index; Stack[top++] = u; Instack[u] = true; for(int i = head[u];i != -1;i = edge[i].next) { v = edge[i].to; if( !DFN[v] ) { Tarjan(v); if( Low[u] &gt; Low[v] )Low[u] = Low[v]; } else if(Instack[v] &amp;&amp; Low[u] &gt; DFN[v]) Low[u] = DFN[v]; } if(Low[u] == DFN[u]) { scc++; do { v = Stack[–top]; Instack[v] = false; Belong[v] = scc; num[scc]++; } while( v != u); }}void solve(int N){ memset(DFN,0,sizeof(DFN)); memset(Instack,false,sizeof(Instack)); memset(num,0,sizeof(num)); Index = scc = top = 0; for(int i = 1;i &lt;= N;i++) if(!DFN[i]) Tarjan(i);}void init(){ tot = 0; memset(head,-1,sizeof(head));}int dp[MAXN];vectorvec[MAXN]; int dfs(int u){ if(dp[u] != -1)return dp[u]; dp[u] = num[u]; for(int i = 0;i &lt; vec[u].size();i++) { int v = vec[u][i]; dp[u] = max(dp[u],num[u] + dfs(v)); } return dp[u];} int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int n,m; while(scanf(“%d%d”,&amp;n,&amp;m) == 2) { init(); int u,v; for(int i = 0;i &lt; m;i++) { scanf(“%d%d”,&amp;u,&amp;v); addedge(u,v); } solve(n); for(int i = 1;i &lt;= scc;i++)vec[i].clear(); for(u = 1;u &lt;= n;u++) { for(int i = head[u];i != -1;i = edge[i].next) { v = edge[i].to; if(Belong[u] != Belong[v]) { vec[Belong[u]].push_back(Belong[v]); } } } int ans = 0; memset(dp,-1,sizeof(dp)); for(int i = 1;i &lt;= scc;i++) ans = max(ans,dfs(i)); printf(“%d\n”,ans); } return 0;}]]></content>
      <categories>
        <category>Contest</category>
        <category>Online Judge</category>
        <category>ZJU</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4069 Squiggly Sudoku （精确覆盖 Dancing Links）]]></title>
    <url>%2F2014%2F05%2F31%2Fhdu4069-dlx%2F</url>
    <content type="text"><![CDATA[HDU4069 变形的数独问题，就是Dancing Links 的精确覆盖模板题了。 题目： Squiggly SudokuTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 1420 Accepted Submission(s): 588 Problem Description Today we play a squiggly sudoku, The objective is to fill a 9*9 grid with digits so that each column, each row, and each of the nine Connecting-sub-grids that compose the grid contains all of the digits from 1 to 9. Left figure is the puzzle and right figure is one solution. Now, give you the information of the puzzle, please tell me is there no solution or multiple solution or one solution. Input The first line is a number T(1&lt;=T&lt;=2500), represents the number of case. The next T blocks follow each indicates a case. Each case contains nine lines, Each line contains nine integers. Each module number tells the information of the gird and is the sum of up to five integers: 0~9: ‘0’ means this gird is empty, ‘1’ - ‘9’ means the gird is already filled in. 16: wall to the up 32: wall to the right 64: wall to the down 128: wall to the left I promise there must be nine Connecting-sub-grids, and each contains nine girds. Output For each case, if there are Multiple Solutions or no solution just output “Multiple Solutions” or “No solution”. Else output the exclusive solution.(as shown in the sample output) Sample Input 3144 18 112 208 80 25 54 144 48135 38 147 80 121 128 97 130 32137 32 160 144 114 167 208 0 32192 100 160 160 208 96 183 192 101209 80 39 192 86 48 136 80 114152 48 226 144 112 160 160 149 48128 0 112 166 215 96 160 128 41128 39 153 32 209 80 101 136 35192 96 200 67 80 112 208 68 96 144 48 144 81 81 16 53 144 48128 96 224 144 48 128 103 128 38163 208 80 0 37 224 209 0 32135 48 176 192 64 112 176 192 104192 101 128 89 80 82 32 150 48149 48 224 208 16 48 224 192 33128 0 114 176 135 0 80 112 169137 32 148 32 192 96 176 144 32192 96 193 64 80 80 96 192 96 144 88 48 217 16 16 80 112 176224 176 129 48 128 40 208 16 37145 32 128 96 196 96 176 136 32192 32 227 176 144 80 96 192 32176 192 80 98 160 145 80 48 224128 48 144 80 96 224 183 128 48128 36 224 144 51 144 32 128 105131 64 112 136 32 192 36 224 176224 208 80 64 64 116 192 83 96 Sample Output Case 1:521439678763895124984527361346182795157964832812743956235678419479216583698351247Case 2:No solutionCase 3:Multiple Solutions Source The 36th ACM/ICPC Asia Regional Fuzhou Site —— Online Contest 和普通数独不一样的就是 分小块不一样， bfs一下就可以了。 此题要判断是唯一解 、还是多解、还是无解。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393/* ***************Author :kuangbinCreated Time :2014/5/31 12:05:46File Name :E:\2014ACM\专题学习\DLX\HDU4069.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int N = 9; //3*3数独const int MaxN = N*N*N + 10;const int MaxM = N*N*4 + 10;const int maxnode = MaxN*4 + MaxM + 10;char g[MaxN];int cnt;struct DLX&#123; int n,m,size; int U[maxnode],D[maxnode],R[maxnode],L[maxnode],Row[maxnode],Col[maxnode]; int H[MaxN],S[MaxM]; int ansd,ans[MaxN]; void init(int _n,int _m) &#123; n = _n; m = _m; for(int i = 0;i &lt;= m;i++) &#123; S[i] = 0; U[i] = D[i] = i; L[i] = i-1; R[i] = i+1; &#125; R[m] = 0; L[0] = m; size = m; for(int i = 1;i &lt;= n;i++)H[i] = -1; &#125; void Link(int r,int c) &#123; ++S[Col[++size]=c]; Row[size] = r; D[size] = D[c]; U[D[c]] = size; U[size] = c; D[c] = size; if(H[r] &lt; 0)H[r] = L[size] = R[size] = size; else &#123; R[size] = R[H[r]]; L[R[H[r]]] = size; L[size] = H[r]; R[H[r]] = size; &#125; &#125; void remove(int c) &#123; L[R[c]] = L[c]; R[L[c]] = R[c]; for(int i = D[c];i != c;i = D[i]) for(int j = R[i];j != i;j = R[j]) &#123; U[D[j]] = U[j]; D[U[j]] = D[j]; --S[Col[j]]; &#125; &#125; void resume(int c) &#123; for(int i = U[c];i != c;i = U[i]) for(int j = L[i];j != i;j = L[j]) ++S[Col[U[D[j]]=D[U[j]]=j]]; L[R[c]] = R[L[c]] = c; &#125; void Dance(int d) &#123; if(cnt &gt; 1)return; if(R[0] == 0) &#123; for(int i = 0;i &lt; d;i++)g[(ans[i]-1)/9] = (ans[i]-1)%9 + '1'; cnt++; return; &#125; int c = R[0]; for(int i = R[0];i != 0;i = R[i]) if(S[i] &lt; S[c]) c = i; remove(c); for(int i = D[c];i != c;i = D[i]) &#123; ans[d] = Row[i]; for(int j = R[i];j != i;j = R[j])remove(Col[j]); Dance(d+1); if(cnt &gt; 1)return; for(int j = L[i];j != i;j = L[j])resume(Col[j]); &#125; resume(c); &#125;&#125;;int id[20][20];int a[20][20];void bfs(int sx,int sy,int d)&#123; queue&lt;pair&lt;int,int&gt; &gt;q; q.push(make_pair(sx,sy)); id[sx][sy] = d; while(!q.empty()) &#123; pair&lt;int,int&gt; tmp = q.front(); int x = tmp.first; int y = tmp.second; q.pop(); if(x &gt; 0 &amp;&amp; ((a[x][y]%32)/16) == 0) if(id[x-1][y] == -1) &#123; id[x-1][y] = d; q.push(make_pair(x-1,y)); &#125; if(x &lt; N-1 &amp;&amp; ((a[x][y]%128)/64) == 0) if(id[x+1][y] == -1) &#123; id[x+1][y] = d; q.push(make_pair(x+1,y)); &#125; if(y &gt; 0 &amp;&amp; ((a[x][y])/128) == 0) if(id[x][y-1] == -1) &#123; id[x][y-1] = d; q.push(make_pair(x,y-1)); &#125; if(y &lt; N-1 &amp;&amp; ((a[x][y]%64)/32) == 0) if(id[x][y+1] == -1) &#123; id[x][y+1] = d; q.push(make_pair(x,y+1)); &#125; &#125;&#125;DLX dlx;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; scanf("%d",&amp;T); int iCase = 0; while(T--) &#123; iCase++; for(int i = 0;i &lt; N;i++) for(int j = 0;j &lt; N;j++) scanf("%d",&amp;a[i][j]); memset(id,-1,sizeof(id)); int index = 0; for(int i = 0;i &lt; N;i++) for(int j = 0;j &lt; N;j++) if(id[i][j] == -1) bfs(i,j,++index); dlx.init(N*N*N,N*N*4); for(int i = 0;i &lt; N;i++) for(int j = 0;j &lt; N;j++) for(int k = 1;k &lt;= N;k++) &#123; if(a[i][j]%16 != 0 &amp;&amp; a[i][j]%16 != k)continue; int r = (i*N+j)*N + k; int c1 = i*N+j+1; int c2 = N*N+i*N+k; int c3 = N*N*2+j*N+k; int c4 = N*N*3+(id[i][j]-1)*N+k; dlx.Link(r,c1); dlx.Link(r,c2); dlx.Link(r,c3); dlx.Link(r,c4); &#125; cnt = 0; dlx.Dance(0); printf("Case %d:\n",iCase); if(cnt == 0)printf("No solution\n"); else if(cnt &gt; 1)printf("Multiple Solutions\n"); else &#123; for(int i = 0;i &lt; N*N;i++) &#123; printf("%c",g[i]); if(i % N == N - 1) printf("\n"); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Online Judge</category>
        <category>HDU</category>
        <category>算法</category>
        <category>Dancing Links</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>Dancing Links</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACdream原创群赛(12)のBUAA选拔赛]]></title>
    <url>%2F2014%2F05%2F31%2Facdream12%2F</url>
    <content type="text"><![CDATA[链接： http://acdream.info/onecontest/1021#overview水了一发这次的比赛，简单记录下题解吧!A： 直接数学公式搞。 n个非负整数的和为m的解个数为C(n+m-1,n-1) 如果其中一个位置选择了i, 那么其余的就是C(n-1 + m-i - 1, n-2), 这就是这个位置i出现次数， 然后位置有n个，再乘以n 根据欧拉定理，指数对 1e9+6取模。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/* ***************Author :kuangbinCreated Time :2014/5/30 20:33:18File Name :E:\2014ACM\比赛\ACdream_20140530\A.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MOD = 1e9+7;int C[2020][2020];void init()&#123; C[0][0] = 1; for(int i = 1;i &lt; 2020;i++) &#123; C[i][0] = C[i][i] = 1; for(int j = 1;j &lt; i;j++) &#123; C[i][j] = C[i-1][j] + C[i-1][j-1]; if(C[i][j] &gt;= MOD-1) C[i][j] -= MOD-1; &#125; &#125;&#125;long long pow_m(long long a,long long n)&#123; long long ret = 1; long long tmp = a%MOD; while(n) &#123; if(n&amp;1) &#123; ret = ret*tmp%MOD; &#125; tmp = tmp*tmp%MOD; n &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n,m; scanf("%d",&amp;T); init(); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); if(n == 1) &#123; printf("%d\n",m); continue; &#125; long long ans = 1; for(int j = 1;j &lt;= m;j++) &#123; ans = pow_m(j,(long long)C[n-1+m-j-1][n-2]n%(MOD-1)); ans %= MOD; &#125; printf("%d\n",(int)ans); &#125; return 0;&#125; B: 就是相当于求一个顺时针的多边行包围的数的和。 我是直接看的横线，从左到右减一个矩形，从右到左加一个矩形。 累加起来就是答案了。 [![无标题](http://www.kuangbin.top/wp-content/uploads/2014/05/无标题-300x118.png)](http://www.kuangbin.top/wp-content/uploads/2014/05/无标题.png) 如上图，可以是 3的和 - 1的和 - 2的和， 就是需要求的答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* ***************Author :kuangbinCreated Time :2014/5/30 21:27:59File Name :E:\2014ACM\比赛\ACdream_20140530\B.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int a[1010][1010];long long sum[1010][1010];pair&lt;int,int&gt;p[1010];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n,m; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) scanf("%d",&amp;a[i][j]); memset(sum,0,sizeof(sum)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; sum[i][j] = sum[i][j-1] + sum[i-1][j] + a[i][j] - sum[i-1][j-1]; &#125; int q; scanf("%d",&amp;q); while(q--) &#123; int k; scanf("%d",&amp;k); for(int i = 0;i &lt; k;i++) scanf("%d%d",&amp;p[i].first,&amp;p[i].second); long long ans = 0; for(int i = 0;i &lt; k;i++) &#123; int x1,y1,x2,y2; x1 = p[i].first; y1 = p[i].second; x2 = p[(i+1)%k].first; y2 = p[(i+1)%k].second; swap(x1,y1); swap(x2,y2); if(x1 == x2) &#123; ans += sum[x1][y1] - sum[x1][y2]; &#125; &#125; printf("%d\n",(int)ans); &#125; &#125; return 0;&#125; C： 一个有向图上的DP， 按照拓扑排序的顺序进行DP， DP出，到终点的最快路径，以及删掉一个的情况下最快到达。 对于点u 如果求u到终点的最快时间，直接转移就是了。 求u到终点可以删掉一条边的话， 那么有两种情况，一种是删掉和u相连的边。另外一种是删掉u下面的边。 对于每种情况，要走最快的路， 然后这些里面取最大值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283/* ***************Author :kuangbinCreated Time :2014/5/30 21:50:05File Name :E:\2014ACM\比赛\ACdream_20140530\C.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10010;const int MAXM = 100010;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,w; int next;&#125;edge[MAXM];int head[MAXN],tot;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;int dp1[MAXN];int dp2[MAXN];int n;int a[MAXM];void dfs(int u)&#123; if(u == n-1) &#123; dp1[u] = dp2[u] = 0; return; &#125; dp1[u] = dp2[u] = INF; int sz = 0; int smin = -1; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; dp1[u] = min(dp1[u],dp1[v] + edge[i].w); if(smin == -1)smin = dp2[v] + edge[i].w; else smin = min(smin,dp2[v] + edge[i].w); a[sz++] = dp1[v] + edge[i].w; &#125; a[sz] = INF; for(int i = sz-2;i &gt;= 0;i--) a[i] = min(a[i],a[i+1]); int tmp = INF; dp2[u] = -1; if(smin !=-1)dp2[u] = smin; int tt = 0; for(int i = head[u];i != -1;i = edge[i].next) &#123; int v = edge[i].to; tt++; if(dp2[u] == -1) dp2[u] = min(tmp,a[tt]); else dp2[u] = max(dp2[u],min(tmp,a[tt])); tmp = min(tmp,dp1[v] + edge[i].w); &#125; if(dp2[u] == -1)dp2[u] = INF;&#125;vector&lt;int&gt;vec[MAXN];int in[MAXN];int b[MAXN];int cnt;void get()&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; n;i++) if(in[i] == 0) &#123; q.push(i); &#125; while(!q.empty()) &#123; int u = q.front(); q.pop(); b[cnt++] = u; int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++) &#123; int v = vec[u][i]; in[v]--; if(in[v] == 0) q.push(v); &#125; &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int m; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); init(); int u,v,w; for(int i = 0;i &lt; n;i++) &#123; in[i] = 0; vec[i].clear(); &#125; while(m--) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addedge(u,v,w); vec[v].push_back(u); in[u]++; &#125; cnt = 0; get(); for(int i = 0;i &lt; n;i++) &#123; dfs(b[i]); &#125; if(dp2[0] &gt;= INF)printf("-1\n"); else printf("%d\n",dp2[0]); &#125; return 0;&#125; D： 把K进行质因子分解下，就知道P(n,m) 中含有多少个该质因子了。 然后取最小值 比如 k = p1^k1 * p2^k2 …..pi^ki 如何求出P(n,m) 有多少个pi ,假如有x个，那么所有的 x/ki 求最小值就是答案了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* ***************Author :kuangbinCreated Time :2014/5/30 20:03:09File Name :E:\2014ACM\比赛\ACdream_20140530\D.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;//**************//素数筛选和合数分解const int MAXN=10000000;int prime[MAXN+1];void getPrime()&#123; memset(prime,0,sizeof(prime)); for(int i=2;i&lt;=MAXN;i++) &#123; if(!prime[i])prime[++prime[0]]=i; for(int j=1;j&lt;=prime[0]&amp;&amp;prime[j]&lt;=MAXN/i;j++) &#123; prime[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;long long factor[100][2];int fatCnt;int getFactors(long long x)&#123; fatCnt=0; long long tmp=x; for(int i=1;prime[i]&lt;=tmp/prime[i];i++) &#123; factor[fatCnt][1]=0; if(tmp%prime[i]==0) &#123; factor[fatCnt][0]=prime[i]; while(tmp%prime[i]==0) &#123; factor[fatCnt][1]++; tmp/=prime[i]; &#125; fatCnt++; &#125; &#125; if(tmp!=1) &#123; factor[fatCnt][0]=tmp; factor[fatCnt++][1]=1; &#125; return fatCnt;&#125;//**************long long f[50];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); getPrime(); long long n,m,k; int T; scanf("%d",&amp;T); while(T--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; getFactors(k); long long ans = 1000000000000000000LL; for(int i = 0;i &lt; fatCnt;i++) &#123; //cout&lt;&lt;factor[i][0]&lt;&lt;" "&lt;&lt;factor[i][1]&lt;&lt;endl; long long tmp = factor[i][0]; memset(f,0,sizeof(f)); long long sum = 0; for(int j = 1;j &lt; 40;j++) &#123; if(tmp &gt; n)break; sum += (n/tmp - (n-m)/tmp); tmp *= factor[i][0]; &#125; ans = min(ans,sum/factor[i][1]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; E： 水题： 太水了。。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* ***************Author :kuangbinCreated Time :2014/5/30 18:45:57File Name :E:\2014ACM\比赛\ACdream_20140530\E.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n) == 1) &#123; int ans = 0; int a; for(int i = 0;i &lt; 2*n-1;i++) &#123; scanf("%d",&amp;a); ans ^= a; &#125; printf("%d\n",ans); &#125; return 0;&#125; F： &gt;= 6161 直接构造， &lt; 6161 处理出含有61的数，然后进行背包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/* ***************Author :kuangbinCreated Time :2014/5/30 20:52:11File Name :E:\2014ACM\比赛\ACdream_20140530\F.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;bool check(int n)&#123; int a[20]; int cnt = 0; do &#123; a[cnt++] = n % 10; n /= 10; &#125; while(n); for(int i = 0;i &lt; cnt-1;i++) if(a[i] == 1 &amp;&amp; a[i+1] == 6) return true; return false;&#125;int f[10000];int pre[10000];int a[10000];const int INF = 0x3f3f3f3f;void ouput(int n)&#123; //printf("%d **\n",n); if(pre[n] != 0)ouput(pre[n]); printf(" %d",n - pre[n]);&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; scanf("%d",&amp;T); int num = 0; for(int i = 1;i &lt;= 6161;i++) if(check(i)) a[num++] = i; for(int i = 0;i &lt; 10000;i++) f[i] = INF; f[0] = 0; pre[0] = -1; for(int i = 1;i &lt; 10000;i++) &#123; for(int j = 0;j &lt; num &amp;&amp; a[j] &lt;= i;j++) &#123; if(f[i] &gt; f[i-a[j]]+1) &#123; f[i] = f[i-a[j]] + 1; pre[i] = i-a[j]; &#125; &#125; &#125; while(T--) &#123; scanf("%d",&amp;n); if(check(n)) &#123; printf("1 %d\n",n); continue; &#125; if(n &gt;= 6161) &#123; int ans1 = 0,ans2 = 0; ans1 = 61; ans2 = 6100; n -= 6161; ans2 += n%100; ans1 += (n/100)*100; printf("2 %d %d\n",ans1,ans2); continue; &#125; if(f[n] == INF) &#123; printf("0\n"); continue; &#125; printf("%d",f[n]); ouput(n); printf("\n"); &#125; return 0;&#125; G： 计算几何。 直接枚举两个端点作为直线的两个点，判断直线和线段交。 写搓了，WA好几发，TAT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293/* ***************Author :kuangbinCreated Time :2014/5/30 19:17:18File Name :E:\2014ACM\比赛\ACdream_20140530\G.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;// 计算几何模板const double eps = 1e-8;const double inf = 1e20;const double pi = acos(-1.0);const int maxp = 1010;//Compares a double to zeroint sgn(int x)&#123; if(x == 0)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct Point&#123; int x,y; Point()&#123;&#125; Point(int _x,int _y) &#123; x = _x; y = _y; &#125; void input() &#123; scanf("%d%d",&amp;x,&amp;y); &#125; bool operator == (Point b)const &#123; return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0; &#125; bool operator &lt; (Point b)const &#123; return sgn(x-b.x)== 0?sgn(y-b.y)&lt;0:x&lt;b.x; &#125; Point operator -(const Point &amp;b)const &#123; return Point(x-b.x,y-b.y); &#125; //叉积 int operator ^(const Point &amp;b)const &#123; return x*b.y - y*b.x; &#125; //点积 int operator *(const Point &amp;b)const &#123; return x*b.x + y*b.y; &#125;&#125;;struct Line&#123; Point s,e; Line()&#123;&#125; Line(Point _s,Point _e) &#123; s = _s; e = _e; &#125; bool operator ==(Line v) &#123; return (s == v.s)&amp;&amp;(e == v.e); &#125; void input() &#123; s.input(); e.input(); &#125; //两线段相交判断 //2 规范相交 //1 非规范相交 //0 不相交 int segcrossseg(Line v) &#123; int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); int d3 = sgn((v.e-v.s)^(s-v.s)); int d4 = sgn((v.e-v.s)^(e-v.s)); if( (d1^d2)==-2 &amp;&amp; (d3^d4)==-2 )return 2; return (d1==0 &amp;&amp; sgn((v.s-s)*(v.s-e))&lt;=0) || (d2==0 &amp;&amp; sgn((v.e-s)*(v.e-e))&lt;=0) || (d3==0 &amp;&amp; sgn((s-v.s)*(s-v.e))&lt;=0) || (d4==0 &amp;&amp; sgn((e-v.s)*(e-v.e))&lt;=0); &#125; //直线和线段相交判断 //-*this line -v seg //2 规范相交 //1 非规范相交 //0 不相交 int linecrossseg(Line v) &#123; int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); if((d1^d2)==-2) return 2; return (d1==0||d2==0); &#125;&#125;;Line line[1010];Point p[2010];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); int num = 0; for(int i = 0;i &lt; n;i++) &#123; line[i].input(); p[num++] = line[i].s; p[num++] = line[i].e; &#125; int ans = 0; for(int x= 0;x &lt; num;x++) for(int y = x+1;y &lt; num;y++) &#123; int cnt = 0; if(p[x] == p[y])continue; for(int j = 0;j &lt; n;j++) if(Line(p[x],p[y]).linecrossseg(line[j]) != 0) cnt++; ans = max(ans,cnt); &#125; printf("%d\n",ans); &#125; return 0;&#125; H： 直接构造的。 1 n 2 n-1 3 n-2 .. 这样两端跳就是满足的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* ***************Author :kuangbinCreated Time :2014/5/30 18:50:58File Name :E:\2014ACM\比赛\ACdream_20140530\H.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int n; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i = 0;i &lt; n;i++) &#123; if(i%2 == 0)printf("%d",1+i/2); else printf("%d",n-i/2); if(i &lt; n-1)printf(" "); else printf("\n"); &#125; &#125; return 0;&#125; I： 二分 + 拓扑排序判断 二分枚举，把 &gt; mid的边加入，看能不能拓扑排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/* ***************Author :kuangbinCreated Time :2014/5/30 18:56:04File Name :E:\2014ACM\比赛\ACdream_20140530\I.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAXN = 10010;vector&lt;int&gt;vec[MAXN];int in[MAXN];int n;bool check()&#123; int cnt = 0; queue&lt;int&gt;q; for(int i = 1;i &lt;= n;i++) if(in[i] == 0) &#123; q.push(i); cnt++; &#125; while(!q.empty()) &#123; int u = q.front(); q.pop(); int sz = vec[u].size(); for(int i = 0;i &lt; sz;i++) &#123; int v = vec[u][i]; in[v]--; if(in[v] == 0) &#123; q.push(v); cnt++; &#125; &#125; &#125; return cnt == n;&#125;int a[MAXN],b[MAXN],c[MAXN];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int m; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; m;i++) &#123; scanf("%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i]); &#125; int l = 0, r = 1000000010; int ans = 0; while(l &lt;= r) &#123; for(int i = 1;i &lt;= n;i++) &#123; in[i] = 0; vec[i].clear(); &#125; int mid = (l+r)/2; for(int i = 0;i &lt; m;i++) if(c[i] &gt; mid) &#123; vec[b[i]].push_back(a[i]); in[a[i]]++; &#125; if(check()) &#123; ans = mid; r = mid-1; &#125; else l = mid+1; &#125; printf("%d\n",ans); &#125; return 0;&#125; J： 满二叉树，对称性知道先手必输。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* ***************Author :kuangbinCreated Time :2014/5/30 18:36:54File Name :E:\2014ACM\比赛\ACdream_20140530\J.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; long long n; scanf("%d",&amp;T); while(T--) &#123; cin&gt;&gt;n; printf("Dudu\n"); &#125; return 0;&#125; K： 简单判断下就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* ***************Author :kuangbinCreated Time :2014/5/30 18:32:27File Name :E:\2014ACM\比赛\ACdream_20140530\K.cpp************************************************ */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int T; int A,B,R1,R2; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;A,&amp;B,&amp;R1,&amp;R2); int R = max(R1,R2); if(A &lt; 2*R || B &lt; 2*R) &#123; printf("NO\n"); continue; &#125; if(A &gt;= 2*R1+2*R2 || B &gt;= 2*R1+2*R2) &#123; printf("YES\n"); continue; &#125; int tmp1 = A - R1 - R2; int tmp2 = B - R1 - R2; if(tmp1*tmp1 + tmp2*tmp2 &gt;= (R1+R2)*(R1+R2)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; Orz 北航年度人物 董壕！ Orz]]></content>
      <categories>
        <category>Contest</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1084 Square Destroyer （重复覆盖 Dancing Links）]]></title>
    <url>%2F2014%2F05%2F29%2Fpoj1084%2F</url>
    <content type="text"><![CDATA[题目链接：http://poj.org/problem?id=1084Square Destroyer Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 3137 Accepted: 1323 Description The left figure below shows a complete 3*3 grid made with 2*(3*4) (=24) matchsticks. The lengths of all matchsticks are one. You can find many squares of different sizes in the grid. The size of a square is the length of its side. In the grid shown in the left figure, there are 9 squares of size one, 4 squares of size two, and 1 square of size three. Each matchstick of the complete grid is identified with a unique number which is assigned from left to right and from top to bottom as shown in the left figure. If you take some matchsticks out from the complete grid, then some squares in the grid will be destroyed, which results in an incomplete 3*3 grid. The right figure illustrates an incomplete 3*3 grid after removing three matchsticks numbered with 12, 17 and 23. This removal destroys 5 squares of size one, 3 squares of size two, and 1 square of size three. Consequently, the incomplete grid does not have squares of size three, but still has 4 squares of size one and 1 square of size two. As input, you are given a (complete or incomplete) n*n grid made with no more than 2n(n+1) matchsticks for a natural number 5 &lt;= n . Your task is to compute the minimum number of matchsticks taken out to destroy all the squares existing in the input n*n grid. Input The input consists of T test cases. The number of test cases (T ) is given in the first line of the input file. Each test case consists of two lines: The first line contains a natural number n , not greater than 5, which implies you are given a (complete or incomplete) n*n grid as input, and the second line begins with a nonnegative integer k , the number of matchsticks that are missing from the complete n*n grid, followed by k numbers specifying the matchsticks. Note that if k is equal to zero, then the input grid is a complete n*n grid; otherwise, the input grid is an incomplete n*n grid such that the specified k matchsticks are missing from the complete n*n grid. Output Print exactly one line for each test case. The line should contain the minimum number of matchsticks that have to be taken out to destroy all the squares in the input grid. Sample Input 22033 12 17 23 Sample Output 33 Source Taejon 2001 很明显的的重复覆盖模板题，主要是建图过程。Dancing Links模板套一下。 以没有删掉的边为行， 存在的正方形为列。 /* ***Author :kuangbinCreated Time :2014/5/28 23:38:33File Name :E:\2014ACM\专题学习\DLX\POJ1084.cpp************************************************ */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include #include #include #include #include #include #include #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;using namespace std; const int MaxM = 200;const int MaxN = 100;const int maxnode = 20000;const int INF = 0x3f3f3f3f;struct DLX{ int n,m,size; int U[maxnode],D[maxnode],R[maxnode],L[maxnode],Row[maxnode],Col[maxnode]; int H[MaxN],S[MaxM]; int ansd; void init(int _n,int _m) { n = _n; m = _m; for(int i = 0;i &lt;= m;i++) { S[i] = 0; U[i] = D[i] = i; L[i] = i-1; R[i] = i+1; } R[m] = 0; L[0] = m; size = m; for(int i = 1;i &lt;= n;i++)H[i] = -1; } void Link(int r,int c) { ++S[Col[++size]=c]; Row[size] = r; D[size] = D[c]; U[D[c]] = size; U[size] = c; D[c] = size; if(H[r] &lt; 0)H[r] = L[size] = R[size] = size; else { R[size] = R[H[r]]; L[R[H[r]]] = size; L[size] = H[r]; R[H[r]] = size; } } void remove(int c) { for(int i = D[c];i != c;i = D[i]) L[R[i]] = L[i], R[L[i]] = R[i]; } void resume(int c) { for(int i = U[c];i != c;i = U[i]) L[R[i]] = R[L[i]] = i; } bool v[MaxM]; int f() { int ret = 0; for(int c = R[0];c != 0;c = R[c])v[c] = true; for(int c = R[0];c != 0;c = R[c]) if(v[c]) { ret++; v[c] = false; for(int i = D[c];i != c;i = D[i]) for(int j = R[i];j != i;j = R[j]) v[Col[j]] = false; } return ret; } void Dance(int d) { if(d + f() &gt;= ansd)return; if(R[0] == 0) { if(d &lt; ansd)ansd = d; return; } int c = R[0]; for(int i = R[0];i != 0;i = R[i]) if(S[i] &lt; S[c]) c = i; for(int i = D[c];i != c;i = D[i]) { remove(i); for(int j = R[i];j != i;j = R[j])remove(j); Dance(d+1); for(int j = L[i];j != i;j = L[j])resume(j); resume(i); } }};DLX g; int id[20][20];bool f[200];int a[10][10][10];int b[200]; int main(){ //freopen(“in.txt”,”r”,stdin); //freopen(“out.txt”,”w”,stdout); int T; int n; scanf(“%d”,&amp;T); while(T–) { scanf(“%d”,&amp;n); int tot = (2*n+1)*n + n; for(int i = 1;i &lt;= tot;i++)f[i] = true; int m,v; scanf(“%d”,&amp;m); while(m–) { scanf(“%d”,&amp;v); f[v] = false; } int num = 0; for(int i = 1;i &lt;= n+1;i++) { for(int j = 1;j &lt;= n;j++) id[2i-1][j] = (++num); if(i &lt;= n) { for(int j = 0;j &lt;= n;j++) id[2i][j] = (++num); } } int cnt = 0; for(int i = 1;i &lt;= tot;i++) if(f[i]) b[i] = (++cnt); num = 0; memset(a,-1,sizeof(a)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) for(int k = 1;i+k-1 &lt;= n &amp;&amp; j+k-1 &lt;= n;k++) { bool flag = true; for(int x = 0;x &lt; k;x++) if(!f[id[2i-1][j+x]]) flag = false; for(int x = 0;x &lt; k;x++) if(!f[id[2(i+k-1)+1][j+x]]) flag = false; for(int x = 0;x &lt; k;x++) if(!f[id[2(i+x)][j-1]]) flag = false; for(int x = 0;x &lt; k;x++) if(!f[id[2(i+x)][j+k-1]]) flag = false; if(!flag)continue; a[i][j][k] = (++num); } g.init(cnt,num); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) for(int k = 1;i+k-1 &lt;= n &amp;&amp; j+k-1 &lt;= n;k++) if(a[i][j][k] != -1) { for(int x = 0;x &lt; k;x++) { g.Link(b[id[2i-1][j+x]],a[i][j][k]); g.Link(b[id[2(i+k-1)+1][j+x]],a[i][j][k]); g.Link(b[id[2(i+x)][j-1]],a[i][j][k]); g.Link(b[id[2(i+x)][j+k-1]],a[i][j][k]); } } g.ansd = INF; g.Dance(0); printf(“%d\n”,g.ansd); } return 0;}]]></content>
      <categories>
        <category>Dancing Links</category>
        <category>Online Judge</category>
        <category>POJ</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2014%2F05%2F28%2Fnew-start%2F</url>
    <content type="text"><![CDATA[新建了新的网站，以后开始在这里写博客了，记录下点滴的成长历程~~~ 以后要好好学习，多学点有用的东西，认真做好每一件事，fighting! 非常感谢 tsyao 和 EndOfFile 的帮助，在他们的帮助下，建立了这个博客，特别鸣谢！]]></content>
      <categories>
        <category>杂言</category>
      </categories>
  </entry>
</search>
